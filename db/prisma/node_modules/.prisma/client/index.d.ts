
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type chaptersPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "chapters"
  objects: {
    events: eventsPayload<ExtArgs>[]
    user_bans: user_bansPayload<ExtArgs>[]
    chapter_users: chapter_usersPayload<ExtArgs>[]
    chapter_tags: chapter_tagsPayload<ExtArgs>[]
    venues: venuesPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    id: number
    name: string
    description: string
    category: string
    city: string
    region: string
    country: string
    logo_url: string | null
    banner_url: string | null
    calendar_id: string | null
    chat_url: string | null
    creator_id: number
  }, ExtArgs["result"]["chapters"]>
  composites: {}
}

/**
 * Model chapters
 * 
 */
export type chapters = runtime.Types.DefaultSelection<chaptersPayload>
export type sessionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "sessions"
  objects: {
    user: usersPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    user_id: number
  }, ExtArgs["result"]["sessions"]>
  composites: {}
}

/**
 * Model sessions
 * 
 */
export type sessions = runtime.Types.DefaultSelection<sessionsPayload>
export type google_tokensPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "google_tokens"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    email: string
    access_token: string
    refresh_token: string
    expiry_date: bigint
    is_valid: boolean
  }, ExtArgs["result"]["google_tokens"]>
  composites: {}
}

/**
 * Model google_tokens
 * 
 */
export type google_tokens = runtime.Types.DefaultSelection<google_tokensPayload>
export type chapter_usersPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "chapter_users"
  objects: {
    user: usersPayload<ExtArgs>
    chapter: chaptersPayload<ExtArgs>
    chapter_role: chapter_rolesPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    joined_date: Date
    user_id: number
    chapter_id: number
    chapter_role_id: number
    subscribed: boolean
  }, ExtArgs["result"]["chapter_users"]>
  composites: {}
}

/**
 * Model chapter_users
 * 
 */
export type chapter_users = runtime.Types.DefaultSelection<chapter_usersPayload>
export type chapter_rolesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "chapter_roles"
  objects: {
    chapter_users: chapter_usersPayload<ExtArgs>[]
    chapter_role_permissions: chapter_role_permissionsPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    id: number
    name: string
  }, ExtArgs["result"]["chapter_roles"]>
  composites: {}
}

/**
 * Model chapter_roles
 * 
 */
export type chapter_roles = runtime.Types.DefaultSelection<chapter_rolesPayload>
export type chapter_role_permissionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "chapter_role_permissions"
  objects: {
    chapter_role: chapter_rolesPayload<ExtArgs>
    chapter_permission: chapter_permissionsPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    chapter_role_id: number
    chapter_permissions_id: number
  }, ExtArgs["result"]["chapter_role_permissions"]>
  composites: {}
}

/**
 * Model chapter_role_permissions
 * 
 */
export type chapter_role_permissions = runtime.Types.DefaultSelection<chapter_role_permissionsPayload>
export type chapter_permissionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "chapter_permissions"
  objects: {
    chapter_role_permissions: chapter_role_permissionsPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    id: number
    name: string
  }, ExtArgs["result"]["chapter_permissions"]>
  composites: {}
}

/**
 * Model chapter_permissions
 * 
 */
export type chapter_permissions = runtime.Types.DefaultSelection<chapter_permissionsPayload>
export type chapter_tagsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "chapter_tags"
  objects: {
    chapter: chaptersPayload<ExtArgs>
    tag: tagsPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    chapter_id: number
    tag_id: number
  }, ExtArgs["result"]["chapter_tags"]>
  composites: {}
}

/**
 * Model chapter_tags
 * 
 */
export type chapter_tags = runtime.Types.DefaultSelection<chapter_tagsPayload>
export type event_sponsorsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "event_sponsors"
  objects: {
    event: eventsPayload<ExtArgs>
    sponsor: sponsorsPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    sponsor_id: number
    event_id: number
  }, ExtArgs["result"]["event_sponsors"]>
  composites: {}
}

/**
 * Model event_sponsors
 * 
 */
export type event_sponsors = runtime.Types.DefaultSelection<event_sponsorsPayload>
export type event_tagsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "event_tags"
  objects: {
    event: eventsPayload<ExtArgs>
    tag: tagsPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    event_id: number
    tag_id: number
  }, ExtArgs["result"]["event_tags"]>
  composites: {}
}

/**
 * Model event_tags
 * 
 */
export type event_tags = runtime.Types.DefaultSelection<event_tagsPayload>
export type eventsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "events"
  objects: {
    chapter: chaptersPayload<ExtArgs>
    venue: venuesPayload<ExtArgs> | null
    sponsors: event_sponsorsPayload<ExtArgs>[]
    event_tags: event_tagsPayload<ExtArgs>[]
    event_users: event_usersPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    id: number
    name: string
    description: string
    url: string | null
    streaming_url: string | null
    venue_type: events_venue_type_enum
    start_at: Date
    ends_at: Date
    canceled: boolean
    capacity: number
    invite_only: boolean
    image_url: string
    venue_id: number | null
    chapter_id: number
    calendar_event_id: string | null
  }, ExtArgs["result"]["events"]>
  composites: {}
}

/**
 * Model events
 * 
 */
export type events = runtime.Types.DefaultSelection<eventsPayload>
export type event_rolesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "event_roles"
  objects: {
    event_role_permissions: event_role_permissionsPayload<ExtArgs>[]
    event_users: event_usersPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    id: number
    name: string
  }, ExtArgs["result"]["event_roles"]>
  composites: {}
}

/**
 * Model event_roles
 * 
 */
export type event_roles = runtime.Types.DefaultSelection<event_rolesPayload>
export type event_role_permissionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "event_role_permissions"
  objects: {
    event_role: event_rolesPayload<ExtArgs>
    event_permission: event_permissionsPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    event_role_id: number
    event_permission_id: number
  }, ExtArgs["result"]["event_role_permissions"]>
  composites: {}
}

/**
 * Model event_role_permissions
 * 
 */
export type event_role_permissions = runtime.Types.DefaultSelection<event_role_permissionsPayload>
export type event_permissionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "event_permissions"
  objects: {
    event_role_permissions: event_role_permissionsPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    id: number
    name: string
  }, ExtArgs["result"]["event_permissions"]>
  composites: {}
}

/**
 * Model event_permissions
 * 
 */
export type event_permissions = runtime.Types.DefaultSelection<event_permissionsPayload>
export type event_usersPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "event_users"
  objects: {
    user: usersPayload<ExtArgs>
    event: eventsPayload<ExtArgs>
    event_role: event_rolesPayload<ExtArgs>
    attendance: attendancePayload<ExtArgs>
    event_reminder: event_remindersPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    joined_date: Date
    user_id: number
    event_id: number
    event_role_id: number
    attendance_id: number
    subscribed: boolean
    title: string[]
  }, ExtArgs["result"]["event_users"]>
  composites: {}
}

/**
 * Model event_users
 * 
 */
export type event_users = runtime.Types.DefaultSelection<event_usersPayload>
export type event_remindersPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "event_reminders"
  objects: {
    event_user: event_usersPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    user_id: number
    event_id: number
    remind_at: Date
    notifying: boolean
  }, ExtArgs["result"]["event_reminders"]>
  composites: {}
}

/**
 * Model event_reminders
 * 
 */
export type event_reminders = runtime.Types.DefaultSelection<event_remindersPayload>
export type attendancePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "attendance"
  objects: {
    event_users: event_usersPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    id: number
    name: string
  }, ExtArgs["result"]["attendance"]>
  composites: {}
}

/**
 * Model attendance
 * 
 */
export type attendance = runtime.Types.DefaultSelection<attendancePayload>
export type sponsorsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "sponsors"
  objects: {
    event_sponsors: event_sponsorsPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    id: number
    name: string
    website: string
    logo_path: string
    type: string
  }, ExtArgs["result"]["sponsors"]>
  composites: {}
}

/**
 * Model sponsors
 * 
 */
export type sponsors = runtime.Types.DefaultSelection<sponsorsPayload>
export type tagsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "tags"
  objects: {
    chapter_tags: chapter_tagsPayload<ExtArgs>[]
    event_tags: event_tagsPayload<ExtArgs>[]
    venue_tags: venue_tagsPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    id: number
    name: string
  }, ExtArgs["result"]["tags"]>
  composites: {}
}

/**
 * Model tags
 * 
 */
export type tags = runtime.Types.DefaultSelection<tagsPayload>
export type user_bansPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "user_bans"
  objects: {
    chapter: chaptersPayload<ExtArgs>
    user: usersPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    user_id: number
    chapter_id: number
  }, ExtArgs["result"]["user_bans"]>
  composites: {}
}

/**
 * Model user_bans
 * 
 */
export type user_bans = runtime.Types.DefaultSelection<user_bansPayload>
export type instance_permissionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "instance_permissions"
  objects: {
    instance_role_permissions: instance_role_permissionsPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    id: number
    name: string
  }, ExtArgs["result"]["instance_permissions"]>
  composites: {}
}

/**
 * Model instance_permissions
 * 
 */
export type instance_permissions = runtime.Types.DefaultSelection<instance_permissionsPayload>
export type instance_role_permissionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "instance_role_permissions"
  objects: {
    instance_role: instance_rolesPayload<ExtArgs>
    instance_permission: instance_permissionsPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    instance_role_id: number
    instance_permission_id: number
  }, ExtArgs["result"]["instance_role_permissions"]>
  composites: {}
}

/**
 * Model instance_role_permissions
 * 
 */
export type instance_role_permissions = runtime.Types.DefaultSelection<instance_role_permissionsPayload>
export type instance_rolesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "instance_roles"
  objects: {
    instance_role_permissions: instance_role_permissionsPayload<ExtArgs>[]
    users: usersPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    id: number
    name: string
  }, ExtArgs["result"]["instance_roles"]>
  composites: {}
}

/**
 * Model instance_roles
 * 
 */
export type instance_roles = runtime.Types.DefaultSelection<instance_rolesPayload>
export type usersPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "users"
  objects: {
    user_bans: user_bansPayload<ExtArgs>[]
    user_chapters: chapter_usersPayload<ExtArgs>[]
    instance_role: instance_rolesPayload<ExtArgs>
    user_events: event_usersPayload<ExtArgs>[]
    session: sessionsPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    id: number
    name: string
    image_url: string | null
    email: string
    auto_subscribe: boolean
    instance_role_id: number
  }, ExtArgs["result"]["users"]>
  composites: {}
}

/**
 * Model users
 * 
 */
export type users = runtime.Types.DefaultSelection<usersPayload>
export type venue_tagsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "venue_tags"
  objects: {
    venue: venuesPayload<ExtArgs>
    tag: tagsPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    venue_id: number
    tag_id: number
  }, ExtArgs["result"]["venue_tags"]>
  composites: {}
}

/**
 * Model venue_tags
 * 
 */
export type venue_tags = runtime.Types.DefaultSelection<venue_tagsPayload>
export type venuesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "venues"
  objects: {
    events: eventsPayload<ExtArgs>[]
    venue_tags: venue_tagsPayload<ExtArgs>[]
    chapter: chaptersPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    created_at: Date
    updated_at: Date
    id: number
    name: string
    street_address: string | null
    city: string
    postal_code: string
    region: string
    country: string
    latitude: number | null
    longitude: number | null
    chapter_id: number
  }, ExtArgs["result"]["venues"]>
  composites: {}
}

/**
 * Model venues
 * 
 */
export type venues = runtime.Types.DefaultSelection<venuesPayload>

/**
 * Enums
 */

export const events_venue_type_enum: {
  Physical: 'Physical',
  Online: 'Online',
  PhysicalAndOnline: 'PhysicalAndOnline'
};

export type events_venue_type_enum = (typeof events_venue_type_enum)[keyof typeof events_venue_type_enum]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Chapters
 * const chapters = await prisma.chapters.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Chapters
   * const chapters = await prisma.chapters.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.chapters`: Exposes CRUD operations for the **chapters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapters
    * const chapters = await prisma.chapters.findMany()
    * ```
    */
  get chapters(): Prisma.chaptersDelegate<ExtArgs>;

  /**
   * `prisma.sessions`: Exposes CRUD operations for the **sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.sessions.findMany()
    * ```
    */
  get sessions(): Prisma.sessionsDelegate<ExtArgs>;

  /**
   * `prisma.google_tokens`: Exposes CRUD operations for the **google_tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Google_tokens
    * const google_tokens = await prisma.google_tokens.findMany()
    * ```
    */
  get google_tokens(): Prisma.google_tokensDelegate<ExtArgs>;

  /**
   * `prisma.chapter_users`: Exposes CRUD operations for the **chapter_users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapter_users
    * const chapter_users = await prisma.chapter_users.findMany()
    * ```
    */
  get chapter_users(): Prisma.chapter_usersDelegate<ExtArgs>;

  /**
   * `prisma.chapter_roles`: Exposes CRUD operations for the **chapter_roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapter_roles
    * const chapter_roles = await prisma.chapter_roles.findMany()
    * ```
    */
  get chapter_roles(): Prisma.chapter_rolesDelegate<ExtArgs>;

  /**
   * `prisma.chapter_role_permissions`: Exposes CRUD operations for the **chapter_role_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapter_role_permissions
    * const chapter_role_permissions = await prisma.chapter_role_permissions.findMany()
    * ```
    */
  get chapter_role_permissions(): Prisma.chapter_role_permissionsDelegate<ExtArgs>;

  /**
   * `prisma.chapter_permissions`: Exposes CRUD operations for the **chapter_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapter_permissions
    * const chapter_permissions = await prisma.chapter_permissions.findMany()
    * ```
    */
  get chapter_permissions(): Prisma.chapter_permissionsDelegate<ExtArgs>;

  /**
   * `prisma.chapter_tags`: Exposes CRUD operations for the **chapter_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapter_tags
    * const chapter_tags = await prisma.chapter_tags.findMany()
    * ```
    */
  get chapter_tags(): Prisma.chapter_tagsDelegate<ExtArgs>;

  /**
   * `prisma.event_sponsors`: Exposes CRUD operations for the **event_sponsors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Event_sponsors
    * const event_sponsors = await prisma.event_sponsors.findMany()
    * ```
    */
  get event_sponsors(): Prisma.event_sponsorsDelegate<ExtArgs>;

  /**
   * `prisma.event_tags`: Exposes CRUD operations for the **event_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Event_tags
    * const event_tags = await prisma.event_tags.findMany()
    * ```
    */
  get event_tags(): Prisma.event_tagsDelegate<ExtArgs>;

  /**
   * `prisma.events`: Exposes CRUD operations for the **events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.events.findMany()
    * ```
    */
  get events(): Prisma.eventsDelegate<ExtArgs>;

  /**
   * `prisma.event_roles`: Exposes CRUD operations for the **event_roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Event_roles
    * const event_roles = await prisma.event_roles.findMany()
    * ```
    */
  get event_roles(): Prisma.event_rolesDelegate<ExtArgs>;

  /**
   * `prisma.event_role_permissions`: Exposes CRUD operations for the **event_role_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Event_role_permissions
    * const event_role_permissions = await prisma.event_role_permissions.findMany()
    * ```
    */
  get event_role_permissions(): Prisma.event_role_permissionsDelegate<ExtArgs>;

  /**
   * `prisma.event_permissions`: Exposes CRUD operations for the **event_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Event_permissions
    * const event_permissions = await prisma.event_permissions.findMany()
    * ```
    */
  get event_permissions(): Prisma.event_permissionsDelegate<ExtArgs>;

  /**
   * `prisma.event_users`: Exposes CRUD operations for the **event_users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Event_users
    * const event_users = await prisma.event_users.findMany()
    * ```
    */
  get event_users(): Prisma.event_usersDelegate<ExtArgs>;

  /**
   * `prisma.event_reminders`: Exposes CRUD operations for the **event_reminders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Event_reminders
    * const event_reminders = await prisma.event_reminders.findMany()
    * ```
    */
  get event_reminders(): Prisma.event_remindersDelegate<ExtArgs>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.attendanceDelegate<ExtArgs>;

  /**
   * `prisma.sponsors`: Exposes CRUD operations for the **sponsors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sponsors
    * const sponsors = await prisma.sponsors.findMany()
    * ```
    */
  get sponsors(): Prisma.sponsorsDelegate<ExtArgs>;

  /**
   * `prisma.tags`: Exposes CRUD operations for the **tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tags.findMany()
    * ```
    */
  get tags(): Prisma.tagsDelegate<ExtArgs>;

  /**
   * `prisma.user_bans`: Exposes CRUD operations for the **user_bans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_bans
    * const user_bans = await prisma.user_bans.findMany()
    * ```
    */
  get user_bans(): Prisma.user_bansDelegate<ExtArgs>;

  /**
   * `prisma.instance_permissions`: Exposes CRUD operations for the **instance_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instance_permissions
    * const instance_permissions = await prisma.instance_permissions.findMany()
    * ```
    */
  get instance_permissions(): Prisma.instance_permissionsDelegate<ExtArgs>;

  /**
   * `prisma.instance_role_permissions`: Exposes CRUD operations for the **instance_role_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instance_role_permissions
    * const instance_role_permissions = await prisma.instance_role_permissions.findMany()
    * ```
    */
  get instance_role_permissions(): Prisma.instance_role_permissionsDelegate<ExtArgs>;

  /**
   * `prisma.instance_roles`: Exposes CRUD operations for the **instance_roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instance_roles
    * const instance_roles = await prisma.instance_roles.findMany()
    * ```
    */
  get instance_roles(): Prisma.instance_rolesDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.venue_tags`: Exposes CRUD operations for the **venue_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Venue_tags
    * const venue_tags = await prisma.venue_tags.findMany()
    * ```
    */
  get venue_tags(): Prisma.venue_tagsDelegate<ExtArgs>;

  /**
   * `prisma.venues`: Exposes CRUD operations for the **venues** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Venues
    * const venues = await prisma.venues.findMany()
    * ```
    */
  get venues(): Prisma.venuesDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 5.0.0
   * Query Engine version: 6b0aef69b7cdfc787f822ecd7cdc76d5f1991584
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    chapters: 'chapters',
    sessions: 'sessions',
    google_tokens: 'google_tokens',
    chapter_users: 'chapter_users',
    chapter_roles: 'chapter_roles',
    chapter_role_permissions: 'chapter_role_permissions',
    chapter_permissions: 'chapter_permissions',
    chapter_tags: 'chapter_tags',
    event_sponsors: 'event_sponsors',
    event_tags: 'event_tags',
    events: 'events',
    event_roles: 'event_roles',
    event_role_permissions: 'event_role_permissions',
    event_permissions: 'event_permissions',
    event_users: 'event_users',
    event_reminders: 'event_reminders',
    attendance: 'attendance',
    sponsors: 'sponsors',
    tags: 'tags',
    user_bans: 'user_bans',
    instance_permissions: 'instance_permissions',
    instance_role_permissions: 'instance_role_permissions',
    instance_roles: 'instance_roles',
    users: 'users',
    venue_tags: 'venue_tags',
    venues: 'venues'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'chapters' | 'sessions' | 'google_tokens' | 'chapter_users' | 'chapter_roles' | 'chapter_role_permissions' | 'chapter_permissions' | 'chapter_tags' | 'event_sponsors' | 'event_tags' | 'events' | 'event_roles' | 'event_role_permissions' | 'event_permissions' | 'event_users' | 'event_reminders' | 'attendance' | 'sponsors' | 'tags' | 'user_bans' | 'instance_permissions' | 'instance_role_permissions' | 'instance_roles' | 'users' | 'venue_tags' | 'venues'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      chapters: {
        payload: chaptersPayload<ExtArgs>
        fields: Prisma.chaptersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chaptersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chaptersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chaptersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chaptersPayload>
          }
          findFirst: {
            args: Prisma.chaptersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chaptersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chaptersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chaptersPayload>
          }
          findMany: {
            args: Prisma.chaptersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chaptersPayload>[]
          }
          create: {
            args: Prisma.chaptersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chaptersPayload>
          }
          createMany: {
            args: Prisma.chaptersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.chaptersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chaptersPayload>
          }
          update: {
            args: Prisma.chaptersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chaptersPayload>
          }
          deleteMany: {
            args: Prisma.chaptersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.chaptersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.chaptersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chaptersPayload>
          }
          aggregate: {
            args: Prisma.ChaptersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChapters>
          }
          groupBy: {
            args: Prisma.chaptersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ChaptersGroupByOutputType>[]
          }
          count: {
            args: Prisma.chaptersCountArgs<ExtArgs>,
            result: $Utils.Optional<ChaptersCountAggregateOutputType> | number
          }
        }
      }
      sessions: {
        payload: sessionsPayload<ExtArgs>
        fields: Prisma.sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sessionsPayload>
          }
          findFirst: {
            args: Prisma.sessionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sessionsPayload>
          }
          findMany: {
            args: Prisma.sessionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sessionsPayload>[]
          }
          create: {
            args: Prisma.sessionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sessionsPayload>
          }
          createMany: {
            args: Prisma.sessionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.sessionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sessionsPayload>
          }
          update: {
            args: Prisma.sessionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sessionsPayload>
          }
          deleteMany: {
            args: Prisma.sessionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.sessionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.sessionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sessionsPayload>
          }
          aggregate: {
            args: Prisma.SessionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSessions>
          }
          groupBy: {
            args: Prisma.sessionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionsCountArgs<ExtArgs>,
            result: $Utils.Optional<SessionsCountAggregateOutputType> | number
          }
        }
      }
      google_tokens: {
        payload: google_tokensPayload<ExtArgs>
        fields: Prisma.google_tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.google_tokensFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<google_tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.google_tokensFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<google_tokensPayload>
          }
          findFirst: {
            args: Prisma.google_tokensFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<google_tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.google_tokensFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<google_tokensPayload>
          }
          findMany: {
            args: Prisma.google_tokensFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<google_tokensPayload>[]
          }
          create: {
            args: Prisma.google_tokensCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<google_tokensPayload>
          }
          createMany: {
            args: Prisma.google_tokensCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.google_tokensDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<google_tokensPayload>
          }
          update: {
            args: Prisma.google_tokensUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<google_tokensPayload>
          }
          deleteMany: {
            args: Prisma.google_tokensDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.google_tokensUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.google_tokensUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<google_tokensPayload>
          }
          aggregate: {
            args: Prisma.Google_tokensAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGoogle_tokens>
          }
          groupBy: {
            args: Prisma.google_tokensGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Google_tokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.google_tokensCountArgs<ExtArgs>,
            result: $Utils.Optional<Google_tokensCountAggregateOutputType> | number
          }
        }
      }
      chapter_users: {
        payload: chapter_usersPayload<ExtArgs>
        fields: Prisma.chapter_usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chapter_usersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chapter_usersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_usersPayload>
          }
          findFirst: {
            args: Prisma.chapter_usersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chapter_usersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_usersPayload>
          }
          findMany: {
            args: Prisma.chapter_usersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_usersPayload>[]
          }
          create: {
            args: Prisma.chapter_usersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_usersPayload>
          }
          createMany: {
            args: Prisma.chapter_usersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.chapter_usersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_usersPayload>
          }
          update: {
            args: Prisma.chapter_usersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_usersPayload>
          }
          deleteMany: {
            args: Prisma.chapter_usersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.chapter_usersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.chapter_usersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_usersPayload>
          }
          aggregate: {
            args: Prisma.Chapter_usersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChapter_users>
          }
          groupBy: {
            args: Prisma.chapter_usersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Chapter_usersGroupByOutputType>[]
          }
          count: {
            args: Prisma.chapter_usersCountArgs<ExtArgs>,
            result: $Utils.Optional<Chapter_usersCountAggregateOutputType> | number
          }
        }
      }
      chapter_roles: {
        payload: chapter_rolesPayload<ExtArgs>
        fields: Prisma.chapter_rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chapter_rolesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chapter_rolesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_rolesPayload>
          }
          findFirst: {
            args: Prisma.chapter_rolesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chapter_rolesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_rolesPayload>
          }
          findMany: {
            args: Prisma.chapter_rolesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_rolesPayload>[]
          }
          create: {
            args: Prisma.chapter_rolesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_rolesPayload>
          }
          createMany: {
            args: Prisma.chapter_rolesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.chapter_rolesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_rolesPayload>
          }
          update: {
            args: Prisma.chapter_rolesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_rolesPayload>
          }
          deleteMany: {
            args: Prisma.chapter_rolesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.chapter_rolesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.chapter_rolesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_rolesPayload>
          }
          aggregate: {
            args: Prisma.Chapter_rolesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChapter_roles>
          }
          groupBy: {
            args: Prisma.chapter_rolesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Chapter_rolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.chapter_rolesCountArgs<ExtArgs>,
            result: $Utils.Optional<Chapter_rolesCountAggregateOutputType> | number
          }
        }
      }
      chapter_role_permissions: {
        payload: chapter_role_permissionsPayload<ExtArgs>
        fields: Prisma.chapter_role_permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chapter_role_permissionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_role_permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chapter_role_permissionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_role_permissionsPayload>
          }
          findFirst: {
            args: Prisma.chapter_role_permissionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_role_permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chapter_role_permissionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_role_permissionsPayload>
          }
          findMany: {
            args: Prisma.chapter_role_permissionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_role_permissionsPayload>[]
          }
          create: {
            args: Prisma.chapter_role_permissionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_role_permissionsPayload>
          }
          createMany: {
            args: Prisma.chapter_role_permissionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.chapter_role_permissionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_role_permissionsPayload>
          }
          update: {
            args: Prisma.chapter_role_permissionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_role_permissionsPayload>
          }
          deleteMany: {
            args: Prisma.chapter_role_permissionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.chapter_role_permissionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.chapter_role_permissionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_role_permissionsPayload>
          }
          aggregate: {
            args: Prisma.Chapter_role_permissionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChapter_role_permissions>
          }
          groupBy: {
            args: Prisma.chapter_role_permissionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Chapter_role_permissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.chapter_role_permissionsCountArgs<ExtArgs>,
            result: $Utils.Optional<Chapter_role_permissionsCountAggregateOutputType> | number
          }
        }
      }
      chapter_permissions: {
        payload: chapter_permissionsPayload<ExtArgs>
        fields: Prisma.chapter_permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chapter_permissionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chapter_permissionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_permissionsPayload>
          }
          findFirst: {
            args: Prisma.chapter_permissionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chapter_permissionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_permissionsPayload>
          }
          findMany: {
            args: Prisma.chapter_permissionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_permissionsPayload>[]
          }
          create: {
            args: Prisma.chapter_permissionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_permissionsPayload>
          }
          createMany: {
            args: Prisma.chapter_permissionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.chapter_permissionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_permissionsPayload>
          }
          update: {
            args: Prisma.chapter_permissionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_permissionsPayload>
          }
          deleteMany: {
            args: Prisma.chapter_permissionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.chapter_permissionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.chapter_permissionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_permissionsPayload>
          }
          aggregate: {
            args: Prisma.Chapter_permissionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChapter_permissions>
          }
          groupBy: {
            args: Prisma.chapter_permissionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Chapter_permissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.chapter_permissionsCountArgs<ExtArgs>,
            result: $Utils.Optional<Chapter_permissionsCountAggregateOutputType> | number
          }
        }
      }
      chapter_tags: {
        payload: chapter_tagsPayload<ExtArgs>
        fields: Prisma.chapter_tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chapter_tagsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chapter_tagsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_tagsPayload>
          }
          findFirst: {
            args: Prisma.chapter_tagsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chapter_tagsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_tagsPayload>
          }
          findMany: {
            args: Prisma.chapter_tagsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_tagsPayload>[]
          }
          create: {
            args: Prisma.chapter_tagsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_tagsPayload>
          }
          createMany: {
            args: Prisma.chapter_tagsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.chapter_tagsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_tagsPayload>
          }
          update: {
            args: Prisma.chapter_tagsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_tagsPayload>
          }
          deleteMany: {
            args: Prisma.chapter_tagsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.chapter_tagsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.chapter_tagsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<chapter_tagsPayload>
          }
          aggregate: {
            args: Prisma.Chapter_tagsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChapter_tags>
          }
          groupBy: {
            args: Prisma.chapter_tagsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Chapter_tagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.chapter_tagsCountArgs<ExtArgs>,
            result: $Utils.Optional<Chapter_tagsCountAggregateOutputType> | number
          }
        }
      }
      event_sponsors: {
        payload: event_sponsorsPayload<ExtArgs>
        fields: Prisma.event_sponsorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.event_sponsorsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_sponsorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.event_sponsorsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_sponsorsPayload>
          }
          findFirst: {
            args: Prisma.event_sponsorsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_sponsorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.event_sponsorsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_sponsorsPayload>
          }
          findMany: {
            args: Prisma.event_sponsorsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_sponsorsPayload>[]
          }
          create: {
            args: Prisma.event_sponsorsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_sponsorsPayload>
          }
          createMany: {
            args: Prisma.event_sponsorsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.event_sponsorsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_sponsorsPayload>
          }
          update: {
            args: Prisma.event_sponsorsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_sponsorsPayload>
          }
          deleteMany: {
            args: Prisma.event_sponsorsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.event_sponsorsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.event_sponsorsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_sponsorsPayload>
          }
          aggregate: {
            args: Prisma.Event_sponsorsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvent_sponsors>
          }
          groupBy: {
            args: Prisma.event_sponsorsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Event_sponsorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.event_sponsorsCountArgs<ExtArgs>,
            result: $Utils.Optional<Event_sponsorsCountAggregateOutputType> | number
          }
        }
      }
      event_tags: {
        payload: event_tagsPayload<ExtArgs>
        fields: Prisma.event_tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.event_tagsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.event_tagsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_tagsPayload>
          }
          findFirst: {
            args: Prisma.event_tagsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.event_tagsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_tagsPayload>
          }
          findMany: {
            args: Prisma.event_tagsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_tagsPayload>[]
          }
          create: {
            args: Prisma.event_tagsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_tagsPayload>
          }
          createMany: {
            args: Prisma.event_tagsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.event_tagsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_tagsPayload>
          }
          update: {
            args: Prisma.event_tagsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_tagsPayload>
          }
          deleteMany: {
            args: Prisma.event_tagsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.event_tagsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.event_tagsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_tagsPayload>
          }
          aggregate: {
            args: Prisma.Event_tagsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvent_tags>
          }
          groupBy: {
            args: Prisma.event_tagsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Event_tagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.event_tagsCountArgs<ExtArgs>,
            result: $Utils.Optional<Event_tagsCountAggregateOutputType> | number
          }
        }
      }
      events: {
        payload: eventsPayload<ExtArgs>
        fields: Prisma.eventsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.eventsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.eventsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventsPayload>
          }
          findFirst: {
            args: Prisma.eventsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.eventsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventsPayload>
          }
          findMany: {
            args: Prisma.eventsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventsPayload>[]
          }
          create: {
            args: Prisma.eventsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventsPayload>
          }
          createMany: {
            args: Prisma.eventsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.eventsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventsPayload>
          }
          update: {
            args: Prisma.eventsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventsPayload>
          }
          deleteMany: {
            args: Prisma.eventsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.eventsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.eventsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventsPayload>
          }
          aggregate: {
            args: Prisma.EventsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvents>
          }
          groupBy: {
            args: Prisma.eventsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EventsGroupByOutputType>[]
          }
          count: {
            args: Prisma.eventsCountArgs<ExtArgs>,
            result: $Utils.Optional<EventsCountAggregateOutputType> | number
          }
        }
      }
      event_roles: {
        payload: event_rolesPayload<ExtArgs>
        fields: Prisma.event_rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.event_rolesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.event_rolesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_rolesPayload>
          }
          findFirst: {
            args: Prisma.event_rolesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.event_rolesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_rolesPayload>
          }
          findMany: {
            args: Prisma.event_rolesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_rolesPayload>[]
          }
          create: {
            args: Prisma.event_rolesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_rolesPayload>
          }
          createMany: {
            args: Prisma.event_rolesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.event_rolesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_rolesPayload>
          }
          update: {
            args: Prisma.event_rolesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_rolesPayload>
          }
          deleteMany: {
            args: Prisma.event_rolesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.event_rolesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.event_rolesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_rolesPayload>
          }
          aggregate: {
            args: Prisma.Event_rolesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvent_roles>
          }
          groupBy: {
            args: Prisma.event_rolesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Event_rolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.event_rolesCountArgs<ExtArgs>,
            result: $Utils.Optional<Event_rolesCountAggregateOutputType> | number
          }
        }
      }
      event_role_permissions: {
        payload: event_role_permissionsPayload<ExtArgs>
        fields: Prisma.event_role_permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.event_role_permissionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_role_permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.event_role_permissionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_role_permissionsPayload>
          }
          findFirst: {
            args: Prisma.event_role_permissionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_role_permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.event_role_permissionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_role_permissionsPayload>
          }
          findMany: {
            args: Prisma.event_role_permissionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_role_permissionsPayload>[]
          }
          create: {
            args: Prisma.event_role_permissionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_role_permissionsPayload>
          }
          createMany: {
            args: Prisma.event_role_permissionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.event_role_permissionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_role_permissionsPayload>
          }
          update: {
            args: Prisma.event_role_permissionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_role_permissionsPayload>
          }
          deleteMany: {
            args: Prisma.event_role_permissionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.event_role_permissionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.event_role_permissionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_role_permissionsPayload>
          }
          aggregate: {
            args: Prisma.Event_role_permissionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvent_role_permissions>
          }
          groupBy: {
            args: Prisma.event_role_permissionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Event_role_permissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.event_role_permissionsCountArgs<ExtArgs>,
            result: $Utils.Optional<Event_role_permissionsCountAggregateOutputType> | number
          }
        }
      }
      event_permissions: {
        payload: event_permissionsPayload<ExtArgs>
        fields: Prisma.event_permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.event_permissionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.event_permissionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_permissionsPayload>
          }
          findFirst: {
            args: Prisma.event_permissionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.event_permissionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_permissionsPayload>
          }
          findMany: {
            args: Prisma.event_permissionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_permissionsPayload>[]
          }
          create: {
            args: Prisma.event_permissionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_permissionsPayload>
          }
          createMany: {
            args: Prisma.event_permissionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.event_permissionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_permissionsPayload>
          }
          update: {
            args: Prisma.event_permissionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_permissionsPayload>
          }
          deleteMany: {
            args: Prisma.event_permissionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.event_permissionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.event_permissionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_permissionsPayload>
          }
          aggregate: {
            args: Prisma.Event_permissionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvent_permissions>
          }
          groupBy: {
            args: Prisma.event_permissionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Event_permissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.event_permissionsCountArgs<ExtArgs>,
            result: $Utils.Optional<Event_permissionsCountAggregateOutputType> | number
          }
        }
      }
      event_users: {
        payload: event_usersPayload<ExtArgs>
        fields: Prisma.event_usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.event_usersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.event_usersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_usersPayload>
          }
          findFirst: {
            args: Prisma.event_usersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.event_usersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_usersPayload>
          }
          findMany: {
            args: Prisma.event_usersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_usersPayload>[]
          }
          create: {
            args: Prisma.event_usersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_usersPayload>
          }
          createMany: {
            args: Prisma.event_usersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.event_usersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_usersPayload>
          }
          update: {
            args: Prisma.event_usersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_usersPayload>
          }
          deleteMany: {
            args: Prisma.event_usersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.event_usersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.event_usersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_usersPayload>
          }
          aggregate: {
            args: Prisma.Event_usersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvent_users>
          }
          groupBy: {
            args: Prisma.event_usersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Event_usersGroupByOutputType>[]
          }
          count: {
            args: Prisma.event_usersCountArgs<ExtArgs>,
            result: $Utils.Optional<Event_usersCountAggregateOutputType> | number
          }
        }
      }
      event_reminders: {
        payload: event_remindersPayload<ExtArgs>
        fields: Prisma.event_remindersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.event_remindersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_remindersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.event_remindersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_remindersPayload>
          }
          findFirst: {
            args: Prisma.event_remindersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_remindersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.event_remindersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_remindersPayload>
          }
          findMany: {
            args: Prisma.event_remindersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_remindersPayload>[]
          }
          create: {
            args: Prisma.event_remindersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_remindersPayload>
          }
          createMany: {
            args: Prisma.event_remindersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.event_remindersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_remindersPayload>
          }
          update: {
            args: Prisma.event_remindersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_remindersPayload>
          }
          deleteMany: {
            args: Prisma.event_remindersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.event_remindersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.event_remindersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<event_remindersPayload>
          }
          aggregate: {
            args: Prisma.Event_remindersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvent_reminders>
          }
          groupBy: {
            args: Prisma.event_remindersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Event_remindersGroupByOutputType>[]
          }
          count: {
            args: Prisma.event_remindersCountArgs<ExtArgs>,
            result: $Utils.Optional<Event_remindersCountAggregateOutputType> | number
          }
        }
      }
      attendance: {
        payload: attendancePayload<ExtArgs>
        fields: Prisma.attendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.attendanceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<attendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.attendanceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<attendancePayload>
          }
          findFirst: {
            args: Prisma.attendanceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<attendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.attendanceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<attendancePayload>
          }
          findMany: {
            args: Prisma.attendanceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<attendancePayload>[]
          }
          create: {
            args: Prisma.attendanceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<attendancePayload>
          }
          createMany: {
            args: Prisma.attendanceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.attendanceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<attendancePayload>
          }
          update: {
            args: Prisma.attendanceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<attendancePayload>
          }
          deleteMany: {
            args: Prisma.attendanceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.attendanceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.attendanceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<attendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.attendanceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.attendanceCountArgs<ExtArgs>,
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      sponsors: {
        payload: sponsorsPayload<ExtArgs>
        fields: Prisma.sponsorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sponsorsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sponsorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sponsorsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sponsorsPayload>
          }
          findFirst: {
            args: Prisma.sponsorsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sponsorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sponsorsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sponsorsPayload>
          }
          findMany: {
            args: Prisma.sponsorsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sponsorsPayload>[]
          }
          create: {
            args: Prisma.sponsorsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sponsorsPayload>
          }
          createMany: {
            args: Prisma.sponsorsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.sponsorsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sponsorsPayload>
          }
          update: {
            args: Prisma.sponsorsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sponsorsPayload>
          }
          deleteMany: {
            args: Prisma.sponsorsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.sponsorsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.sponsorsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sponsorsPayload>
          }
          aggregate: {
            args: Prisma.SponsorsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSponsors>
          }
          groupBy: {
            args: Prisma.sponsorsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SponsorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sponsorsCountArgs<ExtArgs>,
            result: $Utils.Optional<SponsorsCountAggregateOutputType> | number
          }
        }
      }
      tags: {
        payload: tagsPayload<ExtArgs>
        fields: Prisma.tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tagsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tagsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tagsPayload>
          }
          findFirst: {
            args: Prisma.tagsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tagsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tagsPayload>
          }
          findMany: {
            args: Prisma.tagsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tagsPayload>[]
          }
          create: {
            args: Prisma.tagsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tagsPayload>
          }
          createMany: {
            args: Prisma.tagsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tagsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tagsPayload>
          }
          update: {
            args: Prisma.tagsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tagsPayload>
          }
          deleteMany: {
            args: Prisma.tagsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tagsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tagsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tagsPayload>
          }
          aggregate: {
            args: Prisma.TagsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTags>
          }
          groupBy: {
            args: Prisma.tagsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tagsCountArgs<ExtArgs>,
            result: $Utils.Optional<TagsCountAggregateOutputType> | number
          }
        }
      }
      user_bans: {
        payload: user_bansPayload<ExtArgs>
        fields: Prisma.user_bansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_bansFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_bansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_bansFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_bansPayload>
          }
          findFirst: {
            args: Prisma.user_bansFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_bansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_bansFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_bansPayload>
          }
          findMany: {
            args: Prisma.user_bansFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_bansPayload>[]
          }
          create: {
            args: Prisma.user_bansCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_bansPayload>
          }
          createMany: {
            args: Prisma.user_bansCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.user_bansDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_bansPayload>
          }
          update: {
            args: Prisma.user_bansUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_bansPayload>
          }
          deleteMany: {
            args: Prisma.user_bansDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.user_bansUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.user_bansUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_bansPayload>
          }
          aggregate: {
            args: Prisma.User_bansAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser_bans>
          }
          groupBy: {
            args: Prisma.user_bansGroupByArgs<ExtArgs>,
            result: $Utils.Optional<User_bansGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_bansCountArgs<ExtArgs>,
            result: $Utils.Optional<User_bansCountAggregateOutputType> | number
          }
        }
      }
      instance_permissions: {
        payload: instance_permissionsPayload<ExtArgs>
        fields: Prisma.instance_permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.instance_permissionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.instance_permissionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_permissionsPayload>
          }
          findFirst: {
            args: Prisma.instance_permissionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.instance_permissionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_permissionsPayload>
          }
          findMany: {
            args: Prisma.instance_permissionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_permissionsPayload>[]
          }
          create: {
            args: Prisma.instance_permissionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_permissionsPayload>
          }
          createMany: {
            args: Prisma.instance_permissionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.instance_permissionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_permissionsPayload>
          }
          update: {
            args: Prisma.instance_permissionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_permissionsPayload>
          }
          deleteMany: {
            args: Prisma.instance_permissionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.instance_permissionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.instance_permissionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_permissionsPayload>
          }
          aggregate: {
            args: Prisma.Instance_permissionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInstance_permissions>
          }
          groupBy: {
            args: Prisma.instance_permissionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Instance_permissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.instance_permissionsCountArgs<ExtArgs>,
            result: $Utils.Optional<Instance_permissionsCountAggregateOutputType> | number
          }
        }
      }
      instance_role_permissions: {
        payload: instance_role_permissionsPayload<ExtArgs>
        fields: Prisma.instance_role_permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.instance_role_permissionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_role_permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.instance_role_permissionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_role_permissionsPayload>
          }
          findFirst: {
            args: Prisma.instance_role_permissionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_role_permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.instance_role_permissionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_role_permissionsPayload>
          }
          findMany: {
            args: Prisma.instance_role_permissionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_role_permissionsPayload>[]
          }
          create: {
            args: Prisma.instance_role_permissionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_role_permissionsPayload>
          }
          createMany: {
            args: Prisma.instance_role_permissionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.instance_role_permissionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_role_permissionsPayload>
          }
          update: {
            args: Prisma.instance_role_permissionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_role_permissionsPayload>
          }
          deleteMany: {
            args: Prisma.instance_role_permissionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.instance_role_permissionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.instance_role_permissionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_role_permissionsPayload>
          }
          aggregate: {
            args: Prisma.Instance_role_permissionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInstance_role_permissions>
          }
          groupBy: {
            args: Prisma.instance_role_permissionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Instance_role_permissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.instance_role_permissionsCountArgs<ExtArgs>,
            result: $Utils.Optional<Instance_role_permissionsCountAggregateOutputType> | number
          }
        }
      }
      instance_roles: {
        payload: instance_rolesPayload<ExtArgs>
        fields: Prisma.instance_rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.instance_rolesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.instance_rolesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_rolesPayload>
          }
          findFirst: {
            args: Prisma.instance_rolesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.instance_rolesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_rolesPayload>
          }
          findMany: {
            args: Prisma.instance_rolesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_rolesPayload>[]
          }
          create: {
            args: Prisma.instance_rolesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_rolesPayload>
          }
          createMany: {
            args: Prisma.instance_rolesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.instance_rolesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_rolesPayload>
          }
          update: {
            args: Prisma.instance_rolesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_rolesPayload>
          }
          deleteMany: {
            args: Prisma.instance_rolesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.instance_rolesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.instance_rolesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<instance_rolesPayload>
          }
          aggregate: {
            args: Prisma.Instance_rolesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInstance_roles>
          }
          groupBy: {
            args: Prisma.instance_rolesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Instance_rolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.instance_rolesCountArgs<ExtArgs>,
            result: $Utils.Optional<Instance_rolesCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>,
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      venue_tags: {
        payload: venue_tagsPayload<ExtArgs>
        fields: Prisma.venue_tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.venue_tagsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<venue_tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.venue_tagsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<venue_tagsPayload>
          }
          findFirst: {
            args: Prisma.venue_tagsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<venue_tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.venue_tagsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<venue_tagsPayload>
          }
          findMany: {
            args: Prisma.venue_tagsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<venue_tagsPayload>[]
          }
          create: {
            args: Prisma.venue_tagsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<venue_tagsPayload>
          }
          createMany: {
            args: Prisma.venue_tagsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.venue_tagsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<venue_tagsPayload>
          }
          update: {
            args: Prisma.venue_tagsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<venue_tagsPayload>
          }
          deleteMany: {
            args: Prisma.venue_tagsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.venue_tagsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.venue_tagsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<venue_tagsPayload>
          }
          aggregate: {
            args: Prisma.Venue_tagsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVenue_tags>
          }
          groupBy: {
            args: Prisma.venue_tagsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Venue_tagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.venue_tagsCountArgs<ExtArgs>,
            result: $Utils.Optional<Venue_tagsCountAggregateOutputType> | number
          }
        }
      }
      venues: {
        payload: venuesPayload<ExtArgs>
        fields: Prisma.venuesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.venuesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<venuesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.venuesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<venuesPayload>
          }
          findFirst: {
            args: Prisma.venuesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<venuesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.venuesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<venuesPayload>
          }
          findMany: {
            args: Prisma.venuesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<venuesPayload>[]
          }
          create: {
            args: Prisma.venuesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<venuesPayload>
          }
          createMany: {
            args: Prisma.venuesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.venuesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<venuesPayload>
          }
          update: {
            args: Prisma.venuesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<venuesPayload>
          }
          deleteMany: {
            args: Prisma.venuesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.venuesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.venuesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<venuesPayload>
          }
          aggregate: {
            args: Prisma.VenuesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVenues>
          }
          groupBy: {
            args: Prisma.venuesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VenuesGroupByOutputType>[]
          }
          count: {
            args: Prisma.venuesCountArgs<ExtArgs>,
            result: $Utils.Optional<VenuesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ChaptersCountOutputType
   */


  export type ChaptersCountOutputType = {
    events: number
    user_bans: number
    chapter_users: number
    chapter_tags: number
    venues: number
  }

  export type ChaptersCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    events?: boolean | ChaptersCountOutputTypeCountEventsArgs
    user_bans?: boolean | ChaptersCountOutputTypeCountUser_bansArgs
    chapter_users?: boolean | ChaptersCountOutputTypeCountChapter_usersArgs
    chapter_tags?: boolean | ChaptersCountOutputTypeCountChapter_tagsArgs
    venues?: boolean | ChaptersCountOutputTypeCountVenuesArgs
  }

  // Custom InputTypes

  /**
   * ChaptersCountOutputType without action
   */
  export type ChaptersCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChaptersCountOutputType
     */
    select?: ChaptersCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ChaptersCountOutputType without action
   */
  export type ChaptersCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: eventsWhereInput
  }


  /**
   * ChaptersCountOutputType without action
   */
  export type ChaptersCountOutputTypeCountUser_bansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_bansWhereInput
  }


  /**
   * ChaptersCountOutputType without action
   */
  export type ChaptersCountOutputTypeCountChapter_usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: chapter_usersWhereInput
  }


  /**
   * ChaptersCountOutputType without action
   */
  export type ChaptersCountOutputTypeCountChapter_tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: chapter_tagsWhereInput
  }


  /**
   * ChaptersCountOutputType without action
   */
  export type ChaptersCountOutputTypeCountVenuesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: venuesWhereInput
  }



  /**
   * Count Type Chapter_rolesCountOutputType
   */


  export type Chapter_rolesCountOutputType = {
    chapter_users: number
    chapter_role_permissions: number
  }

  export type Chapter_rolesCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    chapter_users?: boolean | Chapter_rolesCountOutputTypeCountChapter_usersArgs
    chapter_role_permissions?: boolean | Chapter_rolesCountOutputTypeCountChapter_role_permissionsArgs
  }

  // Custom InputTypes

  /**
   * Chapter_rolesCountOutputType without action
   */
  export type Chapter_rolesCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter_rolesCountOutputType
     */
    select?: Chapter_rolesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Chapter_rolesCountOutputType without action
   */
  export type Chapter_rolesCountOutputTypeCountChapter_usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: chapter_usersWhereInput
  }


  /**
   * Chapter_rolesCountOutputType without action
   */
  export type Chapter_rolesCountOutputTypeCountChapter_role_permissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: chapter_role_permissionsWhereInput
  }



  /**
   * Count Type Chapter_permissionsCountOutputType
   */


  export type Chapter_permissionsCountOutputType = {
    chapter_role_permissions: number
  }

  export type Chapter_permissionsCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    chapter_role_permissions?: boolean | Chapter_permissionsCountOutputTypeCountChapter_role_permissionsArgs
  }

  // Custom InputTypes

  /**
   * Chapter_permissionsCountOutputType without action
   */
  export type Chapter_permissionsCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter_permissionsCountOutputType
     */
    select?: Chapter_permissionsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Chapter_permissionsCountOutputType without action
   */
  export type Chapter_permissionsCountOutputTypeCountChapter_role_permissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: chapter_role_permissionsWhereInput
  }



  /**
   * Count Type EventsCountOutputType
   */


  export type EventsCountOutputType = {
    sponsors: number
    event_tags: number
    event_users: number
  }

  export type EventsCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    sponsors?: boolean | EventsCountOutputTypeCountSponsorsArgs
    event_tags?: boolean | EventsCountOutputTypeCountEvent_tagsArgs
    event_users?: boolean | EventsCountOutputTypeCountEvent_usersArgs
  }

  // Custom InputTypes

  /**
   * EventsCountOutputType without action
   */
  export type EventsCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventsCountOutputType
     */
    select?: EventsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EventsCountOutputType without action
   */
  export type EventsCountOutputTypeCountSponsorsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: event_sponsorsWhereInput
  }


  /**
   * EventsCountOutputType without action
   */
  export type EventsCountOutputTypeCountEvent_tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: event_tagsWhereInput
  }


  /**
   * EventsCountOutputType without action
   */
  export type EventsCountOutputTypeCountEvent_usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: event_usersWhereInput
  }



  /**
   * Count Type Event_rolesCountOutputType
   */


  export type Event_rolesCountOutputType = {
    event_role_permissions: number
    event_users: number
  }

  export type Event_rolesCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    event_role_permissions?: boolean | Event_rolesCountOutputTypeCountEvent_role_permissionsArgs
    event_users?: boolean | Event_rolesCountOutputTypeCountEvent_usersArgs
  }

  // Custom InputTypes

  /**
   * Event_rolesCountOutputType without action
   */
  export type Event_rolesCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event_rolesCountOutputType
     */
    select?: Event_rolesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Event_rolesCountOutputType without action
   */
  export type Event_rolesCountOutputTypeCountEvent_role_permissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: event_role_permissionsWhereInput
  }


  /**
   * Event_rolesCountOutputType without action
   */
  export type Event_rolesCountOutputTypeCountEvent_usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: event_usersWhereInput
  }



  /**
   * Count Type Event_permissionsCountOutputType
   */


  export type Event_permissionsCountOutputType = {
    event_role_permissions: number
  }

  export type Event_permissionsCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    event_role_permissions?: boolean | Event_permissionsCountOutputTypeCountEvent_role_permissionsArgs
  }

  // Custom InputTypes

  /**
   * Event_permissionsCountOutputType without action
   */
  export type Event_permissionsCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event_permissionsCountOutputType
     */
    select?: Event_permissionsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Event_permissionsCountOutputType without action
   */
  export type Event_permissionsCountOutputTypeCountEvent_role_permissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: event_role_permissionsWhereInput
  }



  /**
   * Count Type AttendanceCountOutputType
   */


  export type AttendanceCountOutputType = {
    event_users: number
  }

  export type AttendanceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    event_users?: boolean | AttendanceCountOutputTypeCountEvent_usersArgs
  }

  // Custom InputTypes

  /**
   * AttendanceCountOutputType without action
   */
  export type AttendanceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceCountOutputType
     */
    select?: AttendanceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AttendanceCountOutputType without action
   */
  export type AttendanceCountOutputTypeCountEvent_usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: event_usersWhereInput
  }



  /**
   * Count Type SponsorsCountOutputType
   */


  export type SponsorsCountOutputType = {
    event_sponsors: number
  }

  export type SponsorsCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    event_sponsors?: boolean | SponsorsCountOutputTypeCountEvent_sponsorsArgs
  }

  // Custom InputTypes

  /**
   * SponsorsCountOutputType without action
   */
  export type SponsorsCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SponsorsCountOutputType
     */
    select?: SponsorsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SponsorsCountOutputType without action
   */
  export type SponsorsCountOutputTypeCountEvent_sponsorsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: event_sponsorsWhereInput
  }



  /**
   * Count Type TagsCountOutputType
   */


  export type TagsCountOutputType = {
    chapter_tags: number
    event_tags: number
    venue_tags: number
  }

  export type TagsCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    chapter_tags?: boolean | TagsCountOutputTypeCountChapter_tagsArgs
    event_tags?: boolean | TagsCountOutputTypeCountEvent_tagsArgs
    venue_tags?: boolean | TagsCountOutputTypeCountVenue_tagsArgs
  }

  // Custom InputTypes

  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsCountOutputType
     */
    select?: TagsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeCountChapter_tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: chapter_tagsWhereInput
  }


  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeCountEvent_tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: event_tagsWhereInput
  }


  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeCountVenue_tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: venue_tagsWhereInput
  }



  /**
   * Count Type Instance_permissionsCountOutputType
   */


  export type Instance_permissionsCountOutputType = {
    instance_role_permissions: number
  }

  export type Instance_permissionsCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    instance_role_permissions?: boolean | Instance_permissionsCountOutputTypeCountInstance_role_permissionsArgs
  }

  // Custom InputTypes

  /**
   * Instance_permissionsCountOutputType without action
   */
  export type Instance_permissionsCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance_permissionsCountOutputType
     */
    select?: Instance_permissionsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Instance_permissionsCountOutputType without action
   */
  export type Instance_permissionsCountOutputTypeCountInstance_role_permissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: instance_role_permissionsWhereInput
  }



  /**
   * Count Type Instance_rolesCountOutputType
   */


  export type Instance_rolesCountOutputType = {
    instance_role_permissions: number
    users: number
  }

  export type Instance_rolesCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    instance_role_permissions?: boolean | Instance_rolesCountOutputTypeCountInstance_role_permissionsArgs
    users?: boolean | Instance_rolesCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes

  /**
   * Instance_rolesCountOutputType without action
   */
  export type Instance_rolesCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance_rolesCountOutputType
     */
    select?: Instance_rolesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Instance_rolesCountOutputType without action
   */
  export type Instance_rolesCountOutputTypeCountInstance_role_permissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: instance_role_permissionsWhereInput
  }


  /**
   * Instance_rolesCountOutputType without action
   */
  export type Instance_rolesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }



  /**
   * Count Type UsersCountOutputType
   */


  export type UsersCountOutputType = {
    user_bans: number
    user_chapters: number
    user_events: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user_bans?: boolean | UsersCountOutputTypeCountUser_bansArgs
    user_chapters?: boolean | UsersCountOutputTypeCountUser_chaptersArgs
    user_events?: boolean | UsersCountOutputTypeCountUser_eventsArgs
  }

  // Custom InputTypes

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_bansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_bansWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_chaptersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: chapter_usersWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_eventsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: event_usersWhereInput
  }



  /**
   * Count Type VenuesCountOutputType
   */


  export type VenuesCountOutputType = {
    events: number
    venue_tags: number
  }

  export type VenuesCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    events?: boolean | VenuesCountOutputTypeCountEventsArgs
    venue_tags?: boolean | VenuesCountOutputTypeCountVenue_tagsArgs
  }

  // Custom InputTypes

  /**
   * VenuesCountOutputType without action
   */
  export type VenuesCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenuesCountOutputType
     */
    select?: VenuesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * VenuesCountOutputType without action
   */
  export type VenuesCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: eventsWhereInput
  }


  /**
   * VenuesCountOutputType without action
   */
  export type VenuesCountOutputTypeCountVenue_tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: venue_tagsWhereInput
  }



  /**
   * Models
   */

  /**
   * Model chapters
   */


  export type AggregateChapters = {
    _count: ChaptersCountAggregateOutputType | null
    _avg: ChaptersAvgAggregateOutputType | null
    _sum: ChaptersSumAggregateOutputType | null
    _min: ChaptersMinAggregateOutputType | null
    _max: ChaptersMaxAggregateOutputType | null
  }

  export type ChaptersAvgAggregateOutputType = {
    id: number | null
    creator_id: number | null
  }

  export type ChaptersSumAggregateOutputType = {
    id: number | null
    creator_id: number | null
  }

  export type ChaptersMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
    description: string | null
    category: string | null
    city: string | null
    region: string | null
    country: string | null
    logo_url: string | null
    banner_url: string | null
    calendar_id: string | null
    chat_url: string | null
    creator_id: number | null
  }

  export type ChaptersMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
    description: string | null
    category: string | null
    city: string | null
    region: string | null
    country: string | null
    logo_url: string | null
    banner_url: string | null
    calendar_id: string | null
    chat_url: string | null
    creator_id: number | null
  }

  export type ChaptersCountAggregateOutputType = {
    created_at: number
    updated_at: number
    id: number
    name: number
    description: number
    category: number
    city: number
    region: number
    country: number
    logo_url: number
    banner_url: number
    calendar_id: number
    chat_url: number
    creator_id: number
    _all: number
  }


  export type ChaptersAvgAggregateInputType = {
    id?: true
    creator_id?: true
  }

  export type ChaptersSumAggregateInputType = {
    id?: true
    creator_id?: true
  }

  export type ChaptersMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    description?: true
    category?: true
    city?: true
    region?: true
    country?: true
    logo_url?: true
    banner_url?: true
    calendar_id?: true
    chat_url?: true
    creator_id?: true
  }

  export type ChaptersMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    description?: true
    category?: true
    city?: true
    region?: true
    country?: true
    logo_url?: true
    banner_url?: true
    calendar_id?: true
    chat_url?: true
    creator_id?: true
  }

  export type ChaptersCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    description?: true
    category?: true
    city?: true
    region?: true
    country?: true
    logo_url?: true
    banner_url?: true
    calendar_id?: true
    chat_url?: true
    creator_id?: true
    _all?: true
  }

  export type ChaptersAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chapters to aggregate.
     */
    where?: chaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapters to fetch.
     */
    orderBy?: chaptersOrderByWithRelationInput | chaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chapters
    **/
    _count?: true | ChaptersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChaptersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChaptersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChaptersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChaptersMaxAggregateInputType
  }

  export type GetChaptersAggregateType<T extends ChaptersAggregateArgs> = {
        [P in keyof T & keyof AggregateChapters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapters[P]>
      : GetScalarType<T[P], AggregateChapters[P]>
  }




  export type chaptersGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: chaptersWhereInput
    orderBy?: chaptersOrderByWithAggregationInput | chaptersOrderByWithAggregationInput[]
    by: ChaptersScalarFieldEnum[] | ChaptersScalarFieldEnum
    having?: chaptersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChaptersCountAggregateInputType | true
    _avg?: ChaptersAvgAggregateInputType
    _sum?: ChaptersSumAggregateInputType
    _min?: ChaptersMinAggregateInputType
    _max?: ChaptersMaxAggregateInputType
  }


  export type ChaptersGroupByOutputType = {
    created_at: Date
    updated_at: Date
    id: number
    name: string
    description: string
    category: string
    city: string
    region: string
    country: string
    logo_url: string | null
    banner_url: string | null
    calendar_id: string | null
    chat_url: string | null
    creator_id: number
    _count: ChaptersCountAggregateOutputType | null
    _avg: ChaptersAvgAggregateOutputType | null
    _sum: ChaptersSumAggregateOutputType | null
    _min: ChaptersMinAggregateOutputType | null
    _max: ChaptersMaxAggregateOutputType | null
  }

  type GetChaptersGroupByPayload<T extends chaptersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChaptersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChaptersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChaptersGroupByOutputType[P]>
            : GetScalarType<T[P], ChaptersGroupByOutputType[P]>
        }
      >
    >


  export type chaptersSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    logo_url?: boolean
    banner_url?: boolean
    calendar_id?: boolean
    chat_url?: boolean
    creator_id?: boolean
    events?: boolean | chapters$eventsArgs<ExtArgs>
    user_bans?: boolean | chapters$user_bansArgs<ExtArgs>
    chapter_users?: boolean | chapters$chapter_usersArgs<ExtArgs>
    chapter_tags?: boolean | chapters$chapter_tagsArgs<ExtArgs>
    venues?: boolean | chapters$venuesArgs<ExtArgs>
    _count?: boolean | ChaptersCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["chapters"]>

  export type chaptersSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    logo_url?: boolean
    banner_url?: boolean
    calendar_id?: boolean
    chat_url?: boolean
    creator_id?: boolean
  }

  export type chaptersInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    events?: boolean | chapters$eventsArgs<ExtArgs>
    user_bans?: boolean | chapters$user_bansArgs<ExtArgs>
    chapter_users?: boolean | chapters$chapter_usersArgs<ExtArgs>
    chapter_tags?: boolean | chapters$chapter_tagsArgs<ExtArgs>
    venues?: boolean | chapters$venuesArgs<ExtArgs>
    _count?: boolean | ChaptersCountOutputTypeArgs<ExtArgs>
  }


  type chaptersGetPayload<S extends boolean | null | undefined | chaptersArgs> = $Types.GetResult<chaptersPayload, S>

  type chaptersCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<chaptersFindManyArgs, 'select' | 'include'> & {
      select?: ChaptersCountAggregateInputType | true
    }

  export interface chaptersDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chapters'], meta: { name: 'chapters' } }
    /**
     * Find zero or one Chapters that matches the filter.
     * @param {chaptersFindUniqueArgs} args - Arguments to find a Chapters
     * @example
     * // Get one Chapters
     * const chapters = await prisma.chapters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends chaptersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, chaptersFindUniqueArgs<ExtArgs>>
    ): Prisma__chaptersClient<$Types.GetResult<chaptersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Chapters that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {chaptersFindUniqueOrThrowArgs} args - Arguments to find a Chapters
     * @example
     * // Get one Chapters
     * const chapters = await prisma.chapters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends chaptersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chaptersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__chaptersClient<$Types.GetResult<chaptersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chaptersFindFirstArgs} args - Arguments to find a Chapters
     * @example
     * // Get one Chapters
     * const chapters = await prisma.chapters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends chaptersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, chaptersFindFirstArgs<ExtArgs>>
    ): Prisma__chaptersClient<$Types.GetResult<chaptersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Chapters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chaptersFindFirstOrThrowArgs} args - Arguments to find a Chapters
     * @example
     * // Get one Chapters
     * const chapters = await prisma.chapters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends chaptersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chaptersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__chaptersClient<$Types.GetResult<chaptersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chaptersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapters
     * const chapters = await prisma.chapters.findMany()
     * 
     * // Get first 10 Chapters
     * const chapters = await prisma.chapters.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const chaptersWithCreated_atOnly = await prisma.chapters.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends chaptersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chaptersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<chaptersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Chapters.
     * @param {chaptersCreateArgs} args - Arguments to create a Chapters.
     * @example
     * // Create one Chapters
     * const Chapters = await prisma.chapters.create({
     *   data: {
     *     // ... data to create a Chapters
     *   }
     * })
     * 
    **/
    create<T extends chaptersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, chaptersCreateArgs<ExtArgs>>
    ): Prisma__chaptersClient<$Types.GetResult<chaptersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Chapters.
     *     @param {chaptersCreateManyArgs} args - Arguments to create many Chapters.
     *     @example
     *     // Create many Chapters
     *     const chapters = await prisma.chapters.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends chaptersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chaptersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chapters.
     * @param {chaptersDeleteArgs} args - Arguments to delete one Chapters.
     * @example
     * // Delete one Chapters
     * const Chapters = await prisma.chapters.delete({
     *   where: {
     *     // ... filter to delete one Chapters
     *   }
     * })
     * 
    **/
    delete<T extends chaptersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, chaptersDeleteArgs<ExtArgs>>
    ): Prisma__chaptersClient<$Types.GetResult<chaptersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Chapters.
     * @param {chaptersUpdateArgs} args - Arguments to update one Chapters.
     * @example
     * // Update one Chapters
     * const chapters = await prisma.chapters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends chaptersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, chaptersUpdateArgs<ExtArgs>>
    ): Prisma__chaptersClient<$Types.GetResult<chaptersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Chapters.
     * @param {chaptersDeleteManyArgs} args - Arguments to filter Chapters to delete.
     * @example
     * // Delete a few Chapters
     * const { count } = await prisma.chapters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends chaptersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chaptersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chaptersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapters
     * const chapters = await prisma.chapters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends chaptersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, chaptersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chapters.
     * @param {chaptersUpsertArgs} args - Arguments to update or create a Chapters.
     * @example
     * // Update or create a Chapters
     * const chapters = await prisma.chapters.upsert({
     *   create: {
     *     // ... data to create a Chapters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapters we want to update
     *   }
     * })
    **/
    upsert<T extends chaptersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, chaptersUpsertArgs<ExtArgs>>
    ): Prisma__chaptersClient<$Types.GetResult<chaptersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chaptersCountArgs} args - Arguments to filter Chapters to count.
     * @example
     * // Count the number of Chapters
     * const count = await prisma.chapters.count({
     *   where: {
     *     // ... the filter for the Chapters we want to count
     *   }
     * })
    **/
    count<T extends chaptersCountArgs>(
      args?: Subset<T, chaptersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChaptersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChaptersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChaptersAggregateArgs>(args: Subset<T, ChaptersAggregateArgs>): Prisma.PrismaPromise<GetChaptersAggregateType<T>>

    /**
     * Group by Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chaptersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chaptersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chaptersGroupByArgs['orderBy'] }
        : { orderBy?: chaptersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chaptersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChaptersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chapters model
   */
  readonly fields: chaptersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chapters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__chaptersClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    events<T extends chapters$eventsArgs<ExtArgs> = {}>(args?: Subset<T, chapters$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<eventsPayload<ExtArgs>, T, 'findMany'>| Null>;

    user_bans<T extends chapters$user_bansArgs<ExtArgs> = {}>(args?: Subset<T, chapters$user_bansArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<user_bansPayload<ExtArgs>, T, 'findMany'>| Null>;

    chapter_users<T extends chapters$chapter_usersArgs<ExtArgs> = {}>(args?: Subset<T, chapters$chapter_usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<chapter_usersPayload<ExtArgs>, T, 'findMany'>| Null>;

    chapter_tags<T extends chapters$chapter_tagsArgs<ExtArgs> = {}>(args?: Subset<T, chapters$chapter_tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<chapter_tagsPayload<ExtArgs>, T, 'findMany'>| Null>;

    venues<T extends chapters$venuesArgs<ExtArgs> = {}>(args?: Subset<T, chapters$venuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<venuesPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the chapters model
   */ 
  interface chaptersFieldRefs {
    readonly created_at: FieldRef<"chapters", 'DateTime'>
    readonly updated_at: FieldRef<"chapters", 'DateTime'>
    readonly id: FieldRef<"chapters", 'Int'>
    readonly name: FieldRef<"chapters", 'String'>
    readonly description: FieldRef<"chapters", 'String'>
    readonly category: FieldRef<"chapters", 'String'>
    readonly city: FieldRef<"chapters", 'String'>
    readonly region: FieldRef<"chapters", 'String'>
    readonly country: FieldRef<"chapters", 'String'>
    readonly logo_url: FieldRef<"chapters", 'String'>
    readonly banner_url: FieldRef<"chapters", 'String'>
    readonly calendar_id: FieldRef<"chapters", 'String'>
    readonly chat_url: FieldRef<"chapters", 'String'>
    readonly creator_id: FieldRef<"chapters", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * chapters findUnique
   */
  export type chaptersFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapters
     */
    select?: chaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chaptersInclude<ExtArgs> | null
    /**
     * Filter, which chapters to fetch.
     */
    where: chaptersWhereUniqueInput
  }


  /**
   * chapters findUniqueOrThrow
   */
  export type chaptersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapters
     */
    select?: chaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chaptersInclude<ExtArgs> | null
    /**
     * Filter, which chapters to fetch.
     */
    where: chaptersWhereUniqueInput
  }


  /**
   * chapters findFirst
   */
  export type chaptersFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapters
     */
    select?: chaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chaptersInclude<ExtArgs> | null
    /**
     * Filter, which chapters to fetch.
     */
    where?: chaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapters to fetch.
     */
    orderBy?: chaptersOrderByWithRelationInput | chaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chapters.
     */
    cursor?: chaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chapters.
     */
    distinct?: ChaptersScalarFieldEnum | ChaptersScalarFieldEnum[]
  }


  /**
   * chapters findFirstOrThrow
   */
  export type chaptersFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapters
     */
    select?: chaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chaptersInclude<ExtArgs> | null
    /**
     * Filter, which chapters to fetch.
     */
    where?: chaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapters to fetch.
     */
    orderBy?: chaptersOrderByWithRelationInput | chaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chapters.
     */
    cursor?: chaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chapters.
     */
    distinct?: ChaptersScalarFieldEnum | ChaptersScalarFieldEnum[]
  }


  /**
   * chapters findMany
   */
  export type chaptersFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapters
     */
    select?: chaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chaptersInclude<ExtArgs> | null
    /**
     * Filter, which chapters to fetch.
     */
    where?: chaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapters to fetch.
     */
    orderBy?: chaptersOrderByWithRelationInput | chaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chapters.
     */
    cursor?: chaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapters.
     */
    skip?: number
    distinct?: ChaptersScalarFieldEnum | ChaptersScalarFieldEnum[]
  }


  /**
   * chapters create
   */
  export type chaptersCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapters
     */
    select?: chaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chaptersInclude<ExtArgs> | null
    /**
     * The data needed to create a chapters.
     */
    data: XOR<chaptersCreateInput, chaptersUncheckedCreateInput>
  }


  /**
   * chapters createMany
   */
  export type chaptersCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chapters.
     */
    data: chaptersCreateManyInput | chaptersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * chapters update
   */
  export type chaptersUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapters
     */
    select?: chaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chaptersInclude<ExtArgs> | null
    /**
     * The data needed to update a chapters.
     */
    data: XOR<chaptersUpdateInput, chaptersUncheckedUpdateInput>
    /**
     * Choose, which chapters to update.
     */
    where: chaptersWhereUniqueInput
  }


  /**
   * chapters updateMany
   */
  export type chaptersUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chapters.
     */
    data: XOR<chaptersUpdateManyMutationInput, chaptersUncheckedUpdateManyInput>
    /**
     * Filter which chapters to update
     */
    where?: chaptersWhereInput
  }


  /**
   * chapters upsert
   */
  export type chaptersUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapters
     */
    select?: chaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chaptersInclude<ExtArgs> | null
    /**
     * The filter to search for the chapters to update in case it exists.
     */
    where: chaptersWhereUniqueInput
    /**
     * In case the chapters found by the `where` argument doesn't exist, create a new chapters with this data.
     */
    create: XOR<chaptersCreateInput, chaptersUncheckedCreateInput>
    /**
     * In case the chapters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chaptersUpdateInput, chaptersUncheckedUpdateInput>
  }


  /**
   * chapters delete
   */
  export type chaptersDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapters
     */
    select?: chaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chaptersInclude<ExtArgs> | null
    /**
     * Filter which chapters to delete.
     */
    where: chaptersWhereUniqueInput
  }


  /**
   * chapters deleteMany
   */
  export type chaptersDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chapters to delete
     */
    where?: chaptersWhereInput
  }


  /**
   * chapters.events
   */
  export type chapters$eventsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventsInclude<ExtArgs> | null
    where?: eventsWhereInput
    orderBy?: eventsOrderByWithRelationInput | eventsOrderByWithRelationInput[]
    cursor?: eventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }


  /**
   * chapters.user_bans
   */
  export type chapters$user_bansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bans
     */
    select?: user_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bansInclude<ExtArgs> | null
    where?: user_bansWhereInput
    orderBy?: user_bansOrderByWithRelationInput | user_bansOrderByWithRelationInput[]
    cursor?: user_bansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_bansScalarFieldEnum | User_bansScalarFieldEnum[]
  }


  /**
   * chapters.chapter_users
   */
  export type chapters$chapter_usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_users
     */
    select?: chapter_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_usersInclude<ExtArgs> | null
    where?: chapter_usersWhereInput
    orderBy?: chapter_usersOrderByWithRelationInput | chapter_usersOrderByWithRelationInput[]
    cursor?: chapter_usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chapter_usersScalarFieldEnum | Chapter_usersScalarFieldEnum[]
  }


  /**
   * chapters.chapter_tags
   */
  export type chapters$chapter_tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_tags
     */
    select?: chapter_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_tagsInclude<ExtArgs> | null
    where?: chapter_tagsWhereInput
    orderBy?: chapter_tagsOrderByWithRelationInput | chapter_tagsOrderByWithRelationInput[]
    cursor?: chapter_tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chapter_tagsScalarFieldEnum | Chapter_tagsScalarFieldEnum[]
  }


  /**
   * chapters.venues
   */
  export type chapters$venuesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venues
     */
    select?: venuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venuesInclude<ExtArgs> | null
    where?: venuesWhereInput
    orderBy?: venuesOrderByWithRelationInput | venuesOrderByWithRelationInput[]
    cursor?: venuesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenuesScalarFieldEnum | VenuesScalarFieldEnum[]
  }


  /**
   * chapters without action
   */
  export type chaptersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapters
     */
    select?: chaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chaptersInclude<ExtArgs> | null
  }



  /**
   * Model sessions
   */


  export type AggregateSessions = {
    _count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  export type SessionsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type SessionsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type SessionsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type SessionsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type SessionsCountAggregateOutputType = {
    id: number
    user_id: number
    _all: number
  }


  export type SessionsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type SessionsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type SessionsMinAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type SessionsMaxAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type SessionsCountAggregateInputType = {
    id?: true
    user_id?: true
    _all?: true
  }

  export type SessionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to aggregate.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionsMaxAggregateInputType
  }

  export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions[P]>
      : GetScalarType<T[P], AggregateSessions[P]>
  }




  export type sessionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithAggregationInput | sessionsOrderByWithAggregationInput[]
    by: SessionsScalarFieldEnum[] | SessionsScalarFieldEnum
    having?: sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionsCountAggregateInputType | true
    _avg?: SessionsAvgAggregateInputType
    _sum?: SessionsSumAggregateInputType
    _min?: SessionsMinAggregateInputType
    _max?: SessionsMaxAggregateInputType
  }


  export type SessionsGroupByOutputType = {
    id: number
    user_id: number
    _count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  type GetSessionsGroupByPayload<T extends sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionsGroupByOutputType[P]>
            : GetScalarType<T[P], SessionsGroupByOutputType[P]>
        }
      >
    >


  export type sessionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    user?: boolean | usersArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type sessionsSelectScalar = {
    id?: boolean
    user_id?: boolean
  }

  export type sessionsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | usersArgs<ExtArgs>
  }


  type sessionsGetPayload<S extends boolean | null | undefined | sessionsArgs> = $Types.GetResult<sessionsPayload, S>

  type sessionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<sessionsFindManyArgs, 'select' | 'include'> & {
      select?: SessionsCountAggregateInputType | true
    }

  export interface sessionsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessions'], meta: { name: 'sessions' } }
    /**
     * Find zero or one Sessions that matches the filter.
     * @param {sessionsFindUniqueArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sessionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, sessionsFindUniqueArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Types.GetResult<sessionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sessions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sessionsFindUniqueOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sessionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Types.GetResult<sessionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sessionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionsFindFirstArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Types.GetResult<sessionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sessionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Types.GetResult<sessionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.sessions.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionsWithIdOnly = await prisma.sessions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends sessionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<sessionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sessions.
     * @param {sessionsCreateArgs} args - Arguments to create a Sessions.
     * @example
     * // Create one Sessions
     * const Sessions = await prisma.sessions.create({
     *   data: {
     *     // ... data to create a Sessions
     *   }
     * })
     * 
    **/
    create<T extends sessionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, sessionsCreateArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Types.GetResult<sessionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sessions.
     *     @param {sessionsCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const sessions = await prisma.sessions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sessionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sessions.
     * @param {sessionsDeleteArgs} args - Arguments to delete one Sessions.
     * @example
     * // Delete one Sessions
     * const Sessions = await prisma.sessions.delete({
     *   where: {
     *     // ... filter to delete one Sessions
     *   }
     * })
     * 
    **/
    delete<T extends sessionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, sessionsDeleteArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Types.GetResult<sessionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sessions.
     * @param {sessionsUpdateArgs} args - Arguments to update one Sessions.
     * @example
     * // Update one Sessions
     * const sessions = await prisma.sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sessionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, sessionsUpdateArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Types.GetResult<sessionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {sessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sessionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sessionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, sessionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sessions.
     * @param {sessionsUpsertArgs} args - Arguments to update or create a Sessions.
     * @example
     * // Update or create a Sessions
     * const sessions = await prisma.sessions.upsert({
     *   create: {
     *     // ... data to create a Sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions we want to update
     *   }
     * })
    **/
    upsert<T extends sessionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, sessionsUpsertArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Types.GetResult<sessionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.sessions.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionsCountArgs>(
      args?: Subset<T, sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionsAggregateArgs>(args: Subset<T, SessionsAggregateArgs>): Prisma.PrismaPromise<GetSessionsAggregateType<T>>

    /**
     * Group by Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionsGroupByArgs['orderBy'] }
        : { orderBy?: sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessions model
   */
  readonly fields: sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sessionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends usersArgs<ExtArgs> = {}>(args?: Subset<T, usersArgs<ExtArgs>>): Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the sessions model
   */ 
  interface sessionsFieldRefs {
    readonly id: FieldRef<"sessions", 'Int'>
    readonly user_id: FieldRef<"sessions", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * sessions findUnique
   */
  export type sessionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }


  /**
   * sessions findUniqueOrThrow
   */
  export type sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }


  /**
   * sessions findFirst
   */
  export type sessionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }


  /**
   * sessions findFirstOrThrow
   */
  export type sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }


  /**
   * sessions findMany
   */
  export type sessionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }


  /**
   * sessions create
   */
  export type sessionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a sessions.
     */
    data: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
  }


  /**
   * sessions createMany
   */
  export type sessionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * sessions update
   */
  export type sessionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a sessions.
     */
    data: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
    /**
     * Choose, which sessions to update.
     */
    where: sessionsWhereUniqueInput
  }


  /**
   * sessions updateMany
   */
  export type sessionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
  }


  /**
   * sessions upsert
   */
  export type sessionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the sessions to update in case it exists.
     */
    where: sessionsWhereUniqueInput
    /**
     * In case the sessions found by the `where` argument doesn't exist, create a new sessions with this data.
     */
    create: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
    /**
     * In case the sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
  }


  /**
   * sessions delete
   */
  export type sessionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter which sessions to delete.
     */
    where: sessionsWhereUniqueInput
  }


  /**
   * sessions deleteMany
   */
  export type sessionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionsWhereInput
  }


  /**
   * sessions without action
   */
  export type sessionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude<ExtArgs> | null
  }



  /**
   * Model google_tokens
   */


  export type AggregateGoogle_tokens = {
    _count: Google_tokensCountAggregateOutputType | null
    _avg: Google_tokensAvgAggregateOutputType | null
    _sum: Google_tokensSumAggregateOutputType | null
    _min: Google_tokensMinAggregateOutputType | null
    _max: Google_tokensMaxAggregateOutputType | null
  }

  export type Google_tokensAvgAggregateOutputType = {
    id: number | null
    expiry_date: number | null
  }

  export type Google_tokensSumAggregateOutputType = {
    id: number | null
    expiry_date: bigint | null
  }

  export type Google_tokensMinAggregateOutputType = {
    id: number | null
    email: string | null
    access_token: string | null
    refresh_token: string | null
    expiry_date: bigint | null
    is_valid: boolean | null
  }

  export type Google_tokensMaxAggregateOutputType = {
    id: number | null
    email: string | null
    access_token: string | null
    refresh_token: string | null
    expiry_date: bigint | null
    is_valid: boolean | null
  }

  export type Google_tokensCountAggregateOutputType = {
    id: number
    email: number
    access_token: number
    refresh_token: number
    expiry_date: number
    is_valid: number
    _all: number
  }


  export type Google_tokensAvgAggregateInputType = {
    id?: true
    expiry_date?: true
  }

  export type Google_tokensSumAggregateInputType = {
    id?: true
    expiry_date?: true
  }

  export type Google_tokensMinAggregateInputType = {
    id?: true
    email?: true
    access_token?: true
    refresh_token?: true
    expiry_date?: true
    is_valid?: true
  }

  export type Google_tokensMaxAggregateInputType = {
    id?: true
    email?: true
    access_token?: true
    refresh_token?: true
    expiry_date?: true
    is_valid?: true
  }

  export type Google_tokensCountAggregateInputType = {
    id?: true
    email?: true
    access_token?: true
    refresh_token?: true
    expiry_date?: true
    is_valid?: true
    _all?: true
  }

  export type Google_tokensAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which google_tokens to aggregate.
     */
    where?: google_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of google_tokens to fetch.
     */
    orderBy?: google_tokensOrderByWithRelationInput | google_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: google_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` google_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` google_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned google_tokens
    **/
    _count?: true | Google_tokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Google_tokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Google_tokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Google_tokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Google_tokensMaxAggregateInputType
  }

  export type GetGoogle_tokensAggregateType<T extends Google_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregateGoogle_tokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoogle_tokens[P]>
      : GetScalarType<T[P], AggregateGoogle_tokens[P]>
  }




  export type google_tokensGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: google_tokensWhereInput
    orderBy?: google_tokensOrderByWithAggregationInput | google_tokensOrderByWithAggregationInput[]
    by: Google_tokensScalarFieldEnum[] | Google_tokensScalarFieldEnum
    having?: google_tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Google_tokensCountAggregateInputType | true
    _avg?: Google_tokensAvgAggregateInputType
    _sum?: Google_tokensSumAggregateInputType
    _min?: Google_tokensMinAggregateInputType
    _max?: Google_tokensMaxAggregateInputType
  }


  export type Google_tokensGroupByOutputType = {
    id: number
    email: string
    access_token: string
    refresh_token: string
    expiry_date: bigint
    is_valid: boolean
    _count: Google_tokensCountAggregateOutputType | null
    _avg: Google_tokensAvgAggregateOutputType | null
    _sum: Google_tokensSumAggregateOutputType | null
    _min: Google_tokensMinAggregateOutputType | null
    _max: Google_tokensMaxAggregateOutputType | null
  }

  type GetGoogle_tokensGroupByPayload<T extends google_tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Google_tokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Google_tokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Google_tokensGroupByOutputType[P]>
            : GetScalarType<T[P], Google_tokensGroupByOutputType[P]>
        }
      >
    >


  export type google_tokensSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    access_token?: boolean
    refresh_token?: boolean
    expiry_date?: boolean
    is_valid?: boolean
  }, ExtArgs["result"]["google_tokens"]>

  export type google_tokensSelectScalar = {
    id?: boolean
    email?: boolean
    access_token?: boolean
    refresh_token?: boolean
    expiry_date?: boolean
    is_valid?: boolean
  }


  type google_tokensGetPayload<S extends boolean | null | undefined | google_tokensArgs> = $Types.GetResult<google_tokensPayload, S>

  type google_tokensCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<google_tokensFindManyArgs, 'select' | 'include'> & {
      select?: Google_tokensCountAggregateInputType | true
    }

  export interface google_tokensDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['google_tokens'], meta: { name: 'google_tokens' } }
    /**
     * Find zero or one Google_tokens that matches the filter.
     * @param {google_tokensFindUniqueArgs} args - Arguments to find a Google_tokens
     * @example
     * // Get one Google_tokens
     * const google_tokens = await prisma.google_tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends google_tokensFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, google_tokensFindUniqueArgs<ExtArgs>>
    ): Prisma__google_tokensClient<$Types.GetResult<google_tokensPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Google_tokens that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {google_tokensFindUniqueOrThrowArgs} args - Arguments to find a Google_tokens
     * @example
     * // Get one Google_tokens
     * const google_tokens = await prisma.google_tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends google_tokensFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, google_tokensFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__google_tokensClient<$Types.GetResult<google_tokensPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Google_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_tokensFindFirstArgs} args - Arguments to find a Google_tokens
     * @example
     * // Get one Google_tokens
     * const google_tokens = await prisma.google_tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends google_tokensFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, google_tokensFindFirstArgs<ExtArgs>>
    ): Prisma__google_tokensClient<$Types.GetResult<google_tokensPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Google_tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_tokensFindFirstOrThrowArgs} args - Arguments to find a Google_tokens
     * @example
     * // Get one Google_tokens
     * const google_tokens = await prisma.google_tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends google_tokensFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, google_tokensFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__google_tokensClient<$Types.GetResult<google_tokensPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Google_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_tokensFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Google_tokens
     * const google_tokens = await prisma.google_tokens.findMany()
     * 
     * // Get first 10 Google_tokens
     * const google_tokens = await prisma.google_tokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const google_tokensWithIdOnly = await prisma.google_tokens.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends google_tokensFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, google_tokensFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<google_tokensPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Google_tokens.
     * @param {google_tokensCreateArgs} args - Arguments to create a Google_tokens.
     * @example
     * // Create one Google_tokens
     * const Google_tokens = await prisma.google_tokens.create({
     *   data: {
     *     // ... data to create a Google_tokens
     *   }
     * })
     * 
    **/
    create<T extends google_tokensCreateArgs<ExtArgs>>(
      args: SelectSubset<T, google_tokensCreateArgs<ExtArgs>>
    ): Prisma__google_tokensClient<$Types.GetResult<google_tokensPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Google_tokens.
     *     @param {google_tokensCreateManyArgs} args - Arguments to create many Google_tokens.
     *     @example
     *     // Create many Google_tokens
     *     const google_tokens = await prisma.google_tokens.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends google_tokensCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, google_tokensCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Google_tokens.
     * @param {google_tokensDeleteArgs} args - Arguments to delete one Google_tokens.
     * @example
     * // Delete one Google_tokens
     * const Google_tokens = await prisma.google_tokens.delete({
     *   where: {
     *     // ... filter to delete one Google_tokens
     *   }
     * })
     * 
    **/
    delete<T extends google_tokensDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, google_tokensDeleteArgs<ExtArgs>>
    ): Prisma__google_tokensClient<$Types.GetResult<google_tokensPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Google_tokens.
     * @param {google_tokensUpdateArgs} args - Arguments to update one Google_tokens.
     * @example
     * // Update one Google_tokens
     * const google_tokens = await prisma.google_tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends google_tokensUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, google_tokensUpdateArgs<ExtArgs>>
    ): Prisma__google_tokensClient<$Types.GetResult<google_tokensPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Google_tokens.
     * @param {google_tokensDeleteManyArgs} args - Arguments to filter Google_tokens to delete.
     * @example
     * // Delete a few Google_tokens
     * const { count } = await prisma.google_tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends google_tokensDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, google_tokensDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Google_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Google_tokens
     * const google_tokens = await prisma.google_tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends google_tokensUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, google_tokensUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Google_tokens.
     * @param {google_tokensUpsertArgs} args - Arguments to update or create a Google_tokens.
     * @example
     * // Update or create a Google_tokens
     * const google_tokens = await prisma.google_tokens.upsert({
     *   create: {
     *     // ... data to create a Google_tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Google_tokens we want to update
     *   }
     * })
    **/
    upsert<T extends google_tokensUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, google_tokensUpsertArgs<ExtArgs>>
    ): Prisma__google_tokensClient<$Types.GetResult<google_tokensPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Google_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_tokensCountArgs} args - Arguments to filter Google_tokens to count.
     * @example
     * // Count the number of Google_tokens
     * const count = await prisma.google_tokens.count({
     *   where: {
     *     // ... the filter for the Google_tokens we want to count
     *   }
     * })
    **/
    count<T extends google_tokensCountArgs>(
      args?: Subset<T, google_tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Google_tokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Google_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Google_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Google_tokensAggregateArgs>(args: Subset<T, Google_tokensAggregateArgs>): Prisma.PrismaPromise<GetGoogle_tokensAggregateType<T>>

    /**
     * Group by Google_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends google_tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: google_tokensGroupByArgs['orderBy'] }
        : { orderBy?: google_tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, google_tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoogle_tokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the google_tokens model
   */
  readonly fields: google_tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for google_tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__google_tokensClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the google_tokens model
   */ 
  interface google_tokensFieldRefs {
    readonly id: FieldRef<"google_tokens", 'Int'>
    readonly email: FieldRef<"google_tokens", 'String'>
    readonly access_token: FieldRef<"google_tokens", 'String'>
    readonly refresh_token: FieldRef<"google_tokens", 'String'>
    readonly expiry_date: FieldRef<"google_tokens", 'BigInt'>
    readonly is_valid: FieldRef<"google_tokens", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * google_tokens findUnique
   */
  export type google_tokensFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_tokens
     */
    select?: google_tokensSelect<ExtArgs> | null
    /**
     * Filter, which google_tokens to fetch.
     */
    where: google_tokensWhereUniqueInput
  }


  /**
   * google_tokens findUniqueOrThrow
   */
  export type google_tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_tokens
     */
    select?: google_tokensSelect<ExtArgs> | null
    /**
     * Filter, which google_tokens to fetch.
     */
    where: google_tokensWhereUniqueInput
  }


  /**
   * google_tokens findFirst
   */
  export type google_tokensFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_tokens
     */
    select?: google_tokensSelect<ExtArgs> | null
    /**
     * Filter, which google_tokens to fetch.
     */
    where?: google_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of google_tokens to fetch.
     */
    orderBy?: google_tokensOrderByWithRelationInput | google_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for google_tokens.
     */
    cursor?: google_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` google_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` google_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of google_tokens.
     */
    distinct?: Google_tokensScalarFieldEnum | Google_tokensScalarFieldEnum[]
  }


  /**
   * google_tokens findFirstOrThrow
   */
  export type google_tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_tokens
     */
    select?: google_tokensSelect<ExtArgs> | null
    /**
     * Filter, which google_tokens to fetch.
     */
    where?: google_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of google_tokens to fetch.
     */
    orderBy?: google_tokensOrderByWithRelationInput | google_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for google_tokens.
     */
    cursor?: google_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` google_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` google_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of google_tokens.
     */
    distinct?: Google_tokensScalarFieldEnum | Google_tokensScalarFieldEnum[]
  }


  /**
   * google_tokens findMany
   */
  export type google_tokensFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_tokens
     */
    select?: google_tokensSelect<ExtArgs> | null
    /**
     * Filter, which google_tokens to fetch.
     */
    where?: google_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of google_tokens to fetch.
     */
    orderBy?: google_tokensOrderByWithRelationInput | google_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing google_tokens.
     */
    cursor?: google_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` google_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` google_tokens.
     */
    skip?: number
    distinct?: Google_tokensScalarFieldEnum | Google_tokensScalarFieldEnum[]
  }


  /**
   * google_tokens create
   */
  export type google_tokensCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_tokens
     */
    select?: google_tokensSelect<ExtArgs> | null
    /**
     * The data needed to create a google_tokens.
     */
    data: XOR<google_tokensCreateInput, google_tokensUncheckedCreateInput>
  }


  /**
   * google_tokens createMany
   */
  export type google_tokensCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many google_tokens.
     */
    data: google_tokensCreateManyInput | google_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * google_tokens update
   */
  export type google_tokensUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_tokens
     */
    select?: google_tokensSelect<ExtArgs> | null
    /**
     * The data needed to update a google_tokens.
     */
    data: XOR<google_tokensUpdateInput, google_tokensUncheckedUpdateInput>
    /**
     * Choose, which google_tokens to update.
     */
    where: google_tokensWhereUniqueInput
  }


  /**
   * google_tokens updateMany
   */
  export type google_tokensUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update google_tokens.
     */
    data: XOR<google_tokensUpdateManyMutationInput, google_tokensUncheckedUpdateManyInput>
    /**
     * Filter which google_tokens to update
     */
    where?: google_tokensWhereInput
  }


  /**
   * google_tokens upsert
   */
  export type google_tokensUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_tokens
     */
    select?: google_tokensSelect<ExtArgs> | null
    /**
     * The filter to search for the google_tokens to update in case it exists.
     */
    where: google_tokensWhereUniqueInput
    /**
     * In case the google_tokens found by the `where` argument doesn't exist, create a new google_tokens with this data.
     */
    create: XOR<google_tokensCreateInput, google_tokensUncheckedCreateInput>
    /**
     * In case the google_tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<google_tokensUpdateInput, google_tokensUncheckedUpdateInput>
  }


  /**
   * google_tokens delete
   */
  export type google_tokensDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_tokens
     */
    select?: google_tokensSelect<ExtArgs> | null
    /**
     * Filter which google_tokens to delete.
     */
    where: google_tokensWhereUniqueInput
  }


  /**
   * google_tokens deleteMany
   */
  export type google_tokensDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which google_tokens to delete
     */
    where?: google_tokensWhereInput
  }


  /**
   * google_tokens without action
   */
  export type google_tokensArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_tokens
     */
    select?: google_tokensSelect<ExtArgs> | null
  }



  /**
   * Model chapter_users
   */


  export type AggregateChapter_users = {
    _count: Chapter_usersCountAggregateOutputType | null
    _avg: Chapter_usersAvgAggregateOutputType | null
    _sum: Chapter_usersSumAggregateOutputType | null
    _min: Chapter_usersMinAggregateOutputType | null
    _max: Chapter_usersMaxAggregateOutputType | null
  }

  export type Chapter_usersAvgAggregateOutputType = {
    user_id: number | null
    chapter_id: number | null
    chapter_role_id: number | null
  }

  export type Chapter_usersSumAggregateOutputType = {
    user_id: number | null
    chapter_id: number | null
    chapter_role_id: number | null
  }

  export type Chapter_usersMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    joined_date: Date | null
    user_id: number | null
    chapter_id: number | null
    chapter_role_id: number | null
    subscribed: boolean | null
  }

  export type Chapter_usersMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    joined_date: Date | null
    user_id: number | null
    chapter_id: number | null
    chapter_role_id: number | null
    subscribed: boolean | null
  }

  export type Chapter_usersCountAggregateOutputType = {
    created_at: number
    updated_at: number
    joined_date: number
    user_id: number
    chapter_id: number
    chapter_role_id: number
    subscribed: number
    _all: number
  }


  export type Chapter_usersAvgAggregateInputType = {
    user_id?: true
    chapter_id?: true
    chapter_role_id?: true
  }

  export type Chapter_usersSumAggregateInputType = {
    user_id?: true
    chapter_id?: true
    chapter_role_id?: true
  }

  export type Chapter_usersMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    joined_date?: true
    user_id?: true
    chapter_id?: true
    chapter_role_id?: true
    subscribed?: true
  }

  export type Chapter_usersMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    joined_date?: true
    user_id?: true
    chapter_id?: true
    chapter_role_id?: true
    subscribed?: true
  }

  export type Chapter_usersCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    joined_date?: true
    user_id?: true
    chapter_id?: true
    chapter_role_id?: true
    subscribed?: true
    _all?: true
  }

  export type Chapter_usersAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chapter_users to aggregate.
     */
    where?: chapter_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_users to fetch.
     */
    orderBy?: chapter_usersOrderByWithRelationInput | chapter_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chapter_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chapter_users
    **/
    _count?: true | Chapter_usersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Chapter_usersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Chapter_usersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chapter_usersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chapter_usersMaxAggregateInputType
  }

  export type GetChapter_usersAggregateType<T extends Chapter_usersAggregateArgs> = {
        [P in keyof T & keyof AggregateChapter_users]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapter_users[P]>
      : GetScalarType<T[P], AggregateChapter_users[P]>
  }




  export type chapter_usersGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: chapter_usersWhereInput
    orderBy?: chapter_usersOrderByWithAggregationInput | chapter_usersOrderByWithAggregationInput[]
    by: Chapter_usersScalarFieldEnum[] | Chapter_usersScalarFieldEnum
    having?: chapter_usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chapter_usersCountAggregateInputType | true
    _avg?: Chapter_usersAvgAggregateInputType
    _sum?: Chapter_usersSumAggregateInputType
    _min?: Chapter_usersMinAggregateInputType
    _max?: Chapter_usersMaxAggregateInputType
  }


  export type Chapter_usersGroupByOutputType = {
    created_at: Date
    updated_at: Date
    joined_date: Date
    user_id: number
    chapter_id: number
    chapter_role_id: number
    subscribed: boolean
    _count: Chapter_usersCountAggregateOutputType | null
    _avg: Chapter_usersAvgAggregateOutputType | null
    _sum: Chapter_usersSumAggregateOutputType | null
    _min: Chapter_usersMinAggregateOutputType | null
    _max: Chapter_usersMaxAggregateOutputType | null
  }

  type GetChapter_usersGroupByPayload<T extends chapter_usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Chapter_usersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chapter_usersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chapter_usersGroupByOutputType[P]>
            : GetScalarType<T[P], Chapter_usersGroupByOutputType[P]>
        }
      >
    >


  export type chapter_usersSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    joined_date?: boolean
    user_id?: boolean
    chapter_id?: boolean
    chapter_role_id?: boolean
    subscribed?: boolean
    user?: boolean | usersArgs<ExtArgs>
    chapter?: boolean | chaptersArgs<ExtArgs>
    chapter_role?: boolean | chapter_rolesArgs<ExtArgs>
  }, ExtArgs["result"]["chapter_users"]>

  export type chapter_usersSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    joined_date?: boolean
    user_id?: boolean
    chapter_id?: boolean
    chapter_role_id?: boolean
    subscribed?: boolean
  }

  export type chapter_usersInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | usersArgs<ExtArgs>
    chapter?: boolean | chaptersArgs<ExtArgs>
    chapter_role?: boolean | chapter_rolesArgs<ExtArgs>
  }


  type chapter_usersGetPayload<S extends boolean | null | undefined | chapter_usersArgs> = $Types.GetResult<chapter_usersPayload, S>

  type chapter_usersCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<chapter_usersFindManyArgs, 'select' | 'include'> & {
      select?: Chapter_usersCountAggregateInputType | true
    }

  export interface chapter_usersDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chapter_users'], meta: { name: 'chapter_users' } }
    /**
     * Find zero or one Chapter_users that matches the filter.
     * @param {chapter_usersFindUniqueArgs} args - Arguments to find a Chapter_users
     * @example
     * // Get one Chapter_users
     * const chapter_users = await prisma.chapter_users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends chapter_usersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_usersFindUniqueArgs<ExtArgs>>
    ): Prisma__chapter_usersClient<$Types.GetResult<chapter_usersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Chapter_users that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {chapter_usersFindUniqueOrThrowArgs} args - Arguments to find a Chapter_users
     * @example
     * // Get one Chapter_users
     * const chapter_users = await prisma.chapter_users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends chapter_usersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_usersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__chapter_usersClient<$Types.GetResult<chapter_usersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Chapter_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_usersFindFirstArgs} args - Arguments to find a Chapter_users
     * @example
     * // Get one Chapter_users
     * const chapter_users = await prisma.chapter_users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends chapter_usersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_usersFindFirstArgs<ExtArgs>>
    ): Prisma__chapter_usersClient<$Types.GetResult<chapter_usersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Chapter_users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_usersFindFirstOrThrowArgs} args - Arguments to find a Chapter_users
     * @example
     * // Get one Chapter_users
     * const chapter_users = await prisma.chapter_users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends chapter_usersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_usersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__chapter_usersClient<$Types.GetResult<chapter_usersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Chapter_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapter_users
     * const chapter_users = await prisma.chapter_users.findMany()
     * 
     * // Get first 10 Chapter_users
     * const chapter_users = await prisma.chapter_users.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const chapter_usersWithCreated_atOnly = await prisma.chapter_users.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends chapter_usersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_usersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<chapter_usersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Chapter_users.
     * @param {chapter_usersCreateArgs} args - Arguments to create a Chapter_users.
     * @example
     * // Create one Chapter_users
     * const Chapter_users = await prisma.chapter_users.create({
     *   data: {
     *     // ... data to create a Chapter_users
     *   }
     * })
     * 
    **/
    create<T extends chapter_usersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_usersCreateArgs<ExtArgs>>
    ): Prisma__chapter_usersClient<$Types.GetResult<chapter_usersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Chapter_users.
     *     @param {chapter_usersCreateManyArgs} args - Arguments to create many Chapter_users.
     *     @example
     *     // Create many Chapter_users
     *     const chapter_users = await prisma.chapter_users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends chapter_usersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_usersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chapter_users.
     * @param {chapter_usersDeleteArgs} args - Arguments to delete one Chapter_users.
     * @example
     * // Delete one Chapter_users
     * const Chapter_users = await prisma.chapter_users.delete({
     *   where: {
     *     // ... filter to delete one Chapter_users
     *   }
     * })
     * 
    **/
    delete<T extends chapter_usersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_usersDeleteArgs<ExtArgs>>
    ): Prisma__chapter_usersClient<$Types.GetResult<chapter_usersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Chapter_users.
     * @param {chapter_usersUpdateArgs} args - Arguments to update one Chapter_users.
     * @example
     * // Update one Chapter_users
     * const chapter_users = await prisma.chapter_users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends chapter_usersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_usersUpdateArgs<ExtArgs>>
    ): Prisma__chapter_usersClient<$Types.GetResult<chapter_usersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Chapter_users.
     * @param {chapter_usersDeleteManyArgs} args - Arguments to filter Chapter_users to delete.
     * @example
     * // Delete a few Chapter_users
     * const { count } = await prisma.chapter_users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends chapter_usersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_usersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapter_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapter_users
     * const chapter_users = await prisma.chapter_users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends chapter_usersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_usersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chapter_users.
     * @param {chapter_usersUpsertArgs} args - Arguments to update or create a Chapter_users.
     * @example
     * // Update or create a Chapter_users
     * const chapter_users = await prisma.chapter_users.upsert({
     *   create: {
     *     // ... data to create a Chapter_users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapter_users we want to update
     *   }
     * })
    **/
    upsert<T extends chapter_usersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_usersUpsertArgs<ExtArgs>>
    ): Prisma__chapter_usersClient<$Types.GetResult<chapter_usersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Chapter_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_usersCountArgs} args - Arguments to filter Chapter_users to count.
     * @example
     * // Count the number of Chapter_users
     * const count = await prisma.chapter_users.count({
     *   where: {
     *     // ... the filter for the Chapter_users we want to count
     *   }
     * })
    **/
    count<T extends chapter_usersCountArgs>(
      args?: Subset<T, chapter_usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chapter_usersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapter_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chapter_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chapter_usersAggregateArgs>(args: Subset<T, Chapter_usersAggregateArgs>): Prisma.PrismaPromise<GetChapter_usersAggregateType<T>>

    /**
     * Group by Chapter_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chapter_usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chapter_usersGroupByArgs['orderBy'] }
        : { orderBy?: chapter_usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chapter_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapter_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chapter_users model
   */
  readonly fields: chapter_usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chapter_users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__chapter_usersClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends usersArgs<ExtArgs> = {}>(args?: Subset<T, usersArgs<ExtArgs>>): Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    chapter<T extends chaptersArgs<ExtArgs> = {}>(args?: Subset<T, chaptersArgs<ExtArgs>>): Prisma__chaptersClient<$Types.GetResult<chaptersPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    chapter_role<T extends chapter_rolesArgs<ExtArgs> = {}>(args?: Subset<T, chapter_rolesArgs<ExtArgs>>): Prisma__chapter_rolesClient<$Types.GetResult<chapter_rolesPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the chapter_users model
   */ 
  interface chapter_usersFieldRefs {
    readonly created_at: FieldRef<"chapter_users", 'DateTime'>
    readonly updated_at: FieldRef<"chapter_users", 'DateTime'>
    readonly joined_date: FieldRef<"chapter_users", 'DateTime'>
    readonly user_id: FieldRef<"chapter_users", 'Int'>
    readonly chapter_id: FieldRef<"chapter_users", 'Int'>
    readonly chapter_role_id: FieldRef<"chapter_users", 'Int'>
    readonly subscribed: FieldRef<"chapter_users", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * chapter_users findUnique
   */
  export type chapter_usersFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_users
     */
    select?: chapter_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_usersInclude<ExtArgs> | null
    /**
     * Filter, which chapter_users to fetch.
     */
    where: chapter_usersWhereUniqueInput
  }


  /**
   * chapter_users findUniqueOrThrow
   */
  export type chapter_usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_users
     */
    select?: chapter_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_usersInclude<ExtArgs> | null
    /**
     * Filter, which chapter_users to fetch.
     */
    where: chapter_usersWhereUniqueInput
  }


  /**
   * chapter_users findFirst
   */
  export type chapter_usersFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_users
     */
    select?: chapter_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_usersInclude<ExtArgs> | null
    /**
     * Filter, which chapter_users to fetch.
     */
    where?: chapter_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_users to fetch.
     */
    orderBy?: chapter_usersOrderByWithRelationInput | chapter_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chapter_users.
     */
    cursor?: chapter_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chapter_users.
     */
    distinct?: Chapter_usersScalarFieldEnum | Chapter_usersScalarFieldEnum[]
  }


  /**
   * chapter_users findFirstOrThrow
   */
  export type chapter_usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_users
     */
    select?: chapter_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_usersInclude<ExtArgs> | null
    /**
     * Filter, which chapter_users to fetch.
     */
    where?: chapter_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_users to fetch.
     */
    orderBy?: chapter_usersOrderByWithRelationInput | chapter_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chapter_users.
     */
    cursor?: chapter_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chapter_users.
     */
    distinct?: Chapter_usersScalarFieldEnum | Chapter_usersScalarFieldEnum[]
  }


  /**
   * chapter_users findMany
   */
  export type chapter_usersFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_users
     */
    select?: chapter_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_usersInclude<ExtArgs> | null
    /**
     * Filter, which chapter_users to fetch.
     */
    where?: chapter_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_users to fetch.
     */
    orderBy?: chapter_usersOrderByWithRelationInput | chapter_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chapter_users.
     */
    cursor?: chapter_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_users.
     */
    skip?: number
    distinct?: Chapter_usersScalarFieldEnum | Chapter_usersScalarFieldEnum[]
  }


  /**
   * chapter_users create
   */
  export type chapter_usersCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_users
     */
    select?: chapter_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_usersInclude<ExtArgs> | null
    /**
     * The data needed to create a chapter_users.
     */
    data: XOR<chapter_usersCreateInput, chapter_usersUncheckedCreateInput>
  }


  /**
   * chapter_users createMany
   */
  export type chapter_usersCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chapter_users.
     */
    data: chapter_usersCreateManyInput | chapter_usersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * chapter_users update
   */
  export type chapter_usersUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_users
     */
    select?: chapter_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_usersInclude<ExtArgs> | null
    /**
     * The data needed to update a chapter_users.
     */
    data: XOR<chapter_usersUpdateInput, chapter_usersUncheckedUpdateInput>
    /**
     * Choose, which chapter_users to update.
     */
    where: chapter_usersWhereUniqueInput
  }


  /**
   * chapter_users updateMany
   */
  export type chapter_usersUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chapter_users.
     */
    data: XOR<chapter_usersUpdateManyMutationInput, chapter_usersUncheckedUpdateManyInput>
    /**
     * Filter which chapter_users to update
     */
    where?: chapter_usersWhereInput
  }


  /**
   * chapter_users upsert
   */
  export type chapter_usersUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_users
     */
    select?: chapter_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_usersInclude<ExtArgs> | null
    /**
     * The filter to search for the chapter_users to update in case it exists.
     */
    where: chapter_usersWhereUniqueInput
    /**
     * In case the chapter_users found by the `where` argument doesn't exist, create a new chapter_users with this data.
     */
    create: XOR<chapter_usersCreateInput, chapter_usersUncheckedCreateInput>
    /**
     * In case the chapter_users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chapter_usersUpdateInput, chapter_usersUncheckedUpdateInput>
  }


  /**
   * chapter_users delete
   */
  export type chapter_usersDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_users
     */
    select?: chapter_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_usersInclude<ExtArgs> | null
    /**
     * Filter which chapter_users to delete.
     */
    where: chapter_usersWhereUniqueInput
  }


  /**
   * chapter_users deleteMany
   */
  export type chapter_usersDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chapter_users to delete
     */
    where?: chapter_usersWhereInput
  }


  /**
   * chapter_users without action
   */
  export type chapter_usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_users
     */
    select?: chapter_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_usersInclude<ExtArgs> | null
  }



  /**
   * Model chapter_roles
   */


  export type AggregateChapter_roles = {
    _count: Chapter_rolesCountAggregateOutputType | null
    _avg: Chapter_rolesAvgAggregateOutputType | null
    _sum: Chapter_rolesSumAggregateOutputType | null
    _min: Chapter_rolesMinAggregateOutputType | null
    _max: Chapter_rolesMaxAggregateOutputType | null
  }

  export type Chapter_rolesAvgAggregateOutputType = {
    id: number | null
  }

  export type Chapter_rolesSumAggregateOutputType = {
    id: number | null
  }

  export type Chapter_rolesMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
  }

  export type Chapter_rolesMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
  }

  export type Chapter_rolesCountAggregateOutputType = {
    created_at: number
    updated_at: number
    id: number
    name: number
    _all: number
  }


  export type Chapter_rolesAvgAggregateInputType = {
    id?: true
  }

  export type Chapter_rolesSumAggregateInputType = {
    id?: true
  }

  export type Chapter_rolesMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
  }

  export type Chapter_rolesMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
  }

  export type Chapter_rolesCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    _all?: true
  }

  export type Chapter_rolesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chapter_roles to aggregate.
     */
    where?: chapter_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_roles to fetch.
     */
    orderBy?: chapter_rolesOrderByWithRelationInput | chapter_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chapter_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chapter_roles
    **/
    _count?: true | Chapter_rolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Chapter_rolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Chapter_rolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chapter_rolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chapter_rolesMaxAggregateInputType
  }

  export type GetChapter_rolesAggregateType<T extends Chapter_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateChapter_roles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapter_roles[P]>
      : GetScalarType<T[P], AggregateChapter_roles[P]>
  }




  export type chapter_rolesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: chapter_rolesWhereInput
    orderBy?: chapter_rolesOrderByWithAggregationInput | chapter_rolesOrderByWithAggregationInput[]
    by: Chapter_rolesScalarFieldEnum[] | Chapter_rolesScalarFieldEnum
    having?: chapter_rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chapter_rolesCountAggregateInputType | true
    _avg?: Chapter_rolesAvgAggregateInputType
    _sum?: Chapter_rolesSumAggregateInputType
    _min?: Chapter_rolesMinAggregateInputType
    _max?: Chapter_rolesMaxAggregateInputType
  }


  export type Chapter_rolesGroupByOutputType = {
    created_at: Date
    updated_at: Date
    id: number
    name: string
    _count: Chapter_rolesCountAggregateOutputType | null
    _avg: Chapter_rolesAvgAggregateOutputType | null
    _sum: Chapter_rolesSumAggregateOutputType | null
    _min: Chapter_rolesMinAggregateOutputType | null
    _max: Chapter_rolesMaxAggregateOutputType | null
  }

  type GetChapter_rolesGroupByPayload<T extends chapter_rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Chapter_rolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chapter_rolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chapter_rolesGroupByOutputType[P]>
            : GetScalarType<T[P], Chapter_rolesGroupByOutputType[P]>
        }
      >
    >


  export type chapter_rolesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
    chapter_users?: boolean | chapter_roles$chapter_usersArgs<ExtArgs>
    chapter_role_permissions?: boolean | chapter_roles$chapter_role_permissionsArgs<ExtArgs>
    _count?: boolean | Chapter_rolesCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["chapter_roles"]>

  export type chapter_rolesSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
  }

  export type chapter_rolesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    chapter_users?: boolean | chapter_roles$chapter_usersArgs<ExtArgs>
    chapter_role_permissions?: boolean | chapter_roles$chapter_role_permissionsArgs<ExtArgs>
    _count?: boolean | Chapter_rolesCountOutputTypeArgs<ExtArgs>
  }


  type chapter_rolesGetPayload<S extends boolean | null | undefined | chapter_rolesArgs> = $Types.GetResult<chapter_rolesPayload, S>

  type chapter_rolesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<chapter_rolesFindManyArgs, 'select' | 'include'> & {
      select?: Chapter_rolesCountAggregateInputType | true
    }

  export interface chapter_rolesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chapter_roles'], meta: { name: 'chapter_roles' } }
    /**
     * Find zero or one Chapter_roles that matches the filter.
     * @param {chapter_rolesFindUniqueArgs} args - Arguments to find a Chapter_roles
     * @example
     * // Get one Chapter_roles
     * const chapter_roles = await prisma.chapter_roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends chapter_rolesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_rolesFindUniqueArgs<ExtArgs>>
    ): Prisma__chapter_rolesClient<$Types.GetResult<chapter_rolesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Chapter_roles that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {chapter_rolesFindUniqueOrThrowArgs} args - Arguments to find a Chapter_roles
     * @example
     * // Get one Chapter_roles
     * const chapter_roles = await prisma.chapter_roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends chapter_rolesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_rolesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__chapter_rolesClient<$Types.GetResult<chapter_rolesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Chapter_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_rolesFindFirstArgs} args - Arguments to find a Chapter_roles
     * @example
     * // Get one Chapter_roles
     * const chapter_roles = await prisma.chapter_roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends chapter_rolesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_rolesFindFirstArgs<ExtArgs>>
    ): Prisma__chapter_rolesClient<$Types.GetResult<chapter_rolesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Chapter_roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_rolesFindFirstOrThrowArgs} args - Arguments to find a Chapter_roles
     * @example
     * // Get one Chapter_roles
     * const chapter_roles = await prisma.chapter_roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends chapter_rolesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_rolesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__chapter_rolesClient<$Types.GetResult<chapter_rolesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Chapter_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_rolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapter_roles
     * const chapter_roles = await prisma.chapter_roles.findMany()
     * 
     * // Get first 10 Chapter_roles
     * const chapter_roles = await prisma.chapter_roles.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const chapter_rolesWithCreated_atOnly = await prisma.chapter_roles.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends chapter_rolesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_rolesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<chapter_rolesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Chapter_roles.
     * @param {chapter_rolesCreateArgs} args - Arguments to create a Chapter_roles.
     * @example
     * // Create one Chapter_roles
     * const Chapter_roles = await prisma.chapter_roles.create({
     *   data: {
     *     // ... data to create a Chapter_roles
     *   }
     * })
     * 
    **/
    create<T extends chapter_rolesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_rolesCreateArgs<ExtArgs>>
    ): Prisma__chapter_rolesClient<$Types.GetResult<chapter_rolesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Chapter_roles.
     *     @param {chapter_rolesCreateManyArgs} args - Arguments to create many Chapter_roles.
     *     @example
     *     // Create many Chapter_roles
     *     const chapter_roles = await prisma.chapter_roles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends chapter_rolesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_rolesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chapter_roles.
     * @param {chapter_rolesDeleteArgs} args - Arguments to delete one Chapter_roles.
     * @example
     * // Delete one Chapter_roles
     * const Chapter_roles = await prisma.chapter_roles.delete({
     *   where: {
     *     // ... filter to delete one Chapter_roles
     *   }
     * })
     * 
    **/
    delete<T extends chapter_rolesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_rolesDeleteArgs<ExtArgs>>
    ): Prisma__chapter_rolesClient<$Types.GetResult<chapter_rolesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Chapter_roles.
     * @param {chapter_rolesUpdateArgs} args - Arguments to update one Chapter_roles.
     * @example
     * // Update one Chapter_roles
     * const chapter_roles = await prisma.chapter_roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends chapter_rolesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_rolesUpdateArgs<ExtArgs>>
    ): Prisma__chapter_rolesClient<$Types.GetResult<chapter_rolesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Chapter_roles.
     * @param {chapter_rolesDeleteManyArgs} args - Arguments to filter Chapter_roles to delete.
     * @example
     * // Delete a few Chapter_roles
     * const { count } = await prisma.chapter_roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends chapter_rolesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_rolesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapter_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapter_roles
     * const chapter_roles = await prisma.chapter_roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends chapter_rolesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_rolesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chapter_roles.
     * @param {chapter_rolesUpsertArgs} args - Arguments to update or create a Chapter_roles.
     * @example
     * // Update or create a Chapter_roles
     * const chapter_roles = await prisma.chapter_roles.upsert({
     *   create: {
     *     // ... data to create a Chapter_roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapter_roles we want to update
     *   }
     * })
    **/
    upsert<T extends chapter_rolesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_rolesUpsertArgs<ExtArgs>>
    ): Prisma__chapter_rolesClient<$Types.GetResult<chapter_rolesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Chapter_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_rolesCountArgs} args - Arguments to filter Chapter_roles to count.
     * @example
     * // Count the number of Chapter_roles
     * const count = await prisma.chapter_roles.count({
     *   where: {
     *     // ... the filter for the Chapter_roles we want to count
     *   }
     * })
    **/
    count<T extends chapter_rolesCountArgs>(
      args?: Subset<T, chapter_rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chapter_rolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapter_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chapter_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chapter_rolesAggregateArgs>(args: Subset<T, Chapter_rolesAggregateArgs>): Prisma.PrismaPromise<GetChapter_rolesAggregateType<T>>

    /**
     * Group by Chapter_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chapter_rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chapter_rolesGroupByArgs['orderBy'] }
        : { orderBy?: chapter_rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chapter_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapter_rolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chapter_roles model
   */
  readonly fields: chapter_rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chapter_roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__chapter_rolesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    chapter_users<T extends chapter_roles$chapter_usersArgs<ExtArgs> = {}>(args?: Subset<T, chapter_roles$chapter_usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<chapter_usersPayload<ExtArgs>, T, 'findMany'>| Null>;

    chapter_role_permissions<T extends chapter_roles$chapter_role_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, chapter_roles$chapter_role_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<chapter_role_permissionsPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the chapter_roles model
   */ 
  interface chapter_rolesFieldRefs {
    readonly created_at: FieldRef<"chapter_roles", 'DateTime'>
    readonly updated_at: FieldRef<"chapter_roles", 'DateTime'>
    readonly id: FieldRef<"chapter_roles", 'Int'>
    readonly name: FieldRef<"chapter_roles", 'String'>
  }
    

  // Custom InputTypes

  /**
   * chapter_roles findUnique
   */
  export type chapter_rolesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_roles
     */
    select?: chapter_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_rolesInclude<ExtArgs> | null
    /**
     * Filter, which chapter_roles to fetch.
     */
    where: chapter_rolesWhereUniqueInput
  }


  /**
   * chapter_roles findUniqueOrThrow
   */
  export type chapter_rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_roles
     */
    select?: chapter_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_rolesInclude<ExtArgs> | null
    /**
     * Filter, which chapter_roles to fetch.
     */
    where: chapter_rolesWhereUniqueInput
  }


  /**
   * chapter_roles findFirst
   */
  export type chapter_rolesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_roles
     */
    select?: chapter_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_rolesInclude<ExtArgs> | null
    /**
     * Filter, which chapter_roles to fetch.
     */
    where?: chapter_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_roles to fetch.
     */
    orderBy?: chapter_rolesOrderByWithRelationInput | chapter_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chapter_roles.
     */
    cursor?: chapter_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chapter_roles.
     */
    distinct?: Chapter_rolesScalarFieldEnum | Chapter_rolesScalarFieldEnum[]
  }


  /**
   * chapter_roles findFirstOrThrow
   */
  export type chapter_rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_roles
     */
    select?: chapter_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_rolesInclude<ExtArgs> | null
    /**
     * Filter, which chapter_roles to fetch.
     */
    where?: chapter_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_roles to fetch.
     */
    orderBy?: chapter_rolesOrderByWithRelationInput | chapter_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chapter_roles.
     */
    cursor?: chapter_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chapter_roles.
     */
    distinct?: Chapter_rolesScalarFieldEnum | Chapter_rolesScalarFieldEnum[]
  }


  /**
   * chapter_roles findMany
   */
  export type chapter_rolesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_roles
     */
    select?: chapter_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_rolesInclude<ExtArgs> | null
    /**
     * Filter, which chapter_roles to fetch.
     */
    where?: chapter_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_roles to fetch.
     */
    orderBy?: chapter_rolesOrderByWithRelationInput | chapter_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chapter_roles.
     */
    cursor?: chapter_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_roles.
     */
    skip?: number
    distinct?: Chapter_rolesScalarFieldEnum | Chapter_rolesScalarFieldEnum[]
  }


  /**
   * chapter_roles create
   */
  export type chapter_rolesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_roles
     */
    select?: chapter_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a chapter_roles.
     */
    data: XOR<chapter_rolesCreateInput, chapter_rolesUncheckedCreateInput>
  }


  /**
   * chapter_roles createMany
   */
  export type chapter_rolesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chapter_roles.
     */
    data: chapter_rolesCreateManyInput | chapter_rolesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * chapter_roles update
   */
  export type chapter_rolesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_roles
     */
    select?: chapter_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a chapter_roles.
     */
    data: XOR<chapter_rolesUpdateInput, chapter_rolesUncheckedUpdateInput>
    /**
     * Choose, which chapter_roles to update.
     */
    where: chapter_rolesWhereUniqueInput
  }


  /**
   * chapter_roles updateMany
   */
  export type chapter_rolesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chapter_roles.
     */
    data: XOR<chapter_rolesUpdateManyMutationInput, chapter_rolesUncheckedUpdateManyInput>
    /**
     * Filter which chapter_roles to update
     */
    where?: chapter_rolesWhereInput
  }


  /**
   * chapter_roles upsert
   */
  export type chapter_rolesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_roles
     */
    select?: chapter_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the chapter_roles to update in case it exists.
     */
    where: chapter_rolesWhereUniqueInput
    /**
     * In case the chapter_roles found by the `where` argument doesn't exist, create a new chapter_roles with this data.
     */
    create: XOR<chapter_rolesCreateInput, chapter_rolesUncheckedCreateInput>
    /**
     * In case the chapter_roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chapter_rolesUpdateInput, chapter_rolesUncheckedUpdateInput>
  }


  /**
   * chapter_roles delete
   */
  export type chapter_rolesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_roles
     */
    select?: chapter_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_rolesInclude<ExtArgs> | null
    /**
     * Filter which chapter_roles to delete.
     */
    where: chapter_rolesWhereUniqueInput
  }


  /**
   * chapter_roles deleteMany
   */
  export type chapter_rolesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chapter_roles to delete
     */
    where?: chapter_rolesWhereInput
  }


  /**
   * chapter_roles.chapter_users
   */
  export type chapter_roles$chapter_usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_users
     */
    select?: chapter_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_usersInclude<ExtArgs> | null
    where?: chapter_usersWhereInput
    orderBy?: chapter_usersOrderByWithRelationInput | chapter_usersOrderByWithRelationInput[]
    cursor?: chapter_usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chapter_usersScalarFieldEnum | Chapter_usersScalarFieldEnum[]
  }


  /**
   * chapter_roles.chapter_role_permissions
   */
  export type chapter_roles$chapter_role_permissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_role_permissions
     */
    select?: chapter_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_role_permissionsInclude<ExtArgs> | null
    where?: chapter_role_permissionsWhereInput
    orderBy?: chapter_role_permissionsOrderByWithRelationInput | chapter_role_permissionsOrderByWithRelationInput[]
    cursor?: chapter_role_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chapter_role_permissionsScalarFieldEnum | Chapter_role_permissionsScalarFieldEnum[]
  }


  /**
   * chapter_roles without action
   */
  export type chapter_rolesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_roles
     */
    select?: chapter_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_rolesInclude<ExtArgs> | null
  }



  /**
   * Model chapter_role_permissions
   */


  export type AggregateChapter_role_permissions = {
    _count: Chapter_role_permissionsCountAggregateOutputType | null
    _avg: Chapter_role_permissionsAvgAggregateOutputType | null
    _sum: Chapter_role_permissionsSumAggregateOutputType | null
    _min: Chapter_role_permissionsMinAggregateOutputType | null
    _max: Chapter_role_permissionsMaxAggregateOutputType | null
  }

  export type Chapter_role_permissionsAvgAggregateOutputType = {
    chapter_role_id: number | null
    chapter_permissions_id: number | null
  }

  export type Chapter_role_permissionsSumAggregateOutputType = {
    chapter_role_id: number | null
    chapter_permissions_id: number | null
  }

  export type Chapter_role_permissionsMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    chapter_role_id: number | null
    chapter_permissions_id: number | null
  }

  export type Chapter_role_permissionsMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    chapter_role_id: number | null
    chapter_permissions_id: number | null
  }

  export type Chapter_role_permissionsCountAggregateOutputType = {
    created_at: number
    updated_at: number
    chapter_role_id: number
    chapter_permissions_id: number
    _all: number
  }


  export type Chapter_role_permissionsAvgAggregateInputType = {
    chapter_role_id?: true
    chapter_permissions_id?: true
  }

  export type Chapter_role_permissionsSumAggregateInputType = {
    chapter_role_id?: true
    chapter_permissions_id?: true
  }

  export type Chapter_role_permissionsMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    chapter_role_id?: true
    chapter_permissions_id?: true
  }

  export type Chapter_role_permissionsMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    chapter_role_id?: true
    chapter_permissions_id?: true
  }

  export type Chapter_role_permissionsCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    chapter_role_id?: true
    chapter_permissions_id?: true
    _all?: true
  }

  export type Chapter_role_permissionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chapter_role_permissions to aggregate.
     */
    where?: chapter_role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_role_permissions to fetch.
     */
    orderBy?: chapter_role_permissionsOrderByWithRelationInput | chapter_role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chapter_role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chapter_role_permissions
    **/
    _count?: true | Chapter_role_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Chapter_role_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Chapter_role_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chapter_role_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chapter_role_permissionsMaxAggregateInputType
  }

  export type GetChapter_role_permissionsAggregateType<T extends Chapter_role_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateChapter_role_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapter_role_permissions[P]>
      : GetScalarType<T[P], AggregateChapter_role_permissions[P]>
  }




  export type chapter_role_permissionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: chapter_role_permissionsWhereInput
    orderBy?: chapter_role_permissionsOrderByWithAggregationInput | chapter_role_permissionsOrderByWithAggregationInput[]
    by: Chapter_role_permissionsScalarFieldEnum[] | Chapter_role_permissionsScalarFieldEnum
    having?: chapter_role_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chapter_role_permissionsCountAggregateInputType | true
    _avg?: Chapter_role_permissionsAvgAggregateInputType
    _sum?: Chapter_role_permissionsSumAggregateInputType
    _min?: Chapter_role_permissionsMinAggregateInputType
    _max?: Chapter_role_permissionsMaxAggregateInputType
  }


  export type Chapter_role_permissionsGroupByOutputType = {
    created_at: Date
    updated_at: Date
    chapter_role_id: number
    chapter_permissions_id: number
    _count: Chapter_role_permissionsCountAggregateOutputType | null
    _avg: Chapter_role_permissionsAvgAggregateOutputType | null
    _sum: Chapter_role_permissionsSumAggregateOutputType | null
    _min: Chapter_role_permissionsMinAggregateOutputType | null
    _max: Chapter_role_permissionsMaxAggregateOutputType | null
  }

  type GetChapter_role_permissionsGroupByPayload<T extends chapter_role_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Chapter_role_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chapter_role_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chapter_role_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Chapter_role_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type chapter_role_permissionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    chapter_role_id?: boolean
    chapter_permissions_id?: boolean
    chapter_role?: boolean | chapter_rolesArgs<ExtArgs>
    chapter_permission?: boolean | chapter_permissionsArgs<ExtArgs>
  }, ExtArgs["result"]["chapter_role_permissions"]>

  export type chapter_role_permissionsSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    chapter_role_id?: boolean
    chapter_permissions_id?: boolean
  }

  export type chapter_role_permissionsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    chapter_role?: boolean | chapter_rolesArgs<ExtArgs>
    chapter_permission?: boolean | chapter_permissionsArgs<ExtArgs>
  }


  type chapter_role_permissionsGetPayload<S extends boolean | null | undefined | chapter_role_permissionsArgs> = $Types.GetResult<chapter_role_permissionsPayload, S>

  type chapter_role_permissionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<chapter_role_permissionsFindManyArgs, 'select' | 'include'> & {
      select?: Chapter_role_permissionsCountAggregateInputType | true
    }

  export interface chapter_role_permissionsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chapter_role_permissions'], meta: { name: 'chapter_role_permissions' } }
    /**
     * Find zero or one Chapter_role_permissions that matches the filter.
     * @param {chapter_role_permissionsFindUniqueArgs} args - Arguments to find a Chapter_role_permissions
     * @example
     * // Get one Chapter_role_permissions
     * const chapter_role_permissions = await prisma.chapter_role_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends chapter_role_permissionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_role_permissionsFindUniqueArgs<ExtArgs>>
    ): Prisma__chapter_role_permissionsClient<$Types.GetResult<chapter_role_permissionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Chapter_role_permissions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {chapter_role_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Chapter_role_permissions
     * @example
     * // Get one Chapter_role_permissions
     * const chapter_role_permissions = await prisma.chapter_role_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends chapter_role_permissionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_role_permissionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__chapter_role_permissionsClient<$Types.GetResult<chapter_role_permissionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Chapter_role_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_role_permissionsFindFirstArgs} args - Arguments to find a Chapter_role_permissions
     * @example
     * // Get one Chapter_role_permissions
     * const chapter_role_permissions = await prisma.chapter_role_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends chapter_role_permissionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_role_permissionsFindFirstArgs<ExtArgs>>
    ): Prisma__chapter_role_permissionsClient<$Types.GetResult<chapter_role_permissionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Chapter_role_permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_role_permissionsFindFirstOrThrowArgs} args - Arguments to find a Chapter_role_permissions
     * @example
     * // Get one Chapter_role_permissions
     * const chapter_role_permissions = await prisma.chapter_role_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends chapter_role_permissionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_role_permissionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__chapter_role_permissionsClient<$Types.GetResult<chapter_role_permissionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Chapter_role_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_role_permissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapter_role_permissions
     * const chapter_role_permissions = await prisma.chapter_role_permissions.findMany()
     * 
     * // Get first 10 Chapter_role_permissions
     * const chapter_role_permissions = await prisma.chapter_role_permissions.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const chapter_role_permissionsWithCreated_atOnly = await prisma.chapter_role_permissions.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends chapter_role_permissionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_role_permissionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<chapter_role_permissionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Chapter_role_permissions.
     * @param {chapter_role_permissionsCreateArgs} args - Arguments to create a Chapter_role_permissions.
     * @example
     * // Create one Chapter_role_permissions
     * const Chapter_role_permissions = await prisma.chapter_role_permissions.create({
     *   data: {
     *     // ... data to create a Chapter_role_permissions
     *   }
     * })
     * 
    **/
    create<T extends chapter_role_permissionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_role_permissionsCreateArgs<ExtArgs>>
    ): Prisma__chapter_role_permissionsClient<$Types.GetResult<chapter_role_permissionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Chapter_role_permissions.
     *     @param {chapter_role_permissionsCreateManyArgs} args - Arguments to create many Chapter_role_permissions.
     *     @example
     *     // Create many Chapter_role_permissions
     *     const chapter_role_permissions = await prisma.chapter_role_permissions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends chapter_role_permissionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_role_permissionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chapter_role_permissions.
     * @param {chapter_role_permissionsDeleteArgs} args - Arguments to delete one Chapter_role_permissions.
     * @example
     * // Delete one Chapter_role_permissions
     * const Chapter_role_permissions = await prisma.chapter_role_permissions.delete({
     *   where: {
     *     // ... filter to delete one Chapter_role_permissions
     *   }
     * })
     * 
    **/
    delete<T extends chapter_role_permissionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_role_permissionsDeleteArgs<ExtArgs>>
    ): Prisma__chapter_role_permissionsClient<$Types.GetResult<chapter_role_permissionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Chapter_role_permissions.
     * @param {chapter_role_permissionsUpdateArgs} args - Arguments to update one Chapter_role_permissions.
     * @example
     * // Update one Chapter_role_permissions
     * const chapter_role_permissions = await prisma.chapter_role_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends chapter_role_permissionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_role_permissionsUpdateArgs<ExtArgs>>
    ): Prisma__chapter_role_permissionsClient<$Types.GetResult<chapter_role_permissionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Chapter_role_permissions.
     * @param {chapter_role_permissionsDeleteManyArgs} args - Arguments to filter Chapter_role_permissions to delete.
     * @example
     * // Delete a few Chapter_role_permissions
     * const { count } = await prisma.chapter_role_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends chapter_role_permissionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_role_permissionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapter_role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_role_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapter_role_permissions
     * const chapter_role_permissions = await prisma.chapter_role_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends chapter_role_permissionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_role_permissionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chapter_role_permissions.
     * @param {chapter_role_permissionsUpsertArgs} args - Arguments to update or create a Chapter_role_permissions.
     * @example
     * // Update or create a Chapter_role_permissions
     * const chapter_role_permissions = await prisma.chapter_role_permissions.upsert({
     *   create: {
     *     // ... data to create a Chapter_role_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapter_role_permissions we want to update
     *   }
     * })
    **/
    upsert<T extends chapter_role_permissionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_role_permissionsUpsertArgs<ExtArgs>>
    ): Prisma__chapter_role_permissionsClient<$Types.GetResult<chapter_role_permissionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Chapter_role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_role_permissionsCountArgs} args - Arguments to filter Chapter_role_permissions to count.
     * @example
     * // Count the number of Chapter_role_permissions
     * const count = await prisma.chapter_role_permissions.count({
     *   where: {
     *     // ... the filter for the Chapter_role_permissions we want to count
     *   }
     * })
    **/
    count<T extends chapter_role_permissionsCountArgs>(
      args?: Subset<T, chapter_role_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chapter_role_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapter_role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chapter_role_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chapter_role_permissionsAggregateArgs>(args: Subset<T, Chapter_role_permissionsAggregateArgs>): Prisma.PrismaPromise<GetChapter_role_permissionsAggregateType<T>>

    /**
     * Group by Chapter_role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_role_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chapter_role_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chapter_role_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: chapter_role_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chapter_role_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapter_role_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chapter_role_permissions model
   */
  readonly fields: chapter_role_permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chapter_role_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__chapter_role_permissionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    chapter_role<T extends chapter_rolesArgs<ExtArgs> = {}>(args?: Subset<T, chapter_rolesArgs<ExtArgs>>): Prisma__chapter_rolesClient<$Types.GetResult<chapter_rolesPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    chapter_permission<T extends chapter_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, chapter_permissionsArgs<ExtArgs>>): Prisma__chapter_permissionsClient<$Types.GetResult<chapter_permissionsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the chapter_role_permissions model
   */ 
  interface chapter_role_permissionsFieldRefs {
    readonly created_at: FieldRef<"chapter_role_permissions", 'DateTime'>
    readonly updated_at: FieldRef<"chapter_role_permissions", 'DateTime'>
    readonly chapter_role_id: FieldRef<"chapter_role_permissions", 'Int'>
    readonly chapter_permissions_id: FieldRef<"chapter_role_permissions", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * chapter_role_permissions findUnique
   */
  export type chapter_role_permissionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_role_permissions
     */
    select?: chapter_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which chapter_role_permissions to fetch.
     */
    where: chapter_role_permissionsWhereUniqueInput
  }


  /**
   * chapter_role_permissions findUniqueOrThrow
   */
  export type chapter_role_permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_role_permissions
     */
    select?: chapter_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which chapter_role_permissions to fetch.
     */
    where: chapter_role_permissionsWhereUniqueInput
  }


  /**
   * chapter_role_permissions findFirst
   */
  export type chapter_role_permissionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_role_permissions
     */
    select?: chapter_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which chapter_role_permissions to fetch.
     */
    where?: chapter_role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_role_permissions to fetch.
     */
    orderBy?: chapter_role_permissionsOrderByWithRelationInput | chapter_role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chapter_role_permissions.
     */
    cursor?: chapter_role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chapter_role_permissions.
     */
    distinct?: Chapter_role_permissionsScalarFieldEnum | Chapter_role_permissionsScalarFieldEnum[]
  }


  /**
   * chapter_role_permissions findFirstOrThrow
   */
  export type chapter_role_permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_role_permissions
     */
    select?: chapter_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which chapter_role_permissions to fetch.
     */
    where?: chapter_role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_role_permissions to fetch.
     */
    orderBy?: chapter_role_permissionsOrderByWithRelationInput | chapter_role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chapter_role_permissions.
     */
    cursor?: chapter_role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chapter_role_permissions.
     */
    distinct?: Chapter_role_permissionsScalarFieldEnum | Chapter_role_permissionsScalarFieldEnum[]
  }


  /**
   * chapter_role_permissions findMany
   */
  export type chapter_role_permissionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_role_permissions
     */
    select?: chapter_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which chapter_role_permissions to fetch.
     */
    where?: chapter_role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_role_permissions to fetch.
     */
    orderBy?: chapter_role_permissionsOrderByWithRelationInput | chapter_role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chapter_role_permissions.
     */
    cursor?: chapter_role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_role_permissions.
     */
    skip?: number
    distinct?: Chapter_role_permissionsScalarFieldEnum | Chapter_role_permissionsScalarFieldEnum[]
  }


  /**
   * chapter_role_permissions create
   */
  export type chapter_role_permissionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_role_permissions
     */
    select?: chapter_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_role_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a chapter_role_permissions.
     */
    data: XOR<chapter_role_permissionsCreateInput, chapter_role_permissionsUncheckedCreateInput>
  }


  /**
   * chapter_role_permissions createMany
   */
  export type chapter_role_permissionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chapter_role_permissions.
     */
    data: chapter_role_permissionsCreateManyInput | chapter_role_permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * chapter_role_permissions update
   */
  export type chapter_role_permissionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_role_permissions
     */
    select?: chapter_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_role_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a chapter_role_permissions.
     */
    data: XOR<chapter_role_permissionsUpdateInput, chapter_role_permissionsUncheckedUpdateInput>
    /**
     * Choose, which chapter_role_permissions to update.
     */
    where: chapter_role_permissionsWhereUniqueInput
  }


  /**
   * chapter_role_permissions updateMany
   */
  export type chapter_role_permissionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chapter_role_permissions.
     */
    data: XOR<chapter_role_permissionsUpdateManyMutationInput, chapter_role_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which chapter_role_permissions to update
     */
    where?: chapter_role_permissionsWhereInput
  }


  /**
   * chapter_role_permissions upsert
   */
  export type chapter_role_permissionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_role_permissions
     */
    select?: chapter_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_role_permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the chapter_role_permissions to update in case it exists.
     */
    where: chapter_role_permissionsWhereUniqueInput
    /**
     * In case the chapter_role_permissions found by the `where` argument doesn't exist, create a new chapter_role_permissions with this data.
     */
    create: XOR<chapter_role_permissionsCreateInput, chapter_role_permissionsUncheckedCreateInput>
    /**
     * In case the chapter_role_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chapter_role_permissionsUpdateInput, chapter_role_permissionsUncheckedUpdateInput>
  }


  /**
   * chapter_role_permissions delete
   */
  export type chapter_role_permissionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_role_permissions
     */
    select?: chapter_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_role_permissionsInclude<ExtArgs> | null
    /**
     * Filter which chapter_role_permissions to delete.
     */
    where: chapter_role_permissionsWhereUniqueInput
  }


  /**
   * chapter_role_permissions deleteMany
   */
  export type chapter_role_permissionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chapter_role_permissions to delete
     */
    where?: chapter_role_permissionsWhereInput
  }


  /**
   * chapter_role_permissions without action
   */
  export type chapter_role_permissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_role_permissions
     */
    select?: chapter_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_role_permissionsInclude<ExtArgs> | null
  }



  /**
   * Model chapter_permissions
   */


  export type AggregateChapter_permissions = {
    _count: Chapter_permissionsCountAggregateOutputType | null
    _avg: Chapter_permissionsAvgAggregateOutputType | null
    _sum: Chapter_permissionsSumAggregateOutputType | null
    _min: Chapter_permissionsMinAggregateOutputType | null
    _max: Chapter_permissionsMaxAggregateOutputType | null
  }

  export type Chapter_permissionsAvgAggregateOutputType = {
    id: number | null
  }

  export type Chapter_permissionsSumAggregateOutputType = {
    id: number | null
  }

  export type Chapter_permissionsMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
  }

  export type Chapter_permissionsMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
  }

  export type Chapter_permissionsCountAggregateOutputType = {
    created_at: number
    updated_at: number
    id: number
    name: number
    _all: number
  }


  export type Chapter_permissionsAvgAggregateInputType = {
    id?: true
  }

  export type Chapter_permissionsSumAggregateInputType = {
    id?: true
  }

  export type Chapter_permissionsMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
  }

  export type Chapter_permissionsMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
  }

  export type Chapter_permissionsCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    _all?: true
  }

  export type Chapter_permissionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chapter_permissions to aggregate.
     */
    where?: chapter_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_permissions to fetch.
     */
    orderBy?: chapter_permissionsOrderByWithRelationInput | chapter_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chapter_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chapter_permissions
    **/
    _count?: true | Chapter_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Chapter_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Chapter_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chapter_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chapter_permissionsMaxAggregateInputType
  }

  export type GetChapter_permissionsAggregateType<T extends Chapter_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateChapter_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapter_permissions[P]>
      : GetScalarType<T[P], AggregateChapter_permissions[P]>
  }




  export type chapter_permissionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: chapter_permissionsWhereInput
    orderBy?: chapter_permissionsOrderByWithAggregationInput | chapter_permissionsOrderByWithAggregationInput[]
    by: Chapter_permissionsScalarFieldEnum[] | Chapter_permissionsScalarFieldEnum
    having?: chapter_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chapter_permissionsCountAggregateInputType | true
    _avg?: Chapter_permissionsAvgAggregateInputType
    _sum?: Chapter_permissionsSumAggregateInputType
    _min?: Chapter_permissionsMinAggregateInputType
    _max?: Chapter_permissionsMaxAggregateInputType
  }


  export type Chapter_permissionsGroupByOutputType = {
    created_at: Date
    updated_at: Date
    id: number
    name: string
    _count: Chapter_permissionsCountAggregateOutputType | null
    _avg: Chapter_permissionsAvgAggregateOutputType | null
    _sum: Chapter_permissionsSumAggregateOutputType | null
    _min: Chapter_permissionsMinAggregateOutputType | null
    _max: Chapter_permissionsMaxAggregateOutputType | null
  }

  type GetChapter_permissionsGroupByPayload<T extends chapter_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Chapter_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chapter_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chapter_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Chapter_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type chapter_permissionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
    chapter_role_permissions?: boolean | chapter_permissions$chapter_role_permissionsArgs<ExtArgs>
    _count?: boolean | Chapter_permissionsCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["chapter_permissions"]>

  export type chapter_permissionsSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
  }

  export type chapter_permissionsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    chapter_role_permissions?: boolean | chapter_permissions$chapter_role_permissionsArgs<ExtArgs>
    _count?: boolean | Chapter_permissionsCountOutputTypeArgs<ExtArgs>
  }


  type chapter_permissionsGetPayload<S extends boolean | null | undefined | chapter_permissionsArgs> = $Types.GetResult<chapter_permissionsPayload, S>

  type chapter_permissionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<chapter_permissionsFindManyArgs, 'select' | 'include'> & {
      select?: Chapter_permissionsCountAggregateInputType | true
    }

  export interface chapter_permissionsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chapter_permissions'], meta: { name: 'chapter_permissions' } }
    /**
     * Find zero or one Chapter_permissions that matches the filter.
     * @param {chapter_permissionsFindUniqueArgs} args - Arguments to find a Chapter_permissions
     * @example
     * // Get one Chapter_permissions
     * const chapter_permissions = await prisma.chapter_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends chapter_permissionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_permissionsFindUniqueArgs<ExtArgs>>
    ): Prisma__chapter_permissionsClient<$Types.GetResult<chapter_permissionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Chapter_permissions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {chapter_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Chapter_permissions
     * @example
     * // Get one Chapter_permissions
     * const chapter_permissions = await prisma.chapter_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends chapter_permissionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_permissionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__chapter_permissionsClient<$Types.GetResult<chapter_permissionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Chapter_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_permissionsFindFirstArgs} args - Arguments to find a Chapter_permissions
     * @example
     * // Get one Chapter_permissions
     * const chapter_permissions = await prisma.chapter_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends chapter_permissionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_permissionsFindFirstArgs<ExtArgs>>
    ): Prisma__chapter_permissionsClient<$Types.GetResult<chapter_permissionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Chapter_permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_permissionsFindFirstOrThrowArgs} args - Arguments to find a Chapter_permissions
     * @example
     * // Get one Chapter_permissions
     * const chapter_permissions = await prisma.chapter_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends chapter_permissionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_permissionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__chapter_permissionsClient<$Types.GetResult<chapter_permissionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Chapter_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_permissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapter_permissions
     * const chapter_permissions = await prisma.chapter_permissions.findMany()
     * 
     * // Get first 10 Chapter_permissions
     * const chapter_permissions = await prisma.chapter_permissions.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const chapter_permissionsWithCreated_atOnly = await prisma.chapter_permissions.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends chapter_permissionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_permissionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<chapter_permissionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Chapter_permissions.
     * @param {chapter_permissionsCreateArgs} args - Arguments to create a Chapter_permissions.
     * @example
     * // Create one Chapter_permissions
     * const Chapter_permissions = await prisma.chapter_permissions.create({
     *   data: {
     *     // ... data to create a Chapter_permissions
     *   }
     * })
     * 
    **/
    create<T extends chapter_permissionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_permissionsCreateArgs<ExtArgs>>
    ): Prisma__chapter_permissionsClient<$Types.GetResult<chapter_permissionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Chapter_permissions.
     *     @param {chapter_permissionsCreateManyArgs} args - Arguments to create many Chapter_permissions.
     *     @example
     *     // Create many Chapter_permissions
     *     const chapter_permissions = await prisma.chapter_permissions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends chapter_permissionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_permissionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chapter_permissions.
     * @param {chapter_permissionsDeleteArgs} args - Arguments to delete one Chapter_permissions.
     * @example
     * // Delete one Chapter_permissions
     * const Chapter_permissions = await prisma.chapter_permissions.delete({
     *   where: {
     *     // ... filter to delete one Chapter_permissions
     *   }
     * })
     * 
    **/
    delete<T extends chapter_permissionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_permissionsDeleteArgs<ExtArgs>>
    ): Prisma__chapter_permissionsClient<$Types.GetResult<chapter_permissionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Chapter_permissions.
     * @param {chapter_permissionsUpdateArgs} args - Arguments to update one Chapter_permissions.
     * @example
     * // Update one Chapter_permissions
     * const chapter_permissions = await prisma.chapter_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends chapter_permissionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_permissionsUpdateArgs<ExtArgs>>
    ): Prisma__chapter_permissionsClient<$Types.GetResult<chapter_permissionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Chapter_permissions.
     * @param {chapter_permissionsDeleteManyArgs} args - Arguments to filter Chapter_permissions to delete.
     * @example
     * // Delete a few Chapter_permissions
     * const { count } = await prisma.chapter_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends chapter_permissionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_permissionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapter_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapter_permissions
     * const chapter_permissions = await prisma.chapter_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends chapter_permissionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_permissionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chapter_permissions.
     * @param {chapter_permissionsUpsertArgs} args - Arguments to update or create a Chapter_permissions.
     * @example
     * // Update or create a Chapter_permissions
     * const chapter_permissions = await prisma.chapter_permissions.upsert({
     *   create: {
     *     // ... data to create a Chapter_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapter_permissions we want to update
     *   }
     * })
    **/
    upsert<T extends chapter_permissionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_permissionsUpsertArgs<ExtArgs>>
    ): Prisma__chapter_permissionsClient<$Types.GetResult<chapter_permissionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Chapter_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_permissionsCountArgs} args - Arguments to filter Chapter_permissions to count.
     * @example
     * // Count the number of Chapter_permissions
     * const count = await prisma.chapter_permissions.count({
     *   where: {
     *     // ... the filter for the Chapter_permissions we want to count
     *   }
     * })
    **/
    count<T extends chapter_permissionsCountArgs>(
      args?: Subset<T, chapter_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chapter_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapter_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chapter_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chapter_permissionsAggregateArgs>(args: Subset<T, Chapter_permissionsAggregateArgs>): Prisma.PrismaPromise<GetChapter_permissionsAggregateType<T>>

    /**
     * Group by Chapter_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chapter_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chapter_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: chapter_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chapter_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapter_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chapter_permissions model
   */
  readonly fields: chapter_permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chapter_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__chapter_permissionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    chapter_role_permissions<T extends chapter_permissions$chapter_role_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, chapter_permissions$chapter_role_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<chapter_role_permissionsPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the chapter_permissions model
   */ 
  interface chapter_permissionsFieldRefs {
    readonly created_at: FieldRef<"chapter_permissions", 'DateTime'>
    readonly updated_at: FieldRef<"chapter_permissions", 'DateTime'>
    readonly id: FieldRef<"chapter_permissions", 'Int'>
    readonly name: FieldRef<"chapter_permissions", 'String'>
  }
    

  // Custom InputTypes

  /**
   * chapter_permissions findUnique
   */
  export type chapter_permissionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_permissions
     */
    select?: chapter_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which chapter_permissions to fetch.
     */
    where: chapter_permissionsWhereUniqueInput
  }


  /**
   * chapter_permissions findUniqueOrThrow
   */
  export type chapter_permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_permissions
     */
    select?: chapter_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which chapter_permissions to fetch.
     */
    where: chapter_permissionsWhereUniqueInput
  }


  /**
   * chapter_permissions findFirst
   */
  export type chapter_permissionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_permissions
     */
    select?: chapter_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which chapter_permissions to fetch.
     */
    where?: chapter_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_permissions to fetch.
     */
    orderBy?: chapter_permissionsOrderByWithRelationInput | chapter_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chapter_permissions.
     */
    cursor?: chapter_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chapter_permissions.
     */
    distinct?: Chapter_permissionsScalarFieldEnum | Chapter_permissionsScalarFieldEnum[]
  }


  /**
   * chapter_permissions findFirstOrThrow
   */
  export type chapter_permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_permissions
     */
    select?: chapter_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which chapter_permissions to fetch.
     */
    where?: chapter_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_permissions to fetch.
     */
    orderBy?: chapter_permissionsOrderByWithRelationInput | chapter_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chapter_permissions.
     */
    cursor?: chapter_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chapter_permissions.
     */
    distinct?: Chapter_permissionsScalarFieldEnum | Chapter_permissionsScalarFieldEnum[]
  }


  /**
   * chapter_permissions findMany
   */
  export type chapter_permissionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_permissions
     */
    select?: chapter_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which chapter_permissions to fetch.
     */
    where?: chapter_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_permissions to fetch.
     */
    orderBy?: chapter_permissionsOrderByWithRelationInput | chapter_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chapter_permissions.
     */
    cursor?: chapter_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_permissions.
     */
    skip?: number
    distinct?: Chapter_permissionsScalarFieldEnum | Chapter_permissionsScalarFieldEnum[]
  }


  /**
   * chapter_permissions create
   */
  export type chapter_permissionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_permissions
     */
    select?: chapter_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a chapter_permissions.
     */
    data: XOR<chapter_permissionsCreateInput, chapter_permissionsUncheckedCreateInput>
  }


  /**
   * chapter_permissions createMany
   */
  export type chapter_permissionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chapter_permissions.
     */
    data: chapter_permissionsCreateManyInput | chapter_permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * chapter_permissions update
   */
  export type chapter_permissionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_permissions
     */
    select?: chapter_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a chapter_permissions.
     */
    data: XOR<chapter_permissionsUpdateInput, chapter_permissionsUncheckedUpdateInput>
    /**
     * Choose, which chapter_permissions to update.
     */
    where: chapter_permissionsWhereUniqueInput
  }


  /**
   * chapter_permissions updateMany
   */
  export type chapter_permissionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chapter_permissions.
     */
    data: XOR<chapter_permissionsUpdateManyMutationInput, chapter_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which chapter_permissions to update
     */
    where?: chapter_permissionsWhereInput
  }


  /**
   * chapter_permissions upsert
   */
  export type chapter_permissionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_permissions
     */
    select?: chapter_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the chapter_permissions to update in case it exists.
     */
    where: chapter_permissionsWhereUniqueInput
    /**
     * In case the chapter_permissions found by the `where` argument doesn't exist, create a new chapter_permissions with this data.
     */
    create: XOR<chapter_permissionsCreateInput, chapter_permissionsUncheckedCreateInput>
    /**
     * In case the chapter_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chapter_permissionsUpdateInput, chapter_permissionsUncheckedUpdateInput>
  }


  /**
   * chapter_permissions delete
   */
  export type chapter_permissionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_permissions
     */
    select?: chapter_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_permissionsInclude<ExtArgs> | null
    /**
     * Filter which chapter_permissions to delete.
     */
    where: chapter_permissionsWhereUniqueInput
  }


  /**
   * chapter_permissions deleteMany
   */
  export type chapter_permissionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chapter_permissions to delete
     */
    where?: chapter_permissionsWhereInput
  }


  /**
   * chapter_permissions.chapter_role_permissions
   */
  export type chapter_permissions$chapter_role_permissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_role_permissions
     */
    select?: chapter_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_role_permissionsInclude<ExtArgs> | null
    where?: chapter_role_permissionsWhereInput
    orderBy?: chapter_role_permissionsOrderByWithRelationInput | chapter_role_permissionsOrderByWithRelationInput[]
    cursor?: chapter_role_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chapter_role_permissionsScalarFieldEnum | Chapter_role_permissionsScalarFieldEnum[]
  }


  /**
   * chapter_permissions without action
   */
  export type chapter_permissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_permissions
     */
    select?: chapter_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_permissionsInclude<ExtArgs> | null
  }



  /**
   * Model chapter_tags
   */


  export type AggregateChapter_tags = {
    _count: Chapter_tagsCountAggregateOutputType | null
    _avg: Chapter_tagsAvgAggregateOutputType | null
    _sum: Chapter_tagsSumAggregateOutputType | null
    _min: Chapter_tagsMinAggregateOutputType | null
    _max: Chapter_tagsMaxAggregateOutputType | null
  }

  export type Chapter_tagsAvgAggregateOutputType = {
    chapter_id: number | null
    tag_id: number | null
  }

  export type Chapter_tagsSumAggregateOutputType = {
    chapter_id: number | null
    tag_id: number | null
  }

  export type Chapter_tagsMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    chapter_id: number | null
    tag_id: number | null
  }

  export type Chapter_tagsMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    chapter_id: number | null
    tag_id: number | null
  }

  export type Chapter_tagsCountAggregateOutputType = {
    created_at: number
    updated_at: number
    chapter_id: number
    tag_id: number
    _all: number
  }


  export type Chapter_tagsAvgAggregateInputType = {
    chapter_id?: true
    tag_id?: true
  }

  export type Chapter_tagsSumAggregateInputType = {
    chapter_id?: true
    tag_id?: true
  }

  export type Chapter_tagsMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    chapter_id?: true
    tag_id?: true
  }

  export type Chapter_tagsMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    chapter_id?: true
    tag_id?: true
  }

  export type Chapter_tagsCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    chapter_id?: true
    tag_id?: true
    _all?: true
  }

  export type Chapter_tagsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chapter_tags to aggregate.
     */
    where?: chapter_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_tags to fetch.
     */
    orderBy?: chapter_tagsOrderByWithRelationInput | chapter_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chapter_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chapter_tags
    **/
    _count?: true | Chapter_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Chapter_tagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Chapter_tagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chapter_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chapter_tagsMaxAggregateInputType
  }

  export type GetChapter_tagsAggregateType<T extends Chapter_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregateChapter_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapter_tags[P]>
      : GetScalarType<T[P], AggregateChapter_tags[P]>
  }




  export type chapter_tagsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: chapter_tagsWhereInput
    orderBy?: chapter_tagsOrderByWithAggregationInput | chapter_tagsOrderByWithAggregationInput[]
    by: Chapter_tagsScalarFieldEnum[] | Chapter_tagsScalarFieldEnum
    having?: chapter_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chapter_tagsCountAggregateInputType | true
    _avg?: Chapter_tagsAvgAggregateInputType
    _sum?: Chapter_tagsSumAggregateInputType
    _min?: Chapter_tagsMinAggregateInputType
    _max?: Chapter_tagsMaxAggregateInputType
  }


  export type Chapter_tagsGroupByOutputType = {
    created_at: Date
    updated_at: Date
    chapter_id: number
    tag_id: number
    _count: Chapter_tagsCountAggregateOutputType | null
    _avg: Chapter_tagsAvgAggregateOutputType | null
    _sum: Chapter_tagsSumAggregateOutputType | null
    _min: Chapter_tagsMinAggregateOutputType | null
    _max: Chapter_tagsMaxAggregateOutputType | null
  }

  type GetChapter_tagsGroupByPayload<T extends chapter_tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Chapter_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chapter_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chapter_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Chapter_tagsGroupByOutputType[P]>
        }
      >
    >


  export type chapter_tagsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    chapter_id?: boolean
    tag_id?: boolean
    chapter?: boolean | chaptersArgs<ExtArgs>
    tag?: boolean | tagsArgs<ExtArgs>
  }, ExtArgs["result"]["chapter_tags"]>

  export type chapter_tagsSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    chapter_id?: boolean
    tag_id?: boolean
  }

  export type chapter_tagsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    chapter?: boolean | chaptersArgs<ExtArgs>
    tag?: boolean | tagsArgs<ExtArgs>
  }


  type chapter_tagsGetPayload<S extends boolean | null | undefined | chapter_tagsArgs> = $Types.GetResult<chapter_tagsPayload, S>

  type chapter_tagsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<chapter_tagsFindManyArgs, 'select' | 'include'> & {
      select?: Chapter_tagsCountAggregateInputType | true
    }

  export interface chapter_tagsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chapter_tags'], meta: { name: 'chapter_tags' } }
    /**
     * Find zero or one Chapter_tags that matches the filter.
     * @param {chapter_tagsFindUniqueArgs} args - Arguments to find a Chapter_tags
     * @example
     * // Get one Chapter_tags
     * const chapter_tags = await prisma.chapter_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends chapter_tagsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_tagsFindUniqueArgs<ExtArgs>>
    ): Prisma__chapter_tagsClient<$Types.GetResult<chapter_tagsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Chapter_tags that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {chapter_tagsFindUniqueOrThrowArgs} args - Arguments to find a Chapter_tags
     * @example
     * // Get one Chapter_tags
     * const chapter_tags = await prisma.chapter_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends chapter_tagsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_tagsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__chapter_tagsClient<$Types.GetResult<chapter_tagsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Chapter_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_tagsFindFirstArgs} args - Arguments to find a Chapter_tags
     * @example
     * // Get one Chapter_tags
     * const chapter_tags = await prisma.chapter_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends chapter_tagsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_tagsFindFirstArgs<ExtArgs>>
    ): Prisma__chapter_tagsClient<$Types.GetResult<chapter_tagsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Chapter_tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_tagsFindFirstOrThrowArgs} args - Arguments to find a Chapter_tags
     * @example
     * // Get one Chapter_tags
     * const chapter_tags = await prisma.chapter_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends chapter_tagsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_tagsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__chapter_tagsClient<$Types.GetResult<chapter_tagsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Chapter_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_tagsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapter_tags
     * const chapter_tags = await prisma.chapter_tags.findMany()
     * 
     * // Get first 10 Chapter_tags
     * const chapter_tags = await prisma.chapter_tags.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const chapter_tagsWithCreated_atOnly = await prisma.chapter_tags.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends chapter_tagsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_tagsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<chapter_tagsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Chapter_tags.
     * @param {chapter_tagsCreateArgs} args - Arguments to create a Chapter_tags.
     * @example
     * // Create one Chapter_tags
     * const Chapter_tags = await prisma.chapter_tags.create({
     *   data: {
     *     // ... data to create a Chapter_tags
     *   }
     * })
     * 
    **/
    create<T extends chapter_tagsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_tagsCreateArgs<ExtArgs>>
    ): Prisma__chapter_tagsClient<$Types.GetResult<chapter_tagsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Chapter_tags.
     *     @param {chapter_tagsCreateManyArgs} args - Arguments to create many Chapter_tags.
     *     @example
     *     // Create many Chapter_tags
     *     const chapter_tags = await prisma.chapter_tags.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends chapter_tagsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_tagsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chapter_tags.
     * @param {chapter_tagsDeleteArgs} args - Arguments to delete one Chapter_tags.
     * @example
     * // Delete one Chapter_tags
     * const Chapter_tags = await prisma.chapter_tags.delete({
     *   where: {
     *     // ... filter to delete one Chapter_tags
     *   }
     * })
     * 
    **/
    delete<T extends chapter_tagsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_tagsDeleteArgs<ExtArgs>>
    ): Prisma__chapter_tagsClient<$Types.GetResult<chapter_tagsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Chapter_tags.
     * @param {chapter_tagsUpdateArgs} args - Arguments to update one Chapter_tags.
     * @example
     * // Update one Chapter_tags
     * const chapter_tags = await prisma.chapter_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends chapter_tagsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_tagsUpdateArgs<ExtArgs>>
    ): Prisma__chapter_tagsClient<$Types.GetResult<chapter_tagsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Chapter_tags.
     * @param {chapter_tagsDeleteManyArgs} args - Arguments to filter Chapter_tags to delete.
     * @example
     * // Delete a few Chapter_tags
     * const { count } = await prisma.chapter_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends chapter_tagsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, chapter_tagsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapter_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapter_tags
     * const chapter_tags = await prisma.chapter_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends chapter_tagsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_tagsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chapter_tags.
     * @param {chapter_tagsUpsertArgs} args - Arguments to update or create a Chapter_tags.
     * @example
     * // Update or create a Chapter_tags
     * const chapter_tags = await prisma.chapter_tags.upsert({
     *   create: {
     *     // ... data to create a Chapter_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapter_tags we want to update
     *   }
     * })
    **/
    upsert<T extends chapter_tagsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, chapter_tagsUpsertArgs<ExtArgs>>
    ): Prisma__chapter_tagsClient<$Types.GetResult<chapter_tagsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Chapter_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_tagsCountArgs} args - Arguments to filter Chapter_tags to count.
     * @example
     * // Count the number of Chapter_tags
     * const count = await prisma.chapter_tags.count({
     *   where: {
     *     // ... the filter for the Chapter_tags we want to count
     *   }
     * })
    **/
    count<T extends chapter_tagsCountArgs>(
      args?: Subset<T, chapter_tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chapter_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapter_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chapter_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chapter_tagsAggregateArgs>(args: Subset<T, Chapter_tagsAggregateArgs>): Prisma.PrismaPromise<GetChapter_tagsAggregateType<T>>

    /**
     * Group by Chapter_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapter_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chapter_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chapter_tagsGroupByArgs['orderBy'] }
        : { orderBy?: chapter_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chapter_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapter_tagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chapter_tags model
   */
  readonly fields: chapter_tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chapter_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__chapter_tagsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    chapter<T extends chaptersArgs<ExtArgs> = {}>(args?: Subset<T, chaptersArgs<ExtArgs>>): Prisma__chaptersClient<$Types.GetResult<chaptersPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    tag<T extends tagsArgs<ExtArgs> = {}>(args?: Subset<T, tagsArgs<ExtArgs>>): Prisma__tagsClient<$Types.GetResult<tagsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the chapter_tags model
   */ 
  interface chapter_tagsFieldRefs {
    readonly created_at: FieldRef<"chapter_tags", 'DateTime'>
    readonly updated_at: FieldRef<"chapter_tags", 'DateTime'>
    readonly chapter_id: FieldRef<"chapter_tags", 'Int'>
    readonly tag_id: FieldRef<"chapter_tags", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * chapter_tags findUnique
   */
  export type chapter_tagsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_tags
     */
    select?: chapter_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_tagsInclude<ExtArgs> | null
    /**
     * Filter, which chapter_tags to fetch.
     */
    where: chapter_tagsWhereUniqueInput
  }


  /**
   * chapter_tags findUniqueOrThrow
   */
  export type chapter_tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_tags
     */
    select?: chapter_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_tagsInclude<ExtArgs> | null
    /**
     * Filter, which chapter_tags to fetch.
     */
    where: chapter_tagsWhereUniqueInput
  }


  /**
   * chapter_tags findFirst
   */
  export type chapter_tagsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_tags
     */
    select?: chapter_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_tagsInclude<ExtArgs> | null
    /**
     * Filter, which chapter_tags to fetch.
     */
    where?: chapter_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_tags to fetch.
     */
    orderBy?: chapter_tagsOrderByWithRelationInput | chapter_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chapter_tags.
     */
    cursor?: chapter_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chapter_tags.
     */
    distinct?: Chapter_tagsScalarFieldEnum | Chapter_tagsScalarFieldEnum[]
  }


  /**
   * chapter_tags findFirstOrThrow
   */
  export type chapter_tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_tags
     */
    select?: chapter_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_tagsInclude<ExtArgs> | null
    /**
     * Filter, which chapter_tags to fetch.
     */
    where?: chapter_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_tags to fetch.
     */
    orderBy?: chapter_tagsOrderByWithRelationInput | chapter_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chapter_tags.
     */
    cursor?: chapter_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chapter_tags.
     */
    distinct?: Chapter_tagsScalarFieldEnum | Chapter_tagsScalarFieldEnum[]
  }


  /**
   * chapter_tags findMany
   */
  export type chapter_tagsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_tags
     */
    select?: chapter_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_tagsInclude<ExtArgs> | null
    /**
     * Filter, which chapter_tags to fetch.
     */
    where?: chapter_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapter_tags to fetch.
     */
    orderBy?: chapter_tagsOrderByWithRelationInput | chapter_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chapter_tags.
     */
    cursor?: chapter_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapter_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapter_tags.
     */
    skip?: number
    distinct?: Chapter_tagsScalarFieldEnum | Chapter_tagsScalarFieldEnum[]
  }


  /**
   * chapter_tags create
   */
  export type chapter_tagsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_tags
     */
    select?: chapter_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a chapter_tags.
     */
    data: XOR<chapter_tagsCreateInput, chapter_tagsUncheckedCreateInput>
  }


  /**
   * chapter_tags createMany
   */
  export type chapter_tagsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chapter_tags.
     */
    data: chapter_tagsCreateManyInput | chapter_tagsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * chapter_tags update
   */
  export type chapter_tagsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_tags
     */
    select?: chapter_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a chapter_tags.
     */
    data: XOR<chapter_tagsUpdateInput, chapter_tagsUncheckedUpdateInput>
    /**
     * Choose, which chapter_tags to update.
     */
    where: chapter_tagsWhereUniqueInput
  }


  /**
   * chapter_tags updateMany
   */
  export type chapter_tagsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chapter_tags.
     */
    data: XOR<chapter_tagsUpdateManyMutationInput, chapter_tagsUncheckedUpdateManyInput>
    /**
     * Filter which chapter_tags to update
     */
    where?: chapter_tagsWhereInput
  }


  /**
   * chapter_tags upsert
   */
  export type chapter_tagsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_tags
     */
    select?: chapter_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the chapter_tags to update in case it exists.
     */
    where: chapter_tagsWhereUniqueInput
    /**
     * In case the chapter_tags found by the `where` argument doesn't exist, create a new chapter_tags with this data.
     */
    create: XOR<chapter_tagsCreateInput, chapter_tagsUncheckedCreateInput>
    /**
     * In case the chapter_tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chapter_tagsUpdateInput, chapter_tagsUncheckedUpdateInput>
  }


  /**
   * chapter_tags delete
   */
  export type chapter_tagsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_tags
     */
    select?: chapter_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_tagsInclude<ExtArgs> | null
    /**
     * Filter which chapter_tags to delete.
     */
    where: chapter_tagsWhereUniqueInput
  }


  /**
   * chapter_tags deleteMany
   */
  export type chapter_tagsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which chapter_tags to delete
     */
    where?: chapter_tagsWhereInput
  }


  /**
   * chapter_tags without action
   */
  export type chapter_tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_tags
     */
    select?: chapter_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_tagsInclude<ExtArgs> | null
  }



  /**
   * Model event_sponsors
   */


  export type AggregateEvent_sponsors = {
    _count: Event_sponsorsCountAggregateOutputType | null
    _avg: Event_sponsorsAvgAggregateOutputType | null
    _sum: Event_sponsorsSumAggregateOutputType | null
    _min: Event_sponsorsMinAggregateOutputType | null
    _max: Event_sponsorsMaxAggregateOutputType | null
  }

  export type Event_sponsorsAvgAggregateOutputType = {
    sponsor_id: number | null
    event_id: number | null
  }

  export type Event_sponsorsSumAggregateOutputType = {
    sponsor_id: number | null
    event_id: number | null
  }

  export type Event_sponsorsMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    sponsor_id: number | null
    event_id: number | null
  }

  export type Event_sponsorsMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    sponsor_id: number | null
    event_id: number | null
  }

  export type Event_sponsorsCountAggregateOutputType = {
    created_at: number
    updated_at: number
    sponsor_id: number
    event_id: number
    _all: number
  }


  export type Event_sponsorsAvgAggregateInputType = {
    sponsor_id?: true
    event_id?: true
  }

  export type Event_sponsorsSumAggregateInputType = {
    sponsor_id?: true
    event_id?: true
  }

  export type Event_sponsorsMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    sponsor_id?: true
    event_id?: true
  }

  export type Event_sponsorsMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    sponsor_id?: true
    event_id?: true
  }

  export type Event_sponsorsCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    sponsor_id?: true
    event_id?: true
    _all?: true
  }

  export type Event_sponsorsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which event_sponsors to aggregate.
     */
    where?: event_sponsorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_sponsors to fetch.
     */
    orderBy?: event_sponsorsOrderByWithRelationInput | event_sponsorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: event_sponsorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned event_sponsors
    **/
    _count?: true | Event_sponsorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Event_sponsorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Event_sponsorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Event_sponsorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Event_sponsorsMaxAggregateInputType
  }

  export type GetEvent_sponsorsAggregateType<T extends Event_sponsorsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent_sponsors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent_sponsors[P]>
      : GetScalarType<T[P], AggregateEvent_sponsors[P]>
  }




  export type event_sponsorsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: event_sponsorsWhereInput
    orderBy?: event_sponsorsOrderByWithAggregationInput | event_sponsorsOrderByWithAggregationInput[]
    by: Event_sponsorsScalarFieldEnum[] | Event_sponsorsScalarFieldEnum
    having?: event_sponsorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Event_sponsorsCountAggregateInputType | true
    _avg?: Event_sponsorsAvgAggregateInputType
    _sum?: Event_sponsorsSumAggregateInputType
    _min?: Event_sponsorsMinAggregateInputType
    _max?: Event_sponsorsMaxAggregateInputType
  }


  export type Event_sponsorsGroupByOutputType = {
    created_at: Date
    updated_at: Date
    sponsor_id: number
    event_id: number
    _count: Event_sponsorsCountAggregateOutputType | null
    _avg: Event_sponsorsAvgAggregateOutputType | null
    _sum: Event_sponsorsSumAggregateOutputType | null
    _min: Event_sponsorsMinAggregateOutputType | null
    _max: Event_sponsorsMaxAggregateOutputType | null
  }

  type GetEvent_sponsorsGroupByPayload<T extends event_sponsorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Event_sponsorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Event_sponsorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Event_sponsorsGroupByOutputType[P]>
            : GetScalarType<T[P], Event_sponsorsGroupByOutputType[P]>
        }
      >
    >


  export type event_sponsorsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    sponsor_id?: boolean
    event_id?: boolean
    event?: boolean | eventsArgs<ExtArgs>
    sponsor?: boolean | sponsorsArgs<ExtArgs>
  }, ExtArgs["result"]["event_sponsors"]>

  export type event_sponsorsSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    sponsor_id?: boolean
    event_id?: boolean
  }

  export type event_sponsorsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    event?: boolean | eventsArgs<ExtArgs>
    sponsor?: boolean | sponsorsArgs<ExtArgs>
  }


  type event_sponsorsGetPayload<S extends boolean | null | undefined | event_sponsorsArgs> = $Types.GetResult<event_sponsorsPayload, S>

  type event_sponsorsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<event_sponsorsFindManyArgs, 'select' | 'include'> & {
      select?: Event_sponsorsCountAggregateInputType | true
    }

  export interface event_sponsorsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['event_sponsors'], meta: { name: 'event_sponsors' } }
    /**
     * Find zero or one Event_sponsors that matches the filter.
     * @param {event_sponsorsFindUniqueArgs} args - Arguments to find a Event_sponsors
     * @example
     * // Get one Event_sponsors
     * const event_sponsors = await prisma.event_sponsors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends event_sponsorsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, event_sponsorsFindUniqueArgs<ExtArgs>>
    ): Prisma__event_sponsorsClient<$Types.GetResult<event_sponsorsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Event_sponsors that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {event_sponsorsFindUniqueOrThrowArgs} args - Arguments to find a Event_sponsors
     * @example
     * // Get one Event_sponsors
     * const event_sponsors = await prisma.event_sponsors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends event_sponsorsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, event_sponsorsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__event_sponsorsClient<$Types.GetResult<event_sponsorsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Event_sponsors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_sponsorsFindFirstArgs} args - Arguments to find a Event_sponsors
     * @example
     * // Get one Event_sponsors
     * const event_sponsors = await prisma.event_sponsors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends event_sponsorsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, event_sponsorsFindFirstArgs<ExtArgs>>
    ): Prisma__event_sponsorsClient<$Types.GetResult<event_sponsorsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Event_sponsors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_sponsorsFindFirstOrThrowArgs} args - Arguments to find a Event_sponsors
     * @example
     * // Get one Event_sponsors
     * const event_sponsors = await prisma.event_sponsors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends event_sponsorsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, event_sponsorsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__event_sponsorsClient<$Types.GetResult<event_sponsorsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Event_sponsors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_sponsorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Event_sponsors
     * const event_sponsors = await prisma.event_sponsors.findMany()
     * 
     * // Get first 10 Event_sponsors
     * const event_sponsors = await prisma.event_sponsors.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const event_sponsorsWithCreated_atOnly = await prisma.event_sponsors.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends event_sponsorsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_sponsorsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<event_sponsorsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Event_sponsors.
     * @param {event_sponsorsCreateArgs} args - Arguments to create a Event_sponsors.
     * @example
     * // Create one Event_sponsors
     * const Event_sponsors = await prisma.event_sponsors.create({
     *   data: {
     *     // ... data to create a Event_sponsors
     *   }
     * })
     * 
    **/
    create<T extends event_sponsorsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, event_sponsorsCreateArgs<ExtArgs>>
    ): Prisma__event_sponsorsClient<$Types.GetResult<event_sponsorsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Event_sponsors.
     *     @param {event_sponsorsCreateManyArgs} args - Arguments to create many Event_sponsors.
     *     @example
     *     // Create many Event_sponsors
     *     const event_sponsors = await prisma.event_sponsors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends event_sponsorsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_sponsorsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event_sponsors.
     * @param {event_sponsorsDeleteArgs} args - Arguments to delete one Event_sponsors.
     * @example
     * // Delete one Event_sponsors
     * const Event_sponsors = await prisma.event_sponsors.delete({
     *   where: {
     *     // ... filter to delete one Event_sponsors
     *   }
     * })
     * 
    **/
    delete<T extends event_sponsorsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, event_sponsorsDeleteArgs<ExtArgs>>
    ): Prisma__event_sponsorsClient<$Types.GetResult<event_sponsorsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Event_sponsors.
     * @param {event_sponsorsUpdateArgs} args - Arguments to update one Event_sponsors.
     * @example
     * // Update one Event_sponsors
     * const event_sponsors = await prisma.event_sponsors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends event_sponsorsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, event_sponsorsUpdateArgs<ExtArgs>>
    ): Prisma__event_sponsorsClient<$Types.GetResult<event_sponsorsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Event_sponsors.
     * @param {event_sponsorsDeleteManyArgs} args - Arguments to filter Event_sponsors to delete.
     * @example
     * // Delete a few Event_sponsors
     * const { count } = await prisma.event_sponsors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends event_sponsorsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_sponsorsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Event_sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_sponsorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Event_sponsors
     * const event_sponsors = await prisma.event_sponsors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends event_sponsorsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, event_sponsorsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event_sponsors.
     * @param {event_sponsorsUpsertArgs} args - Arguments to update or create a Event_sponsors.
     * @example
     * // Update or create a Event_sponsors
     * const event_sponsors = await prisma.event_sponsors.upsert({
     *   create: {
     *     // ... data to create a Event_sponsors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event_sponsors we want to update
     *   }
     * })
    **/
    upsert<T extends event_sponsorsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, event_sponsorsUpsertArgs<ExtArgs>>
    ): Prisma__event_sponsorsClient<$Types.GetResult<event_sponsorsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Event_sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_sponsorsCountArgs} args - Arguments to filter Event_sponsors to count.
     * @example
     * // Count the number of Event_sponsors
     * const count = await prisma.event_sponsors.count({
     *   where: {
     *     // ... the filter for the Event_sponsors we want to count
     *   }
     * })
    **/
    count<T extends event_sponsorsCountArgs>(
      args?: Subset<T, event_sponsorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Event_sponsorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event_sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Event_sponsorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Event_sponsorsAggregateArgs>(args: Subset<T, Event_sponsorsAggregateArgs>): Prisma.PrismaPromise<GetEvent_sponsorsAggregateType<T>>

    /**
     * Group by Event_sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_sponsorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends event_sponsorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: event_sponsorsGroupByArgs['orderBy'] }
        : { orderBy?: event_sponsorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, event_sponsorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvent_sponsorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the event_sponsors model
   */
  readonly fields: event_sponsorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for event_sponsors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__event_sponsorsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    event<T extends eventsArgs<ExtArgs> = {}>(args?: Subset<T, eventsArgs<ExtArgs>>): Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    sponsor<T extends sponsorsArgs<ExtArgs> = {}>(args?: Subset<T, sponsorsArgs<ExtArgs>>): Prisma__sponsorsClient<$Types.GetResult<sponsorsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the event_sponsors model
   */ 
  interface event_sponsorsFieldRefs {
    readonly created_at: FieldRef<"event_sponsors", 'DateTime'>
    readonly updated_at: FieldRef<"event_sponsors", 'DateTime'>
    readonly sponsor_id: FieldRef<"event_sponsors", 'Int'>
    readonly event_id: FieldRef<"event_sponsors", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * event_sponsors findUnique
   */
  export type event_sponsorsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_sponsors
     */
    select?: event_sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_sponsorsInclude<ExtArgs> | null
    /**
     * Filter, which event_sponsors to fetch.
     */
    where: event_sponsorsWhereUniqueInput
  }


  /**
   * event_sponsors findUniqueOrThrow
   */
  export type event_sponsorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_sponsors
     */
    select?: event_sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_sponsorsInclude<ExtArgs> | null
    /**
     * Filter, which event_sponsors to fetch.
     */
    where: event_sponsorsWhereUniqueInput
  }


  /**
   * event_sponsors findFirst
   */
  export type event_sponsorsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_sponsors
     */
    select?: event_sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_sponsorsInclude<ExtArgs> | null
    /**
     * Filter, which event_sponsors to fetch.
     */
    where?: event_sponsorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_sponsors to fetch.
     */
    orderBy?: event_sponsorsOrderByWithRelationInput | event_sponsorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_sponsors.
     */
    cursor?: event_sponsorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_sponsors.
     */
    distinct?: Event_sponsorsScalarFieldEnum | Event_sponsorsScalarFieldEnum[]
  }


  /**
   * event_sponsors findFirstOrThrow
   */
  export type event_sponsorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_sponsors
     */
    select?: event_sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_sponsorsInclude<ExtArgs> | null
    /**
     * Filter, which event_sponsors to fetch.
     */
    where?: event_sponsorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_sponsors to fetch.
     */
    orderBy?: event_sponsorsOrderByWithRelationInput | event_sponsorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_sponsors.
     */
    cursor?: event_sponsorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_sponsors.
     */
    distinct?: Event_sponsorsScalarFieldEnum | Event_sponsorsScalarFieldEnum[]
  }


  /**
   * event_sponsors findMany
   */
  export type event_sponsorsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_sponsors
     */
    select?: event_sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_sponsorsInclude<ExtArgs> | null
    /**
     * Filter, which event_sponsors to fetch.
     */
    where?: event_sponsorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_sponsors to fetch.
     */
    orderBy?: event_sponsorsOrderByWithRelationInput | event_sponsorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing event_sponsors.
     */
    cursor?: event_sponsorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_sponsors.
     */
    skip?: number
    distinct?: Event_sponsorsScalarFieldEnum | Event_sponsorsScalarFieldEnum[]
  }


  /**
   * event_sponsors create
   */
  export type event_sponsorsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_sponsors
     */
    select?: event_sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_sponsorsInclude<ExtArgs> | null
    /**
     * The data needed to create a event_sponsors.
     */
    data: XOR<event_sponsorsCreateInput, event_sponsorsUncheckedCreateInput>
  }


  /**
   * event_sponsors createMany
   */
  export type event_sponsorsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many event_sponsors.
     */
    data: event_sponsorsCreateManyInput | event_sponsorsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * event_sponsors update
   */
  export type event_sponsorsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_sponsors
     */
    select?: event_sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_sponsorsInclude<ExtArgs> | null
    /**
     * The data needed to update a event_sponsors.
     */
    data: XOR<event_sponsorsUpdateInput, event_sponsorsUncheckedUpdateInput>
    /**
     * Choose, which event_sponsors to update.
     */
    where: event_sponsorsWhereUniqueInput
  }


  /**
   * event_sponsors updateMany
   */
  export type event_sponsorsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update event_sponsors.
     */
    data: XOR<event_sponsorsUpdateManyMutationInput, event_sponsorsUncheckedUpdateManyInput>
    /**
     * Filter which event_sponsors to update
     */
    where?: event_sponsorsWhereInput
  }


  /**
   * event_sponsors upsert
   */
  export type event_sponsorsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_sponsors
     */
    select?: event_sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_sponsorsInclude<ExtArgs> | null
    /**
     * The filter to search for the event_sponsors to update in case it exists.
     */
    where: event_sponsorsWhereUniqueInput
    /**
     * In case the event_sponsors found by the `where` argument doesn't exist, create a new event_sponsors with this data.
     */
    create: XOR<event_sponsorsCreateInput, event_sponsorsUncheckedCreateInput>
    /**
     * In case the event_sponsors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<event_sponsorsUpdateInput, event_sponsorsUncheckedUpdateInput>
  }


  /**
   * event_sponsors delete
   */
  export type event_sponsorsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_sponsors
     */
    select?: event_sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_sponsorsInclude<ExtArgs> | null
    /**
     * Filter which event_sponsors to delete.
     */
    where: event_sponsorsWhereUniqueInput
  }


  /**
   * event_sponsors deleteMany
   */
  export type event_sponsorsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which event_sponsors to delete
     */
    where?: event_sponsorsWhereInput
  }


  /**
   * event_sponsors without action
   */
  export type event_sponsorsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_sponsors
     */
    select?: event_sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_sponsorsInclude<ExtArgs> | null
  }



  /**
   * Model event_tags
   */


  export type AggregateEvent_tags = {
    _count: Event_tagsCountAggregateOutputType | null
    _avg: Event_tagsAvgAggregateOutputType | null
    _sum: Event_tagsSumAggregateOutputType | null
    _min: Event_tagsMinAggregateOutputType | null
    _max: Event_tagsMaxAggregateOutputType | null
  }

  export type Event_tagsAvgAggregateOutputType = {
    event_id: number | null
    tag_id: number | null
  }

  export type Event_tagsSumAggregateOutputType = {
    event_id: number | null
    tag_id: number | null
  }

  export type Event_tagsMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    event_id: number | null
    tag_id: number | null
  }

  export type Event_tagsMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    event_id: number | null
    tag_id: number | null
  }

  export type Event_tagsCountAggregateOutputType = {
    created_at: number
    updated_at: number
    event_id: number
    tag_id: number
    _all: number
  }


  export type Event_tagsAvgAggregateInputType = {
    event_id?: true
    tag_id?: true
  }

  export type Event_tagsSumAggregateInputType = {
    event_id?: true
    tag_id?: true
  }

  export type Event_tagsMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    event_id?: true
    tag_id?: true
  }

  export type Event_tagsMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    event_id?: true
    tag_id?: true
  }

  export type Event_tagsCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    event_id?: true
    tag_id?: true
    _all?: true
  }

  export type Event_tagsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which event_tags to aggregate.
     */
    where?: event_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_tags to fetch.
     */
    orderBy?: event_tagsOrderByWithRelationInput | event_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: event_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned event_tags
    **/
    _count?: true | Event_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Event_tagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Event_tagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Event_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Event_tagsMaxAggregateInputType
  }

  export type GetEvent_tagsAggregateType<T extends Event_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent_tags[P]>
      : GetScalarType<T[P], AggregateEvent_tags[P]>
  }




  export type event_tagsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: event_tagsWhereInput
    orderBy?: event_tagsOrderByWithAggregationInput | event_tagsOrderByWithAggregationInput[]
    by: Event_tagsScalarFieldEnum[] | Event_tagsScalarFieldEnum
    having?: event_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Event_tagsCountAggregateInputType | true
    _avg?: Event_tagsAvgAggregateInputType
    _sum?: Event_tagsSumAggregateInputType
    _min?: Event_tagsMinAggregateInputType
    _max?: Event_tagsMaxAggregateInputType
  }


  export type Event_tagsGroupByOutputType = {
    created_at: Date
    updated_at: Date
    event_id: number
    tag_id: number
    _count: Event_tagsCountAggregateOutputType | null
    _avg: Event_tagsAvgAggregateOutputType | null
    _sum: Event_tagsSumAggregateOutputType | null
    _min: Event_tagsMinAggregateOutputType | null
    _max: Event_tagsMaxAggregateOutputType | null
  }

  type GetEvent_tagsGroupByPayload<T extends event_tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Event_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Event_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Event_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Event_tagsGroupByOutputType[P]>
        }
      >
    >


  export type event_tagsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    event_id?: boolean
    tag_id?: boolean
    event?: boolean | eventsArgs<ExtArgs>
    tag?: boolean | tagsArgs<ExtArgs>
  }, ExtArgs["result"]["event_tags"]>

  export type event_tagsSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    event_id?: boolean
    tag_id?: boolean
  }

  export type event_tagsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    event?: boolean | eventsArgs<ExtArgs>
    tag?: boolean | tagsArgs<ExtArgs>
  }


  type event_tagsGetPayload<S extends boolean | null | undefined | event_tagsArgs> = $Types.GetResult<event_tagsPayload, S>

  type event_tagsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<event_tagsFindManyArgs, 'select' | 'include'> & {
      select?: Event_tagsCountAggregateInputType | true
    }

  export interface event_tagsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['event_tags'], meta: { name: 'event_tags' } }
    /**
     * Find zero or one Event_tags that matches the filter.
     * @param {event_tagsFindUniqueArgs} args - Arguments to find a Event_tags
     * @example
     * // Get one Event_tags
     * const event_tags = await prisma.event_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends event_tagsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, event_tagsFindUniqueArgs<ExtArgs>>
    ): Prisma__event_tagsClient<$Types.GetResult<event_tagsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Event_tags that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {event_tagsFindUniqueOrThrowArgs} args - Arguments to find a Event_tags
     * @example
     * // Get one Event_tags
     * const event_tags = await prisma.event_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends event_tagsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, event_tagsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__event_tagsClient<$Types.GetResult<event_tagsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Event_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_tagsFindFirstArgs} args - Arguments to find a Event_tags
     * @example
     * // Get one Event_tags
     * const event_tags = await prisma.event_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends event_tagsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, event_tagsFindFirstArgs<ExtArgs>>
    ): Prisma__event_tagsClient<$Types.GetResult<event_tagsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Event_tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_tagsFindFirstOrThrowArgs} args - Arguments to find a Event_tags
     * @example
     * // Get one Event_tags
     * const event_tags = await prisma.event_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends event_tagsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, event_tagsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__event_tagsClient<$Types.GetResult<event_tagsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Event_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_tagsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Event_tags
     * const event_tags = await prisma.event_tags.findMany()
     * 
     * // Get first 10 Event_tags
     * const event_tags = await prisma.event_tags.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const event_tagsWithCreated_atOnly = await prisma.event_tags.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends event_tagsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_tagsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<event_tagsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Event_tags.
     * @param {event_tagsCreateArgs} args - Arguments to create a Event_tags.
     * @example
     * // Create one Event_tags
     * const Event_tags = await prisma.event_tags.create({
     *   data: {
     *     // ... data to create a Event_tags
     *   }
     * })
     * 
    **/
    create<T extends event_tagsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, event_tagsCreateArgs<ExtArgs>>
    ): Prisma__event_tagsClient<$Types.GetResult<event_tagsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Event_tags.
     *     @param {event_tagsCreateManyArgs} args - Arguments to create many Event_tags.
     *     @example
     *     // Create many Event_tags
     *     const event_tags = await prisma.event_tags.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends event_tagsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_tagsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event_tags.
     * @param {event_tagsDeleteArgs} args - Arguments to delete one Event_tags.
     * @example
     * // Delete one Event_tags
     * const Event_tags = await prisma.event_tags.delete({
     *   where: {
     *     // ... filter to delete one Event_tags
     *   }
     * })
     * 
    **/
    delete<T extends event_tagsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, event_tagsDeleteArgs<ExtArgs>>
    ): Prisma__event_tagsClient<$Types.GetResult<event_tagsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Event_tags.
     * @param {event_tagsUpdateArgs} args - Arguments to update one Event_tags.
     * @example
     * // Update one Event_tags
     * const event_tags = await prisma.event_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends event_tagsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, event_tagsUpdateArgs<ExtArgs>>
    ): Prisma__event_tagsClient<$Types.GetResult<event_tagsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Event_tags.
     * @param {event_tagsDeleteManyArgs} args - Arguments to filter Event_tags to delete.
     * @example
     * // Delete a few Event_tags
     * const { count } = await prisma.event_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends event_tagsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_tagsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Event_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Event_tags
     * const event_tags = await prisma.event_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends event_tagsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, event_tagsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event_tags.
     * @param {event_tagsUpsertArgs} args - Arguments to update or create a Event_tags.
     * @example
     * // Update or create a Event_tags
     * const event_tags = await prisma.event_tags.upsert({
     *   create: {
     *     // ... data to create a Event_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event_tags we want to update
     *   }
     * })
    **/
    upsert<T extends event_tagsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, event_tagsUpsertArgs<ExtArgs>>
    ): Prisma__event_tagsClient<$Types.GetResult<event_tagsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Event_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_tagsCountArgs} args - Arguments to filter Event_tags to count.
     * @example
     * // Count the number of Event_tags
     * const count = await prisma.event_tags.count({
     *   where: {
     *     // ... the filter for the Event_tags we want to count
     *   }
     * })
    **/
    count<T extends event_tagsCountArgs>(
      args?: Subset<T, event_tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Event_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Event_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Event_tagsAggregateArgs>(args: Subset<T, Event_tagsAggregateArgs>): Prisma.PrismaPromise<GetEvent_tagsAggregateType<T>>

    /**
     * Group by Event_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends event_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: event_tagsGroupByArgs['orderBy'] }
        : { orderBy?: event_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, event_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvent_tagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the event_tags model
   */
  readonly fields: event_tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for event_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__event_tagsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    event<T extends eventsArgs<ExtArgs> = {}>(args?: Subset<T, eventsArgs<ExtArgs>>): Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    tag<T extends tagsArgs<ExtArgs> = {}>(args?: Subset<T, tagsArgs<ExtArgs>>): Prisma__tagsClient<$Types.GetResult<tagsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the event_tags model
   */ 
  interface event_tagsFieldRefs {
    readonly created_at: FieldRef<"event_tags", 'DateTime'>
    readonly updated_at: FieldRef<"event_tags", 'DateTime'>
    readonly event_id: FieldRef<"event_tags", 'Int'>
    readonly tag_id: FieldRef<"event_tags", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * event_tags findUnique
   */
  export type event_tagsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_tags
     */
    select?: event_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_tagsInclude<ExtArgs> | null
    /**
     * Filter, which event_tags to fetch.
     */
    where: event_tagsWhereUniqueInput
  }


  /**
   * event_tags findUniqueOrThrow
   */
  export type event_tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_tags
     */
    select?: event_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_tagsInclude<ExtArgs> | null
    /**
     * Filter, which event_tags to fetch.
     */
    where: event_tagsWhereUniqueInput
  }


  /**
   * event_tags findFirst
   */
  export type event_tagsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_tags
     */
    select?: event_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_tagsInclude<ExtArgs> | null
    /**
     * Filter, which event_tags to fetch.
     */
    where?: event_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_tags to fetch.
     */
    orderBy?: event_tagsOrderByWithRelationInput | event_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_tags.
     */
    cursor?: event_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_tags.
     */
    distinct?: Event_tagsScalarFieldEnum | Event_tagsScalarFieldEnum[]
  }


  /**
   * event_tags findFirstOrThrow
   */
  export type event_tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_tags
     */
    select?: event_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_tagsInclude<ExtArgs> | null
    /**
     * Filter, which event_tags to fetch.
     */
    where?: event_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_tags to fetch.
     */
    orderBy?: event_tagsOrderByWithRelationInput | event_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_tags.
     */
    cursor?: event_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_tags.
     */
    distinct?: Event_tagsScalarFieldEnum | Event_tagsScalarFieldEnum[]
  }


  /**
   * event_tags findMany
   */
  export type event_tagsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_tags
     */
    select?: event_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_tagsInclude<ExtArgs> | null
    /**
     * Filter, which event_tags to fetch.
     */
    where?: event_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_tags to fetch.
     */
    orderBy?: event_tagsOrderByWithRelationInput | event_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing event_tags.
     */
    cursor?: event_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_tags.
     */
    skip?: number
    distinct?: Event_tagsScalarFieldEnum | Event_tagsScalarFieldEnum[]
  }


  /**
   * event_tags create
   */
  export type event_tagsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_tags
     */
    select?: event_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a event_tags.
     */
    data: XOR<event_tagsCreateInput, event_tagsUncheckedCreateInput>
  }


  /**
   * event_tags createMany
   */
  export type event_tagsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many event_tags.
     */
    data: event_tagsCreateManyInput | event_tagsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * event_tags update
   */
  export type event_tagsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_tags
     */
    select?: event_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a event_tags.
     */
    data: XOR<event_tagsUpdateInput, event_tagsUncheckedUpdateInput>
    /**
     * Choose, which event_tags to update.
     */
    where: event_tagsWhereUniqueInput
  }


  /**
   * event_tags updateMany
   */
  export type event_tagsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update event_tags.
     */
    data: XOR<event_tagsUpdateManyMutationInput, event_tagsUncheckedUpdateManyInput>
    /**
     * Filter which event_tags to update
     */
    where?: event_tagsWhereInput
  }


  /**
   * event_tags upsert
   */
  export type event_tagsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_tags
     */
    select?: event_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the event_tags to update in case it exists.
     */
    where: event_tagsWhereUniqueInput
    /**
     * In case the event_tags found by the `where` argument doesn't exist, create a new event_tags with this data.
     */
    create: XOR<event_tagsCreateInput, event_tagsUncheckedCreateInput>
    /**
     * In case the event_tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<event_tagsUpdateInput, event_tagsUncheckedUpdateInput>
  }


  /**
   * event_tags delete
   */
  export type event_tagsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_tags
     */
    select?: event_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_tagsInclude<ExtArgs> | null
    /**
     * Filter which event_tags to delete.
     */
    where: event_tagsWhereUniqueInput
  }


  /**
   * event_tags deleteMany
   */
  export type event_tagsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which event_tags to delete
     */
    where?: event_tagsWhereInput
  }


  /**
   * event_tags without action
   */
  export type event_tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_tags
     */
    select?: event_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_tagsInclude<ExtArgs> | null
  }



  /**
   * Model events
   */


  export type AggregateEvents = {
    _count: EventsCountAggregateOutputType | null
    _avg: EventsAvgAggregateOutputType | null
    _sum: EventsSumAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  export type EventsAvgAggregateOutputType = {
    id: number | null
    capacity: number | null
    venue_id: number | null
    chapter_id: number | null
  }

  export type EventsSumAggregateOutputType = {
    id: number | null
    capacity: number | null
    venue_id: number | null
    chapter_id: number | null
  }

  export type EventsMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
    description: string | null
    url: string | null
    streaming_url: string | null
    venue_type: events_venue_type_enum | null
    start_at: Date | null
    ends_at: Date | null
    canceled: boolean | null
    capacity: number | null
    invite_only: boolean | null
    image_url: string | null
    venue_id: number | null
    chapter_id: number | null
    calendar_event_id: string | null
  }

  export type EventsMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
    description: string | null
    url: string | null
    streaming_url: string | null
    venue_type: events_venue_type_enum | null
    start_at: Date | null
    ends_at: Date | null
    canceled: boolean | null
    capacity: number | null
    invite_only: boolean | null
    image_url: string | null
    venue_id: number | null
    chapter_id: number | null
    calendar_event_id: string | null
  }

  export type EventsCountAggregateOutputType = {
    created_at: number
    updated_at: number
    id: number
    name: number
    description: number
    url: number
    streaming_url: number
    venue_type: number
    start_at: number
    ends_at: number
    canceled: number
    capacity: number
    invite_only: number
    image_url: number
    venue_id: number
    chapter_id: number
    calendar_event_id: number
    _all: number
  }


  export type EventsAvgAggregateInputType = {
    id?: true
    capacity?: true
    venue_id?: true
    chapter_id?: true
  }

  export type EventsSumAggregateInputType = {
    id?: true
    capacity?: true
    venue_id?: true
    chapter_id?: true
  }

  export type EventsMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    description?: true
    url?: true
    streaming_url?: true
    venue_type?: true
    start_at?: true
    ends_at?: true
    canceled?: true
    capacity?: true
    invite_only?: true
    image_url?: true
    venue_id?: true
    chapter_id?: true
    calendar_event_id?: true
  }

  export type EventsMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    description?: true
    url?: true
    streaming_url?: true
    venue_type?: true
    start_at?: true
    ends_at?: true
    canceled?: true
    capacity?: true
    invite_only?: true
    image_url?: true
    venue_id?: true
    chapter_id?: true
    calendar_event_id?: true
  }

  export type EventsCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    description?: true
    url?: true
    streaming_url?: true
    venue_type?: true
    start_at?: true
    ends_at?: true
    canceled?: true
    capacity?: true
    invite_only?: true
    image_url?: true
    venue_id?: true
    chapter_id?: true
    calendar_event_id?: true
    _all?: true
  }

  export type EventsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which events to aggregate.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventsOrderByWithRelationInput | eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned events
    **/
    _count?: true | EventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventsMaxAggregateInputType
  }

  export type GetEventsAggregateType<T extends EventsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvents[P]>
      : GetScalarType<T[P], AggregateEvents[P]>
  }




  export type eventsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: eventsWhereInput
    orderBy?: eventsOrderByWithAggregationInput | eventsOrderByWithAggregationInput[]
    by: EventsScalarFieldEnum[] | EventsScalarFieldEnum
    having?: eventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventsCountAggregateInputType | true
    _avg?: EventsAvgAggregateInputType
    _sum?: EventsSumAggregateInputType
    _min?: EventsMinAggregateInputType
    _max?: EventsMaxAggregateInputType
  }


  export type EventsGroupByOutputType = {
    created_at: Date
    updated_at: Date
    id: number
    name: string
    description: string
    url: string | null
    streaming_url: string | null
    venue_type: events_venue_type_enum
    start_at: Date
    ends_at: Date
    canceled: boolean
    capacity: number
    invite_only: boolean
    image_url: string
    venue_id: number | null
    chapter_id: number
    calendar_event_id: string | null
    _count: EventsCountAggregateOutputType | null
    _avg: EventsAvgAggregateOutputType | null
    _sum: EventsSumAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  type GetEventsGroupByPayload<T extends eventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventsGroupByOutputType[P]>
            : GetScalarType<T[P], EventsGroupByOutputType[P]>
        }
      >
    >


  export type eventsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    streaming_url?: boolean
    venue_type?: boolean
    start_at?: boolean
    ends_at?: boolean
    canceled?: boolean
    capacity?: boolean
    invite_only?: boolean
    image_url?: boolean
    venue_id?: boolean
    chapter_id?: boolean
    calendar_event_id?: boolean
    chapter?: boolean | chaptersArgs<ExtArgs>
    venue?: boolean | events$venueArgs<ExtArgs>
    sponsors?: boolean | events$sponsorsArgs<ExtArgs>
    event_tags?: boolean | events$event_tagsArgs<ExtArgs>
    event_users?: boolean | events$event_usersArgs<ExtArgs>
    _count?: boolean | EventsCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["events"]>

  export type eventsSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    streaming_url?: boolean
    venue_type?: boolean
    start_at?: boolean
    ends_at?: boolean
    canceled?: boolean
    capacity?: boolean
    invite_only?: boolean
    image_url?: boolean
    venue_id?: boolean
    chapter_id?: boolean
    calendar_event_id?: boolean
  }

  export type eventsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    chapter?: boolean | chaptersArgs<ExtArgs>
    venue?: boolean | events$venueArgs<ExtArgs>
    sponsors?: boolean | events$sponsorsArgs<ExtArgs>
    event_tags?: boolean | events$event_tagsArgs<ExtArgs>
    event_users?: boolean | events$event_usersArgs<ExtArgs>
    _count?: boolean | EventsCountOutputTypeArgs<ExtArgs>
  }


  type eventsGetPayload<S extends boolean | null | undefined | eventsArgs> = $Types.GetResult<eventsPayload, S>

  type eventsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<eventsFindManyArgs, 'select' | 'include'> & {
      select?: EventsCountAggregateInputType | true
    }

  export interface eventsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['events'], meta: { name: 'events' } }
    /**
     * Find zero or one Events that matches the filter.
     * @param {eventsFindUniqueArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends eventsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, eventsFindUniqueArgs<ExtArgs>>
    ): Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Events that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {eventsFindUniqueOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends eventsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, eventsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsFindFirstArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends eventsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, eventsFindFirstArgs<ExtArgs>>
    ): Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Events that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsFindFirstOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends eventsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, eventsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.events.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.events.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const eventsWithCreated_atOnly = await prisma.events.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends eventsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eventsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<eventsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Events.
     * @param {eventsCreateArgs} args - Arguments to create a Events.
     * @example
     * // Create one Events
     * const Events = await prisma.events.create({
     *   data: {
     *     // ... data to create a Events
     *   }
     * })
     * 
    **/
    create<T extends eventsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, eventsCreateArgs<ExtArgs>>
    ): Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Events.
     *     @param {eventsCreateManyArgs} args - Arguments to create many Events.
     *     @example
     *     // Create many Events
     *     const events = await prisma.events.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends eventsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eventsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Events.
     * @param {eventsDeleteArgs} args - Arguments to delete one Events.
     * @example
     * // Delete one Events
     * const Events = await prisma.events.delete({
     *   where: {
     *     // ... filter to delete one Events
     *   }
     * })
     * 
    **/
    delete<T extends eventsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, eventsDeleteArgs<ExtArgs>>
    ): Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Events.
     * @param {eventsUpdateArgs} args - Arguments to update one Events.
     * @example
     * // Update one Events
     * const events = await prisma.events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends eventsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, eventsUpdateArgs<ExtArgs>>
    ): Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {eventsDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends eventsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eventsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const events = await prisma.events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends eventsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, eventsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Events.
     * @param {eventsUpsertArgs} args - Arguments to update or create a Events.
     * @example
     * // Update or create a Events
     * const events = await prisma.events.upsert({
     *   create: {
     *     // ... data to create a Events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Events we want to update
     *   }
     * })
    **/
    upsert<T extends eventsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, eventsUpsertArgs<ExtArgs>>
    ): Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.events.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends eventsCountArgs>(
      args?: Subset<T, eventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventsAggregateArgs>(args: Subset<T, EventsAggregateArgs>): Prisma.PrismaPromise<GetEventsAggregateType<T>>

    /**
     * Group by Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends eventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: eventsGroupByArgs['orderBy'] }
        : { orderBy?: eventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, eventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the events model
   */
  readonly fields: eventsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__eventsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    chapter<T extends chaptersArgs<ExtArgs> = {}>(args?: Subset<T, chaptersArgs<ExtArgs>>): Prisma__chaptersClient<$Types.GetResult<chaptersPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    venue<T extends events$venueArgs<ExtArgs> = {}>(args?: Subset<T, events$venueArgs<ExtArgs>>): Prisma__venuesClient<$Types.GetResult<venuesPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    sponsors<T extends events$sponsorsArgs<ExtArgs> = {}>(args?: Subset<T, events$sponsorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<event_sponsorsPayload<ExtArgs>, T, 'findMany'>| Null>;

    event_tags<T extends events$event_tagsArgs<ExtArgs> = {}>(args?: Subset<T, events$event_tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<event_tagsPayload<ExtArgs>, T, 'findMany'>| Null>;

    event_users<T extends events$event_usersArgs<ExtArgs> = {}>(args?: Subset<T, events$event_usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<event_usersPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the events model
   */ 
  interface eventsFieldRefs {
    readonly created_at: FieldRef<"events", 'DateTime'>
    readonly updated_at: FieldRef<"events", 'DateTime'>
    readonly id: FieldRef<"events", 'Int'>
    readonly name: FieldRef<"events", 'String'>
    readonly description: FieldRef<"events", 'String'>
    readonly url: FieldRef<"events", 'String'>
    readonly streaming_url: FieldRef<"events", 'String'>
    readonly venue_type: FieldRef<"events", 'events_venue_type_enum'>
    readonly start_at: FieldRef<"events", 'DateTime'>
    readonly ends_at: FieldRef<"events", 'DateTime'>
    readonly canceled: FieldRef<"events", 'Boolean'>
    readonly capacity: FieldRef<"events", 'Int'>
    readonly invite_only: FieldRef<"events", 'Boolean'>
    readonly image_url: FieldRef<"events", 'String'>
    readonly venue_id: FieldRef<"events", 'Int'>
    readonly chapter_id: FieldRef<"events", 'Int'>
    readonly calendar_event_id: FieldRef<"events", 'String'>
  }
    

  // Custom InputTypes

  /**
   * events findUnique
   */
  export type eventsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventsInclude<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where: eventsWhereUniqueInput
  }


  /**
   * events findUniqueOrThrow
   */
  export type eventsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventsInclude<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where: eventsWhereUniqueInput
  }


  /**
   * events findFirst
   */
  export type eventsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventsInclude<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventsOrderByWithRelationInput | eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }


  /**
   * events findFirstOrThrow
   */
  export type eventsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventsInclude<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventsOrderByWithRelationInput | eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }


  /**
   * events findMany
   */
  export type eventsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventsInclude<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventsOrderByWithRelationInput | eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing events.
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }


  /**
   * events create
   */
  export type eventsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventsInclude<ExtArgs> | null
    /**
     * The data needed to create a events.
     */
    data: XOR<eventsCreateInput, eventsUncheckedCreateInput>
  }


  /**
   * events createMany
   */
  export type eventsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many events.
     */
    data: eventsCreateManyInput | eventsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * events update
   */
  export type eventsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventsInclude<ExtArgs> | null
    /**
     * The data needed to update a events.
     */
    data: XOR<eventsUpdateInput, eventsUncheckedUpdateInput>
    /**
     * Choose, which events to update.
     */
    where: eventsWhereUniqueInput
  }


  /**
   * events updateMany
   */
  export type eventsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update events.
     */
    data: XOR<eventsUpdateManyMutationInput, eventsUncheckedUpdateManyInput>
    /**
     * Filter which events to update
     */
    where?: eventsWhereInput
  }


  /**
   * events upsert
   */
  export type eventsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventsInclude<ExtArgs> | null
    /**
     * The filter to search for the events to update in case it exists.
     */
    where: eventsWhereUniqueInput
    /**
     * In case the events found by the `where` argument doesn't exist, create a new events with this data.
     */
    create: XOR<eventsCreateInput, eventsUncheckedCreateInput>
    /**
     * In case the events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eventsUpdateInput, eventsUncheckedUpdateInput>
  }


  /**
   * events delete
   */
  export type eventsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventsInclude<ExtArgs> | null
    /**
     * Filter which events to delete.
     */
    where: eventsWhereUniqueInput
  }


  /**
   * events deleteMany
   */
  export type eventsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which events to delete
     */
    where?: eventsWhereInput
  }


  /**
   * events.venue
   */
  export type events$venueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venues
     */
    select?: venuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venuesInclude<ExtArgs> | null
    where?: venuesWhereInput
  }


  /**
   * events.sponsors
   */
  export type events$sponsorsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_sponsors
     */
    select?: event_sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_sponsorsInclude<ExtArgs> | null
    where?: event_sponsorsWhereInput
    orderBy?: event_sponsorsOrderByWithRelationInput | event_sponsorsOrderByWithRelationInput[]
    cursor?: event_sponsorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Event_sponsorsScalarFieldEnum | Event_sponsorsScalarFieldEnum[]
  }


  /**
   * events.event_tags
   */
  export type events$event_tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_tags
     */
    select?: event_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_tagsInclude<ExtArgs> | null
    where?: event_tagsWhereInput
    orderBy?: event_tagsOrderByWithRelationInput | event_tagsOrderByWithRelationInput[]
    cursor?: event_tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Event_tagsScalarFieldEnum | Event_tagsScalarFieldEnum[]
  }


  /**
   * events.event_users
   */
  export type events$event_usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_users
     */
    select?: event_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_usersInclude<ExtArgs> | null
    where?: event_usersWhereInput
    orderBy?: event_usersOrderByWithRelationInput | event_usersOrderByWithRelationInput[]
    cursor?: event_usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Event_usersScalarFieldEnum | Event_usersScalarFieldEnum[]
  }


  /**
   * events without action
   */
  export type eventsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventsInclude<ExtArgs> | null
  }



  /**
   * Model event_roles
   */


  export type AggregateEvent_roles = {
    _count: Event_rolesCountAggregateOutputType | null
    _avg: Event_rolesAvgAggregateOutputType | null
    _sum: Event_rolesSumAggregateOutputType | null
    _min: Event_rolesMinAggregateOutputType | null
    _max: Event_rolesMaxAggregateOutputType | null
  }

  export type Event_rolesAvgAggregateOutputType = {
    id: number | null
  }

  export type Event_rolesSumAggregateOutputType = {
    id: number | null
  }

  export type Event_rolesMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
  }

  export type Event_rolesMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
  }

  export type Event_rolesCountAggregateOutputType = {
    created_at: number
    updated_at: number
    id: number
    name: number
    _all: number
  }


  export type Event_rolesAvgAggregateInputType = {
    id?: true
  }

  export type Event_rolesSumAggregateInputType = {
    id?: true
  }

  export type Event_rolesMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
  }

  export type Event_rolesMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
  }

  export type Event_rolesCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    _all?: true
  }

  export type Event_rolesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which event_roles to aggregate.
     */
    where?: event_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_roles to fetch.
     */
    orderBy?: event_rolesOrderByWithRelationInput | event_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: event_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned event_roles
    **/
    _count?: true | Event_rolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Event_rolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Event_rolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Event_rolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Event_rolesMaxAggregateInputType
  }

  export type GetEvent_rolesAggregateType<T extends Event_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent_roles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent_roles[P]>
      : GetScalarType<T[P], AggregateEvent_roles[P]>
  }




  export type event_rolesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: event_rolesWhereInput
    orderBy?: event_rolesOrderByWithAggregationInput | event_rolesOrderByWithAggregationInput[]
    by: Event_rolesScalarFieldEnum[] | Event_rolesScalarFieldEnum
    having?: event_rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Event_rolesCountAggregateInputType | true
    _avg?: Event_rolesAvgAggregateInputType
    _sum?: Event_rolesSumAggregateInputType
    _min?: Event_rolesMinAggregateInputType
    _max?: Event_rolesMaxAggregateInputType
  }


  export type Event_rolesGroupByOutputType = {
    created_at: Date
    updated_at: Date
    id: number
    name: string
    _count: Event_rolesCountAggregateOutputType | null
    _avg: Event_rolesAvgAggregateOutputType | null
    _sum: Event_rolesSumAggregateOutputType | null
    _min: Event_rolesMinAggregateOutputType | null
    _max: Event_rolesMaxAggregateOutputType | null
  }

  type GetEvent_rolesGroupByPayload<T extends event_rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Event_rolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Event_rolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Event_rolesGroupByOutputType[P]>
            : GetScalarType<T[P], Event_rolesGroupByOutputType[P]>
        }
      >
    >


  export type event_rolesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
    event_role_permissions?: boolean | event_roles$event_role_permissionsArgs<ExtArgs>
    event_users?: boolean | event_roles$event_usersArgs<ExtArgs>
    _count?: boolean | Event_rolesCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["event_roles"]>

  export type event_rolesSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
  }

  export type event_rolesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    event_role_permissions?: boolean | event_roles$event_role_permissionsArgs<ExtArgs>
    event_users?: boolean | event_roles$event_usersArgs<ExtArgs>
    _count?: boolean | Event_rolesCountOutputTypeArgs<ExtArgs>
  }


  type event_rolesGetPayload<S extends boolean | null | undefined | event_rolesArgs> = $Types.GetResult<event_rolesPayload, S>

  type event_rolesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<event_rolesFindManyArgs, 'select' | 'include'> & {
      select?: Event_rolesCountAggregateInputType | true
    }

  export interface event_rolesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['event_roles'], meta: { name: 'event_roles' } }
    /**
     * Find zero or one Event_roles that matches the filter.
     * @param {event_rolesFindUniqueArgs} args - Arguments to find a Event_roles
     * @example
     * // Get one Event_roles
     * const event_roles = await prisma.event_roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends event_rolesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, event_rolesFindUniqueArgs<ExtArgs>>
    ): Prisma__event_rolesClient<$Types.GetResult<event_rolesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Event_roles that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {event_rolesFindUniqueOrThrowArgs} args - Arguments to find a Event_roles
     * @example
     * // Get one Event_roles
     * const event_roles = await prisma.event_roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends event_rolesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, event_rolesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__event_rolesClient<$Types.GetResult<event_rolesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Event_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_rolesFindFirstArgs} args - Arguments to find a Event_roles
     * @example
     * // Get one Event_roles
     * const event_roles = await prisma.event_roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends event_rolesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, event_rolesFindFirstArgs<ExtArgs>>
    ): Prisma__event_rolesClient<$Types.GetResult<event_rolesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Event_roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_rolesFindFirstOrThrowArgs} args - Arguments to find a Event_roles
     * @example
     * // Get one Event_roles
     * const event_roles = await prisma.event_roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends event_rolesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, event_rolesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__event_rolesClient<$Types.GetResult<event_rolesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Event_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_rolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Event_roles
     * const event_roles = await prisma.event_roles.findMany()
     * 
     * // Get first 10 Event_roles
     * const event_roles = await prisma.event_roles.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const event_rolesWithCreated_atOnly = await prisma.event_roles.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends event_rolesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_rolesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<event_rolesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Event_roles.
     * @param {event_rolesCreateArgs} args - Arguments to create a Event_roles.
     * @example
     * // Create one Event_roles
     * const Event_roles = await prisma.event_roles.create({
     *   data: {
     *     // ... data to create a Event_roles
     *   }
     * })
     * 
    **/
    create<T extends event_rolesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, event_rolesCreateArgs<ExtArgs>>
    ): Prisma__event_rolesClient<$Types.GetResult<event_rolesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Event_roles.
     *     @param {event_rolesCreateManyArgs} args - Arguments to create many Event_roles.
     *     @example
     *     // Create many Event_roles
     *     const event_roles = await prisma.event_roles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends event_rolesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_rolesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event_roles.
     * @param {event_rolesDeleteArgs} args - Arguments to delete one Event_roles.
     * @example
     * // Delete one Event_roles
     * const Event_roles = await prisma.event_roles.delete({
     *   where: {
     *     // ... filter to delete one Event_roles
     *   }
     * })
     * 
    **/
    delete<T extends event_rolesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, event_rolesDeleteArgs<ExtArgs>>
    ): Prisma__event_rolesClient<$Types.GetResult<event_rolesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Event_roles.
     * @param {event_rolesUpdateArgs} args - Arguments to update one Event_roles.
     * @example
     * // Update one Event_roles
     * const event_roles = await prisma.event_roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends event_rolesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, event_rolesUpdateArgs<ExtArgs>>
    ): Prisma__event_rolesClient<$Types.GetResult<event_rolesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Event_roles.
     * @param {event_rolesDeleteManyArgs} args - Arguments to filter Event_roles to delete.
     * @example
     * // Delete a few Event_roles
     * const { count } = await prisma.event_roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends event_rolesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_rolesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Event_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Event_roles
     * const event_roles = await prisma.event_roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends event_rolesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, event_rolesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event_roles.
     * @param {event_rolesUpsertArgs} args - Arguments to update or create a Event_roles.
     * @example
     * // Update or create a Event_roles
     * const event_roles = await prisma.event_roles.upsert({
     *   create: {
     *     // ... data to create a Event_roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event_roles we want to update
     *   }
     * })
    **/
    upsert<T extends event_rolesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, event_rolesUpsertArgs<ExtArgs>>
    ): Prisma__event_rolesClient<$Types.GetResult<event_rolesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Event_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_rolesCountArgs} args - Arguments to filter Event_roles to count.
     * @example
     * // Count the number of Event_roles
     * const count = await prisma.event_roles.count({
     *   where: {
     *     // ... the filter for the Event_roles we want to count
     *   }
     * })
    **/
    count<T extends event_rolesCountArgs>(
      args?: Subset<T, event_rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Event_rolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Event_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Event_rolesAggregateArgs>(args: Subset<T, Event_rolesAggregateArgs>): Prisma.PrismaPromise<GetEvent_rolesAggregateType<T>>

    /**
     * Group by Event_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends event_rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: event_rolesGroupByArgs['orderBy'] }
        : { orderBy?: event_rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, event_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvent_rolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the event_roles model
   */
  readonly fields: event_rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for event_roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__event_rolesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    event_role_permissions<T extends event_roles$event_role_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, event_roles$event_role_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<event_role_permissionsPayload<ExtArgs>, T, 'findMany'>| Null>;

    event_users<T extends event_roles$event_usersArgs<ExtArgs> = {}>(args?: Subset<T, event_roles$event_usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<event_usersPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the event_roles model
   */ 
  interface event_rolesFieldRefs {
    readonly created_at: FieldRef<"event_roles", 'DateTime'>
    readonly updated_at: FieldRef<"event_roles", 'DateTime'>
    readonly id: FieldRef<"event_roles", 'Int'>
    readonly name: FieldRef<"event_roles", 'String'>
  }
    

  // Custom InputTypes

  /**
   * event_roles findUnique
   */
  export type event_rolesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_roles
     */
    select?: event_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_rolesInclude<ExtArgs> | null
    /**
     * Filter, which event_roles to fetch.
     */
    where: event_rolesWhereUniqueInput
  }


  /**
   * event_roles findUniqueOrThrow
   */
  export type event_rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_roles
     */
    select?: event_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_rolesInclude<ExtArgs> | null
    /**
     * Filter, which event_roles to fetch.
     */
    where: event_rolesWhereUniqueInput
  }


  /**
   * event_roles findFirst
   */
  export type event_rolesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_roles
     */
    select?: event_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_rolesInclude<ExtArgs> | null
    /**
     * Filter, which event_roles to fetch.
     */
    where?: event_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_roles to fetch.
     */
    orderBy?: event_rolesOrderByWithRelationInput | event_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_roles.
     */
    cursor?: event_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_roles.
     */
    distinct?: Event_rolesScalarFieldEnum | Event_rolesScalarFieldEnum[]
  }


  /**
   * event_roles findFirstOrThrow
   */
  export type event_rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_roles
     */
    select?: event_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_rolesInclude<ExtArgs> | null
    /**
     * Filter, which event_roles to fetch.
     */
    where?: event_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_roles to fetch.
     */
    orderBy?: event_rolesOrderByWithRelationInput | event_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_roles.
     */
    cursor?: event_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_roles.
     */
    distinct?: Event_rolesScalarFieldEnum | Event_rolesScalarFieldEnum[]
  }


  /**
   * event_roles findMany
   */
  export type event_rolesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_roles
     */
    select?: event_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_rolesInclude<ExtArgs> | null
    /**
     * Filter, which event_roles to fetch.
     */
    where?: event_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_roles to fetch.
     */
    orderBy?: event_rolesOrderByWithRelationInput | event_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing event_roles.
     */
    cursor?: event_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_roles.
     */
    skip?: number
    distinct?: Event_rolesScalarFieldEnum | Event_rolesScalarFieldEnum[]
  }


  /**
   * event_roles create
   */
  export type event_rolesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_roles
     */
    select?: event_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a event_roles.
     */
    data: XOR<event_rolesCreateInput, event_rolesUncheckedCreateInput>
  }


  /**
   * event_roles createMany
   */
  export type event_rolesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many event_roles.
     */
    data: event_rolesCreateManyInput | event_rolesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * event_roles update
   */
  export type event_rolesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_roles
     */
    select?: event_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a event_roles.
     */
    data: XOR<event_rolesUpdateInput, event_rolesUncheckedUpdateInput>
    /**
     * Choose, which event_roles to update.
     */
    where: event_rolesWhereUniqueInput
  }


  /**
   * event_roles updateMany
   */
  export type event_rolesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update event_roles.
     */
    data: XOR<event_rolesUpdateManyMutationInput, event_rolesUncheckedUpdateManyInput>
    /**
     * Filter which event_roles to update
     */
    where?: event_rolesWhereInput
  }


  /**
   * event_roles upsert
   */
  export type event_rolesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_roles
     */
    select?: event_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the event_roles to update in case it exists.
     */
    where: event_rolesWhereUniqueInput
    /**
     * In case the event_roles found by the `where` argument doesn't exist, create a new event_roles with this data.
     */
    create: XOR<event_rolesCreateInput, event_rolesUncheckedCreateInput>
    /**
     * In case the event_roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<event_rolesUpdateInput, event_rolesUncheckedUpdateInput>
  }


  /**
   * event_roles delete
   */
  export type event_rolesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_roles
     */
    select?: event_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_rolesInclude<ExtArgs> | null
    /**
     * Filter which event_roles to delete.
     */
    where: event_rolesWhereUniqueInput
  }


  /**
   * event_roles deleteMany
   */
  export type event_rolesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which event_roles to delete
     */
    where?: event_rolesWhereInput
  }


  /**
   * event_roles.event_role_permissions
   */
  export type event_roles$event_role_permissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_role_permissions
     */
    select?: event_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_role_permissionsInclude<ExtArgs> | null
    where?: event_role_permissionsWhereInput
    orderBy?: event_role_permissionsOrderByWithRelationInput | event_role_permissionsOrderByWithRelationInput[]
    cursor?: event_role_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Event_role_permissionsScalarFieldEnum | Event_role_permissionsScalarFieldEnum[]
  }


  /**
   * event_roles.event_users
   */
  export type event_roles$event_usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_users
     */
    select?: event_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_usersInclude<ExtArgs> | null
    where?: event_usersWhereInput
    orderBy?: event_usersOrderByWithRelationInput | event_usersOrderByWithRelationInput[]
    cursor?: event_usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Event_usersScalarFieldEnum | Event_usersScalarFieldEnum[]
  }


  /**
   * event_roles without action
   */
  export type event_rolesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_roles
     */
    select?: event_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_rolesInclude<ExtArgs> | null
  }



  /**
   * Model event_role_permissions
   */


  export type AggregateEvent_role_permissions = {
    _count: Event_role_permissionsCountAggregateOutputType | null
    _avg: Event_role_permissionsAvgAggregateOutputType | null
    _sum: Event_role_permissionsSumAggregateOutputType | null
    _min: Event_role_permissionsMinAggregateOutputType | null
    _max: Event_role_permissionsMaxAggregateOutputType | null
  }

  export type Event_role_permissionsAvgAggregateOutputType = {
    event_role_id: number | null
    event_permission_id: number | null
  }

  export type Event_role_permissionsSumAggregateOutputType = {
    event_role_id: number | null
    event_permission_id: number | null
  }

  export type Event_role_permissionsMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    event_role_id: number | null
    event_permission_id: number | null
  }

  export type Event_role_permissionsMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    event_role_id: number | null
    event_permission_id: number | null
  }

  export type Event_role_permissionsCountAggregateOutputType = {
    created_at: number
    updated_at: number
    event_role_id: number
    event_permission_id: number
    _all: number
  }


  export type Event_role_permissionsAvgAggregateInputType = {
    event_role_id?: true
    event_permission_id?: true
  }

  export type Event_role_permissionsSumAggregateInputType = {
    event_role_id?: true
    event_permission_id?: true
  }

  export type Event_role_permissionsMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    event_role_id?: true
    event_permission_id?: true
  }

  export type Event_role_permissionsMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    event_role_id?: true
    event_permission_id?: true
  }

  export type Event_role_permissionsCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    event_role_id?: true
    event_permission_id?: true
    _all?: true
  }

  export type Event_role_permissionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which event_role_permissions to aggregate.
     */
    where?: event_role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_role_permissions to fetch.
     */
    orderBy?: event_role_permissionsOrderByWithRelationInput | event_role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: event_role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned event_role_permissions
    **/
    _count?: true | Event_role_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Event_role_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Event_role_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Event_role_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Event_role_permissionsMaxAggregateInputType
  }

  export type GetEvent_role_permissionsAggregateType<T extends Event_role_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent_role_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent_role_permissions[P]>
      : GetScalarType<T[P], AggregateEvent_role_permissions[P]>
  }




  export type event_role_permissionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: event_role_permissionsWhereInput
    orderBy?: event_role_permissionsOrderByWithAggregationInput | event_role_permissionsOrderByWithAggregationInput[]
    by: Event_role_permissionsScalarFieldEnum[] | Event_role_permissionsScalarFieldEnum
    having?: event_role_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Event_role_permissionsCountAggregateInputType | true
    _avg?: Event_role_permissionsAvgAggregateInputType
    _sum?: Event_role_permissionsSumAggregateInputType
    _min?: Event_role_permissionsMinAggregateInputType
    _max?: Event_role_permissionsMaxAggregateInputType
  }


  export type Event_role_permissionsGroupByOutputType = {
    created_at: Date
    updated_at: Date
    event_role_id: number
    event_permission_id: number
    _count: Event_role_permissionsCountAggregateOutputType | null
    _avg: Event_role_permissionsAvgAggregateOutputType | null
    _sum: Event_role_permissionsSumAggregateOutputType | null
    _min: Event_role_permissionsMinAggregateOutputType | null
    _max: Event_role_permissionsMaxAggregateOutputType | null
  }

  type GetEvent_role_permissionsGroupByPayload<T extends event_role_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Event_role_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Event_role_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Event_role_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Event_role_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type event_role_permissionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    event_role_id?: boolean
    event_permission_id?: boolean
    event_role?: boolean | event_rolesArgs<ExtArgs>
    event_permission?: boolean | event_permissionsArgs<ExtArgs>
  }, ExtArgs["result"]["event_role_permissions"]>

  export type event_role_permissionsSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    event_role_id?: boolean
    event_permission_id?: boolean
  }

  export type event_role_permissionsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    event_role?: boolean | event_rolesArgs<ExtArgs>
    event_permission?: boolean | event_permissionsArgs<ExtArgs>
  }


  type event_role_permissionsGetPayload<S extends boolean | null | undefined | event_role_permissionsArgs> = $Types.GetResult<event_role_permissionsPayload, S>

  type event_role_permissionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<event_role_permissionsFindManyArgs, 'select' | 'include'> & {
      select?: Event_role_permissionsCountAggregateInputType | true
    }

  export interface event_role_permissionsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['event_role_permissions'], meta: { name: 'event_role_permissions' } }
    /**
     * Find zero or one Event_role_permissions that matches the filter.
     * @param {event_role_permissionsFindUniqueArgs} args - Arguments to find a Event_role_permissions
     * @example
     * // Get one Event_role_permissions
     * const event_role_permissions = await prisma.event_role_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends event_role_permissionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, event_role_permissionsFindUniqueArgs<ExtArgs>>
    ): Prisma__event_role_permissionsClient<$Types.GetResult<event_role_permissionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Event_role_permissions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {event_role_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Event_role_permissions
     * @example
     * // Get one Event_role_permissions
     * const event_role_permissions = await prisma.event_role_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends event_role_permissionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, event_role_permissionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__event_role_permissionsClient<$Types.GetResult<event_role_permissionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Event_role_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_role_permissionsFindFirstArgs} args - Arguments to find a Event_role_permissions
     * @example
     * // Get one Event_role_permissions
     * const event_role_permissions = await prisma.event_role_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends event_role_permissionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, event_role_permissionsFindFirstArgs<ExtArgs>>
    ): Prisma__event_role_permissionsClient<$Types.GetResult<event_role_permissionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Event_role_permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_role_permissionsFindFirstOrThrowArgs} args - Arguments to find a Event_role_permissions
     * @example
     * // Get one Event_role_permissions
     * const event_role_permissions = await prisma.event_role_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends event_role_permissionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, event_role_permissionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__event_role_permissionsClient<$Types.GetResult<event_role_permissionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Event_role_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_role_permissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Event_role_permissions
     * const event_role_permissions = await prisma.event_role_permissions.findMany()
     * 
     * // Get first 10 Event_role_permissions
     * const event_role_permissions = await prisma.event_role_permissions.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const event_role_permissionsWithCreated_atOnly = await prisma.event_role_permissions.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends event_role_permissionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_role_permissionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<event_role_permissionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Event_role_permissions.
     * @param {event_role_permissionsCreateArgs} args - Arguments to create a Event_role_permissions.
     * @example
     * // Create one Event_role_permissions
     * const Event_role_permissions = await prisma.event_role_permissions.create({
     *   data: {
     *     // ... data to create a Event_role_permissions
     *   }
     * })
     * 
    **/
    create<T extends event_role_permissionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, event_role_permissionsCreateArgs<ExtArgs>>
    ): Prisma__event_role_permissionsClient<$Types.GetResult<event_role_permissionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Event_role_permissions.
     *     @param {event_role_permissionsCreateManyArgs} args - Arguments to create many Event_role_permissions.
     *     @example
     *     // Create many Event_role_permissions
     *     const event_role_permissions = await prisma.event_role_permissions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends event_role_permissionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_role_permissionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event_role_permissions.
     * @param {event_role_permissionsDeleteArgs} args - Arguments to delete one Event_role_permissions.
     * @example
     * // Delete one Event_role_permissions
     * const Event_role_permissions = await prisma.event_role_permissions.delete({
     *   where: {
     *     // ... filter to delete one Event_role_permissions
     *   }
     * })
     * 
    **/
    delete<T extends event_role_permissionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, event_role_permissionsDeleteArgs<ExtArgs>>
    ): Prisma__event_role_permissionsClient<$Types.GetResult<event_role_permissionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Event_role_permissions.
     * @param {event_role_permissionsUpdateArgs} args - Arguments to update one Event_role_permissions.
     * @example
     * // Update one Event_role_permissions
     * const event_role_permissions = await prisma.event_role_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends event_role_permissionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, event_role_permissionsUpdateArgs<ExtArgs>>
    ): Prisma__event_role_permissionsClient<$Types.GetResult<event_role_permissionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Event_role_permissions.
     * @param {event_role_permissionsDeleteManyArgs} args - Arguments to filter Event_role_permissions to delete.
     * @example
     * // Delete a few Event_role_permissions
     * const { count } = await prisma.event_role_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends event_role_permissionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_role_permissionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Event_role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_role_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Event_role_permissions
     * const event_role_permissions = await prisma.event_role_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends event_role_permissionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, event_role_permissionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event_role_permissions.
     * @param {event_role_permissionsUpsertArgs} args - Arguments to update or create a Event_role_permissions.
     * @example
     * // Update or create a Event_role_permissions
     * const event_role_permissions = await prisma.event_role_permissions.upsert({
     *   create: {
     *     // ... data to create a Event_role_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event_role_permissions we want to update
     *   }
     * })
    **/
    upsert<T extends event_role_permissionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, event_role_permissionsUpsertArgs<ExtArgs>>
    ): Prisma__event_role_permissionsClient<$Types.GetResult<event_role_permissionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Event_role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_role_permissionsCountArgs} args - Arguments to filter Event_role_permissions to count.
     * @example
     * // Count the number of Event_role_permissions
     * const count = await prisma.event_role_permissions.count({
     *   where: {
     *     // ... the filter for the Event_role_permissions we want to count
     *   }
     * })
    **/
    count<T extends event_role_permissionsCountArgs>(
      args?: Subset<T, event_role_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Event_role_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event_role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Event_role_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Event_role_permissionsAggregateArgs>(args: Subset<T, Event_role_permissionsAggregateArgs>): Prisma.PrismaPromise<GetEvent_role_permissionsAggregateType<T>>

    /**
     * Group by Event_role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_role_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends event_role_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: event_role_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: event_role_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, event_role_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvent_role_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the event_role_permissions model
   */
  readonly fields: event_role_permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for event_role_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__event_role_permissionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    event_role<T extends event_rolesArgs<ExtArgs> = {}>(args?: Subset<T, event_rolesArgs<ExtArgs>>): Prisma__event_rolesClient<$Types.GetResult<event_rolesPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    event_permission<T extends event_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, event_permissionsArgs<ExtArgs>>): Prisma__event_permissionsClient<$Types.GetResult<event_permissionsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the event_role_permissions model
   */ 
  interface event_role_permissionsFieldRefs {
    readonly created_at: FieldRef<"event_role_permissions", 'DateTime'>
    readonly updated_at: FieldRef<"event_role_permissions", 'DateTime'>
    readonly event_role_id: FieldRef<"event_role_permissions", 'Int'>
    readonly event_permission_id: FieldRef<"event_role_permissions", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * event_role_permissions findUnique
   */
  export type event_role_permissionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_role_permissions
     */
    select?: event_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which event_role_permissions to fetch.
     */
    where: event_role_permissionsWhereUniqueInput
  }


  /**
   * event_role_permissions findUniqueOrThrow
   */
  export type event_role_permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_role_permissions
     */
    select?: event_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which event_role_permissions to fetch.
     */
    where: event_role_permissionsWhereUniqueInput
  }


  /**
   * event_role_permissions findFirst
   */
  export type event_role_permissionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_role_permissions
     */
    select?: event_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which event_role_permissions to fetch.
     */
    where?: event_role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_role_permissions to fetch.
     */
    orderBy?: event_role_permissionsOrderByWithRelationInput | event_role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_role_permissions.
     */
    cursor?: event_role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_role_permissions.
     */
    distinct?: Event_role_permissionsScalarFieldEnum | Event_role_permissionsScalarFieldEnum[]
  }


  /**
   * event_role_permissions findFirstOrThrow
   */
  export type event_role_permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_role_permissions
     */
    select?: event_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which event_role_permissions to fetch.
     */
    where?: event_role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_role_permissions to fetch.
     */
    orderBy?: event_role_permissionsOrderByWithRelationInput | event_role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_role_permissions.
     */
    cursor?: event_role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_role_permissions.
     */
    distinct?: Event_role_permissionsScalarFieldEnum | Event_role_permissionsScalarFieldEnum[]
  }


  /**
   * event_role_permissions findMany
   */
  export type event_role_permissionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_role_permissions
     */
    select?: event_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which event_role_permissions to fetch.
     */
    where?: event_role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_role_permissions to fetch.
     */
    orderBy?: event_role_permissionsOrderByWithRelationInput | event_role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing event_role_permissions.
     */
    cursor?: event_role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_role_permissions.
     */
    skip?: number
    distinct?: Event_role_permissionsScalarFieldEnum | Event_role_permissionsScalarFieldEnum[]
  }


  /**
   * event_role_permissions create
   */
  export type event_role_permissionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_role_permissions
     */
    select?: event_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_role_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a event_role_permissions.
     */
    data: XOR<event_role_permissionsCreateInput, event_role_permissionsUncheckedCreateInput>
  }


  /**
   * event_role_permissions createMany
   */
  export type event_role_permissionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many event_role_permissions.
     */
    data: event_role_permissionsCreateManyInput | event_role_permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * event_role_permissions update
   */
  export type event_role_permissionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_role_permissions
     */
    select?: event_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_role_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a event_role_permissions.
     */
    data: XOR<event_role_permissionsUpdateInput, event_role_permissionsUncheckedUpdateInput>
    /**
     * Choose, which event_role_permissions to update.
     */
    where: event_role_permissionsWhereUniqueInput
  }


  /**
   * event_role_permissions updateMany
   */
  export type event_role_permissionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update event_role_permissions.
     */
    data: XOR<event_role_permissionsUpdateManyMutationInput, event_role_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which event_role_permissions to update
     */
    where?: event_role_permissionsWhereInput
  }


  /**
   * event_role_permissions upsert
   */
  export type event_role_permissionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_role_permissions
     */
    select?: event_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_role_permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the event_role_permissions to update in case it exists.
     */
    where: event_role_permissionsWhereUniqueInput
    /**
     * In case the event_role_permissions found by the `where` argument doesn't exist, create a new event_role_permissions with this data.
     */
    create: XOR<event_role_permissionsCreateInput, event_role_permissionsUncheckedCreateInput>
    /**
     * In case the event_role_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<event_role_permissionsUpdateInput, event_role_permissionsUncheckedUpdateInput>
  }


  /**
   * event_role_permissions delete
   */
  export type event_role_permissionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_role_permissions
     */
    select?: event_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_role_permissionsInclude<ExtArgs> | null
    /**
     * Filter which event_role_permissions to delete.
     */
    where: event_role_permissionsWhereUniqueInput
  }


  /**
   * event_role_permissions deleteMany
   */
  export type event_role_permissionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which event_role_permissions to delete
     */
    where?: event_role_permissionsWhereInput
  }


  /**
   * event_role_permissions without action
   */
  export type event_role_permissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_role_permissions
     */
    select?: event_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_role_permissionsInclude<ExtArgs> | null
  }



  /**
   * Model event_permissions
   */


  export type AggregateEvent_permissions = {
    _count: Event_permissionsCountAggregateOutputType | null
    _avg: Event_permissionsAvgAggregateOutputType | null
    _sum: Event_permissionsSumAggregateOutputType | null
    _min: Event_permissionsMinAggregateOutputType | null
    _max: Event_permissionsMaxAggregateOutputType | null
  }

  export type Event_permissionsAvgAggregateOutputType = {
    id: number | null
  }

  export type Event_permissionsSumAggregateOutputType = {
    id: number | null
  }

  export type Event_permissionsMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
  }

  export type Event_permissionsMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
  }

  export type Event_permissionsCountAggregateOutputType = {
    created_at: number
    updated_at: number
    id: number
    name: number
    _all: number
  }


  export type Event_permissionsAvgAggregateInputType = {
    id?: true
  }

  export type Event_permissionsSumAggregateInputType = {
    id?: true
  }

  export type Event_permissionsMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
  }

  export type Event_permissionsMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
  }

  export type Event_permissionsCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    _all?: true
  }

  export type Event_permissionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which event_permissions to aggregate.
     */
    where?: event_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_permissions to fetch.
     */
    orderBy?: event_permissionsOrderByWithRelationInput | event_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: event_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned event_permissions
    **/
    _count?: true | Event_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Event_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Event_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Event_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Event_permissionsMaxAggregateInputType
  }

  export type GetEvent_permissionsAggregateType<T extends Event_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent_permissions[P]>
      : GetScalarType<T[P], AggregateEvent_permissions[P]>
  }




  export type event_permissionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: event_permissionsWhereInput
    orderBy?: event_permissionsOrderByWithAggregationInput | event_permissionsOrderByWithAggregationInput[]
    by: Event_permissionsScalarFieldEnum[] | Event_permissionsScalarFieldEnum
    having?: event_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Event_permissionsCountAggregateInputType | true
    _avg?: Event_permissionsAvgAggregateInputType
    _sum?: Event_permissionsSumAggregateInputType
    _min?: Event_permissionsMinAggregateInputType
    _max?: Event_permissionsMaxAggregateInputType
  }


  export type Event_permissionsGroupByOutputType = {
    created_at: Date
    updated_at: Date
    id: number
    name: string
    _count: Event_permissionsCountAggregateOutputType | null
    _avg: Event_permissionsAvgAggregateOutputType | null
    _sum: Event_permissionsSumAggregateOutputType | null
    _min: Event_permissionsMinAggregateOutputType | null
    _max: Event_permissionsMaxAggregateOutputType | null
  }

  type GetEvent_permissionsGroupByPayload<T extends event_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Event_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Event_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Event_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Event_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type event_permissionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
    event_role_permissions?: boolean | event_permissions$event_role_permissionsArgs<ExtArgs>
    _count?: boolean | Event_permissionsCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["event_permissions"]>

  export type event_permissionsSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
  }

  export type event_permissionsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    event_role_permissions?: boolean | event_permissions$event_role_permissionsArgs<ExtArgs>
    _count?: boolean | Event_permissionsCountOutputTypeArgs<ExtArgs>
  }


  type event_permissionsGetPayload<S extends boolean | null | undefined | event_permissionsArgs> = $Types.GetResult<event_permissionsPayload, S>

  type event_permissionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<event_permissionsFindManyArgs, 'select' | 'include'> & {
      select?: Event_permissionsCountAggregateInputType | true
    }

  export interface event_permissionsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['event_permissions'], meta: { name: 'event_permissions' } }
    /**
     * Find zero or one Event_permissions that matches the filter.
     * @param {event_permissionsFindUniqueArgs} args - Arguments to find a Event_permissions
     * @example
     * // Get one Event_permissions
     * const event_permissions = await prisma.event_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends event_permissionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, event_permissionsFindUniqueArgs<ExtArgs>>
    ): Prisma__event_permissionsClient<$Types.GetResult<event_permissionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Event_permissions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {event_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Event_permissions
     * @example
     * // Get one Event_permissions
     * const event_permissions = await prisma.event_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends event_permissionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, event_permissionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__event_permissionsClient<$Types.GetResult<event_permissionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Event_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_permissionsFindFirstArgs} args - Arguments to find a Event_permissions
     * @example
     * // Get one Event_permissions
     * const event_permissions = await prisma.event_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends event_permissionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, event_permissionsFindFirstArgs<ExtArgs>>
    ): Prisma__event_permissionsClient<$Types.GetResult<event_permissionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Event_permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_permissionsFindFirstOrThrowArgs} args - Arguments to find a Event_permissions
     * @example
     * // Get one Event_permissions
     * const event_permissions = await prisma.event_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends event_permissionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, event_permissionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__event_permissionsClient<$Types.GetResult<event_permissionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Event_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_permissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Event_permissions
     * const event_permissions = await prisma.event_permissions.findMany()
     * 
     * // Get first 10 Event_permissions
     * const event_permissions = await prisma.event_permissions.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const event_permissionsWithCreated_atOnly = await prisma.event_permissions.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends event_permissionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_permissionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<event_permissionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Event_permissions.
     * @param {event_permissionsCreateArgs} args - Arguments to create a Event_permissions.
     * @example
     * // Create one Event_permissions
     * const Event_permissions = await prisma.event_permissions.create({
     *   data: {
     *     // ... data to create a Event_permissions
     *   }
     * })
     * 
    **/
    create<T extends event_permissionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, event_permissionsCreateArgs<ExtArgs>>
    ): Prisma__event_permissionsClient<$Types.GetResult<event_permissionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Event_permissions.
     *     @param {event_permissionsCreateManyArgs} args - Arguments to create many Event_permissions.
     *     @example
     *     // Create many Event_permissions
     *     const event_permissions = await prisma.event_permissions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends event_permissionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_permissionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event_permissions.
     * @param {event_permissionsDeleteArgs} args - Arguments to delete one Event_permissions.
     * @example
     * // Delete one Event_permissions
     * const Event_permissions = await prisma.event_permissions.delete({
     *   where: {
     *     // ... filter to delete one Event_permissions
     *   }
     * })
     * 
    **/
    delete<T extends event_permissionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, event_permissionsDeleteArgs<ExtArgs>>
    ): Prisma__event_permissionsClient<$Types.GetResult<event_permissionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Event_permissions.
     * @param {event_permissionsUpdateArgs} args - Arguments to update one Event_permissions.
     * @example
     * // Update one Event_permissions
     * const event_permissions = await prisma.event_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends event_permissionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, event_permissionsUpdateArgs<ExtArgs>>
    ): Prisma__event_permissionsClient<$Types.GetResult<event_permissionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Event_permissions.
     * @param {event_permissionsDeleteManyArgs} args - Arguments to filter Event_permissions to delete.
     * @example
     * // Delete a few Event_permissions
     * const { count } = await prisma.event_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends event_permissionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_permissionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Event_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Event_permissions
     * const event_permissions = await prisma.event_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends event_permissionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, event_permissionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event_permissions.
     * @param {event_permissionsUpsertArgs} args - Arguments to update or create a Event_permissions.
     * @example
     * // Update or create a Event_permissions
     * const event_permissions = await prisma.event_permissions.upsert({
     *   create: {
     *     // ... data to create a Event_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event_permissions we want to update
     *   }
     * })
    **/
    upsert<T extends event_permissionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, event_permissionsUpsertArgs<ExtArgs>>
    ): Prisma__event_permissionsClient<$Types.GetResult<event_permissionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Event_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_permissionsCountArgs} args - Arguments to filter Event_permissions to count.
     * @example
     * // Count the number of Event_permissions
     * const count = await prisma.event_permissions.count({
     *   where: {
     *     // ... the filter for the Event_permissions we want to count
     *   }
     * })
    **/
    count<T extends event_permissionsCountArgs>(
      args?: Subset<T, event_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Event_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Event_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Event_permissionsAggregateArgs>(args: Subset<T, Event_permissionsAggregateArgs>): Prisma.PrismaPromise<GetEvent_permissionsAggregateType<T>>

    /**
     * Group by Event_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends event_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: event_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: event_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, event_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvent_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the event_permissions model
   */
  readonly fields: event_permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for event_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__event_permissionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    event_role_permissions<T extends event_permissions$event_role_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, event_permissions$event_role_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<event_role_permissionsPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the event_permissions model
   */ 
  interface event_permissionsFieldRefs {
    readonly created_at: FieldRef<"event_permissions", 'DateTime'>
    readonly updated_at: FieldRef<"event_permissions", 'DateTime'>
    readonly id: FieldRef<"event_permissions", 'Int'>
    readonly name: FieldRef<"event_permissions", 'String'>
  }
    

  // Custom InputTypes

  /**
   * event_permissions findUnique
   */
  export type event_permissionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_permissions
     */
    select?: event_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which event_permissions to fetch.
     */
    where: event_permissionsWhereUniqueInput
  }


  /**
   * event_permissions findUniqueOrThrow
   */
  export type event_permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_permissions
     */
    select?: event_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which event_permissions to fetch.
     */
    where: event_permissionsWhereUniqueInput
  }


  /**
   * event_permissions findFirst
   */
  export type event_permissionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_permissions
     */
    select?: event_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which event_permissions to fetch.
     */
    where?: event_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_permissions to fetch.
     */
    orderBy?: event_permissionsOrderByWithRelationInput | event_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_permissions.
     */
    cursor?: event_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_permissions.
     */
    distinct?: Event_permissionsScalarFieldEnum | Event_permissionsScalarFieldEnum[]
  }


  /**
   * event_permissions findFirstOrThrow
   */
  export type event_permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_permissions
     */
    select?: event_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which event_permissions to fetch.
     */
    where?: event_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_permissions to fetch.
     */
    orderBy?: event_permissionsOrderByWithRelationInput | event_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_permissions.
     */
    cursor?: event_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_permissions.
     */
    distinct?: Event_permissionsScalarFieldEnum | Event_permissionsScalarFieldEnum[]
  }


  /**
   * event_permissions findMany
   */
  export type event_permissionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_permissions
     */
    select?: event_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which event_permissions to fetch.
     */
    where?: event_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_permissions to fetch.
     */
    orderBy?: event_permissionsOrderByWithRelationInput | event_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing event_permissions.
     */
    cursor?: event_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_permissions.
     */
    skip?: number
    distinct?: Event_permissionsScalarFieldEnum | Event_permissionsScalarFieldEnum[]
  }


  /**
   * event_permissions create
   */
  export type event_permissionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_permissions
     */
    select?: event_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a event_permissions.
     */
    data: XOR<event_permissionsCreateInput, event_permissionsUncheckedCreateInput>
  }


  /**
   * event_permissions createMany
   */
  export type event_permissionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many event_permissions.
     */
    data: event_permissionsCreateManyInput | event_permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * event_permissions update
   */
  export type event_permissionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_permissions
     */
    select?: event_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a event_permissions.
     */
    data: XOR<event_permissionsUpdateInput, event_permissionsUncheckedUpdateInput>
    /**
     * Choose, which event_permissions to update.
     */
    where: event_permissionsWhereUniqueInput
  }


  /**
   * event_permissions updateMany
   */
  export type event_permissionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update event_permissions.
     */
    data: XOR<event_permissionsUpdateManyMutationInput, event_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which event_permissions to update
     */
    where?: event_permissionsWhereInput
  }


  /**
   * event_permissions upsert
   */
  export type event_permissionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_permissions
     */
    select?: event_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the event_permissions to update in case it exists.
     */
    where: event_permissionsWhereUniqueInput
    /**
     * In case the event_permissions found by the `where` argument doesn't exist, create a new event_permissions with this data.
     */
    create: XOR<event_permissionsCreateInput, event_permissionsUncheckedCreateInput>
    /**
     * In case the event_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<event_permissionsUpdateInput, event_permissionsUncheckedUpdateInput>
  }


  /**
   * event_permissions delete
   */
  export type event_permissionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_permissions
     */
    select?: event_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_permissionsInclude<ExtArgs> | null
    /**
     * Filter which event_permissions to delete.
     */
    where: event_permissionsWhereUniqueInput
  }


  /**
   * event_permissions deleteMany
   */
  export type event_permissionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which event_permissions to delete
     */
    where?: event_permissionsWhereInput
  }


  /**
   * event_permissions.event_role_permissions
   */
  export type event_permissions$event_role_permissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_role_permissions
     */
    select?: event_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_role_permissionsInclude<ExtArgs> | null
    where?: event_role_permissionsWhereInput
    orderBy?: event_role_permissionsOrderByWithRelationInput | event_role_permissionsOrderByWithRelationInput[]
    cursor?: event_role_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Event_role_permissionsScalarFieldEnum | Event_role_permissionsScalarFieldEnum[]
  }


  /**
   * event_permissions without action
   */
  export type event_permissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_permissions
     */
    select?: event_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_permissionsInclude<ExtArgs> | null
  }



  /**
   * Model event_users
   */


  export type AggregateEvent_users = {
    _count: Event_usersCountAggregateOutputType | null
    _avg: Event_usersAvgAggregateOutputType | null
    _sum: Event_usersSumAggregateOutputType | null
    _min: Event_usersMinAggregateOutputType | null
    _max: Event_usersMaxAggregateOutputType | null
  }

  export type Event_usersAvgAggregateOutputType = {
    user_id: number | null
    event_id: number | null
    event_role_id: number | null
    attendance_id: number | null
  }

  export type Event_usersSumAggregateOutputType = {
    user_id: number | null
    event_id: number | null
    event_role_id: number | null
    attendance_id: number | null
  }

  export type Event_usersMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    joined_date: Date | null
    user_id: number | null
    event_id: number | null
    event_role_id: number | null
    attendance_id: number | null
    subscribed: boolean | null
  }

  export type Event_usersMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    joined_date: Date | null
    user_id: number | null
    event_id: number | null
    event_role_id: number | null
    attendance_id: number | null
    subscribed: boolean | null
  }

  export type Event_usersCountAggregateOutputType = {
    created_at: number
    updated_at: number
    joined_date: number
    user_id: number
    event_id: number
    event_role_id: number
    attendance_id: number
    subscribed: number
    title: number
    _all: number
  }


  export type Event_usersAvgAggregateInputType = {
    user_id?: true
    event_id?: true
    event_role_id?: true
    attendance_id?: true
  }

  export type Event_usersSumAggregateInputType = {
    user_id?: true
    event_id?: true
    event_role_id?: true
    attendance_id?: true
  }

  export type Event_usersMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    joined_date?: true
    user_id?: true
    event_id?: true
    event_role_id?: true
    attendance_id?: true
    subscribed?: true
  }

  export type Event_usersMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    joined_date?: true
    user_id?: true
    event_id?: true
    event_role_id?: true
    attendance_id?: true
    subscribed?: true
  }

  export type Event_usersCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    joined_date?: true
    user_id?: true
    event_id?: true
    event_role_id?: true
    attendance_id?: true
    subscribed?: true
    title?: true
    _all?: true
  }

  export type Event_usersAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which event_users to aggregate.
     */
    where?: event_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_users to fetch.
     */
    orderBy?: event_usersOrderByWithRelationInput | event_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: event_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned event_users
    **/
    _count?: true | Event_usersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Event_usersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Event_usersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Event_usersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Event_usersMaxAggregateInputType
  }

  export type GetEvent_usersAggregateType<T extends Event_usersAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent_users]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent_users[P]>
      : GetScalarType<T[P], AggregateEvent_users[P]>
  }




  export type event_usersGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: event_usersWhereInput
    orderBy?: event_usersOrderByWithAggregationInput | event_usersOrderByWithAggregationInput[]
    by: Event_usersScalarFieldEnum[] | Event_usersScalarFieldEnum
    having?: event_usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Event_usersCountAggregateInputType | true
    _avg?: Event_usersAvgAggregateInputType
    _sum?: Event_usersSumAggregateInputType
    _min?: Event_usersMinAggregateInputType
    _max?: Event_usersMaxAggregateInputType
  }


  export type Event_usersGroupByOutputType = {
    created_at: Date
    updated_at: Date
    joined_date: Date
    user_id: number
    event_id: number
    event_role_id: number
    attendance_id: number
    subscribed: boolean
    title: string[]
    _count: Event_usersCountAggregateOutputType | null
    _avg: Event_usersAvgAggregateOutputType | null
    _sum: Event_usersSumAggregateOutputType | null
    _min: Event_usersMinAggregateOutputType | null
    _max: Event_usersMaxAggregateOutputType | null
  }

  type GetEvent_usersGroupByPayload<T extends event_usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Event_usersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Event_usersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Event_usersGroupByOutputType[P]>
            : GetScalarType<T[P], Event_usersGroupByOutputType[P]>
        }
      >
    >


  export type event_usersSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    joined_date?: boolean
    user_id?: boolean
    event_id?: boolean
    event_role_id?: boolean
    attendance_id?: boolean
    subscribed?: boolean
    title?: boolean
    user?: boolean | usersArgs<ExtArgs>
    event?: boolean | eventsArgs<ExtArgs>
    event_role?: boolean | event_rolesArgs<ExtArgs>
    attendance?: boolean | attendanceArgs<ExtArgs>
    event_reminder?: boolean | event_users$event_reminderArgs<ExtArgs>
  }, ExtArgs["result"]["event_users"]>

  export type event_usersSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    joined_date?: boolean
    user_id?: boolean
    event_id?: boolean
    event_role_id?: boolean
    attendance_id?: boolean
    subscribed?: boolean
    title?: boolean
  }

  export type event_usersInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | usersArgs<ExtArgs>
    event?: boolean | eventsArgs<ExtArgs>
    event_role?: boolean | event_rolesArgs<ExtArgs>
    attendance?: boolean | attendanceArgs<ExtArgs>
    event_reminder?: boolean | event_users$event_reminderArgs<ExtArgs>
  }


  type event_usersGetPayload<S extends boolean | null | undefined | event_usersArgs> = $Types.GetResult<event_usersPayload, S>

  type event_usersCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<event_usersFindManyArgs, 'select' | 'include'> & {
      select?: Event_usersCountAggregateInputType | true
    }

  export interface event_usersDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['event_users'], meta: { name: 'event_users' } }
    /**
     * Find zero or one Event_users that matches the filter.
     * @param {event_usersFindUniqueArgs} args - Arguments to find a Event_users
     * @example
     * // Get one Event_users
     * const event_users = await prisma.event_users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends event_usersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, event_usersFindUniqueArgs<ExtArgs>>
    ): Prisma__event_usersClient<$Types.GetResult<event_usersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Event_users that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {event_usersFindUniqueOrThrowArgs} args - Arguments to find a Event_users
     * @example
     * // Get one Event_users
     * const event_users = await prisma.event_users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends event_usersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, event_usersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__event_usersClient<$Types.GetResult<event_usersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Event_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_usersFindFirstArgs} args - Arguments to find a Event_users
     * @example
     * // Get one Event_users
     * const event_users = await prisma.event_users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends event_usersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, event_usersFindFirstArgs<ExtArgs>>
    ): Prisma__event_usersClient<$Types.GetResult<event_usersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Event_users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_usersFindFirstOrThrowArgs} args - Arguments to find a Event_users
     * @example
     * // Get one Event_users
     * const event_users = await prisma.event_users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends event_usersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, event_usersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__event_usersClient<$Types.GetResult<event_usersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Event_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Event_users
     * const event_users = await prisma.event_users.findMany()
     * 
     * // Get first 10 Event_users
     * const event_users = await prisma.event_users.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const event_usersWithCreated_atOnly = await prisma.event_users.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends event_usersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_usersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<event_usersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Event_users.
     * @param {event_usersCreateArgs} args - Arguments to create a Event_users.
     * @example
     * // Create one Event_users
     * const Event_users = await prisma.event_users.create({
     *   data: {
     *     // ... data to create a Event_users
     *   }
     * })
     * 
    **/
    create<T extends event_usersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, event_usersCreateArgs<ExtArgs>>
    ): Prisma__event_usersClient<$Types.GetResult<event_usersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Event_users.
     *     @param {event_usersCreateManyArgs} args - Arguments to create many Event_users.
     *     @example
     *     // Create many Event_users
     *     const event_users = await prisma.event_users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends event_usersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_usersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event_users.
     * @param {event_usersDeleteArgs} args - Arguments to delete one Event_users.
     * @example
     * // Delete one Event_users
     * const Event_users = await prisma.event_users.delete({
     *   where: {
     *     // ... filter to delete one Event_users
     *   }
     * })
     * 
    **/
    delete<T extends event_usersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, event_usersDeleteArgs<ExtArgs>>
    ): Prisma__event_usersClient<$Types.GetResult<event_usersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Event_users.
     * @param {event_usersUpdateArgs} args - Arguments to update one Event_users.
     * @example
     * // Update one Event_users
     * const event_users = await prisma.event_users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends event_usersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, event_usersUpdateArgs<ExtArgs>>
    ): Prisma__event_usersClient<$Types.GetResult<event_usersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Event_users.
     * @param {event_usersDeleteManyArgs} args - Arguments to filter Event_users to delete.
     * @example
     * // Delete a few Event_users
     * const { count } = await prisma.event_users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends event_usersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_usersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Event_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Event_users
     * const event_users = await prisma.event_users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends event_usersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, event_usersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event_users.
     * @param {event_usersUpsertArgs} args - Arguments to update or create a Event_users.
     * @example
     * // Update or create a Event_users
     * const event_users = await prisma.event_users.upsert({
     *   create: {
     *     // ... data to create a Event_users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event_users we want to update
     *   }
     * })
    **/
    upsert<T extends event_usersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, event_usersUpsertArgs<ExtArgs>>
    ): Prisma__event_usersClient<$Types.GetResult<event_usersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Event_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_usersCountArgs} args - Arguments to filter Event_users to count.
     * @example
     * // Count the number of Event_users
     * const count = await prisma.event_users.count({
     *   where: {
     *     // ... the filter for the Event_users we want to count
     *   }
     * })
    **/
    count<T extends event_usersCountArgs>(
      args?: Subset<T, event_usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Event_usersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Event_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Event_usersAggregateArgs>(args: Subset<T, Event_usersAggregateArgs>): Prisma.PrismaPromise<GetEvent_usersAggregateType<T>>

    /**
     * Group by Event_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends event_usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: event_usersGroupByArgs['orderBy'] }
        : { orderBy?: event_usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, event_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvent_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the event_users model
   */
  readonly fields: event_usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for event_users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__event_usersClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends usersArgs<ExtArgs> = {}>(args?: Subset<T, usersArgs<ExtArgs>>): Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    event<T extends eventsArgs<ExtArgs> = {}>(args?: Subset<T, eventsArgs<ExtArgs>>): Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    event_role<T extends event_rolesArgs<ExtArgs> = {}>(args?: Subset<T, event_rolesArgs<ExtArgs>>): Prisma__event_rolesClient<$Types.GetResult<event_rolesPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    attendance<T extends attendanceArgs<ExtArgs> = {}>(args?: Subset<T, attendanceArgs<ExtArgs>>): Prisma__attendanceClient<$Types.GetResult<attendancePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    event_reminder<T extends event_users$event_reminderArgs<ExtArgs> = {}>(args?: Subset<T, event_users$event_reminderArgs<ExtArgs>>): Prisma__event_remindersClient<$Types.GetResult<event_remindersPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the event_users model
   */ 
  interface event_usersFieldRefs {
    readonly created_at: FieldRef<"event_users", 'DateTime'>
    readonly updated_at: FieldRef<"event_users", 'DateTime'>
    readonly joined_date: FieldRef<"event_users", 'DateTime'>
    readonly user_id: FieldRef<"event_users", 'Int'>
    readonly event_id: FieldRef<"event_users", 'Int'>
    readonly event_role_id: FieldRef<"event_users", 'Int'>
    readonly attendance_id: FieldRef<"event_users", 'Int'>
    readonly subscribed: FieldRef<"event_users", 'Boolean'>
    readonly title: FieldRef<"event_users", 'String[]'>
  }
    

  // Custom InputTypes

  /**
   * event_users findUnique
   */
  export type event_usersFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_users
     */
    select?: event_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_usersInclude<ExtArgs> | null
    /**
     * Filter, which event_users to fetch.
     */
    where: event_usersWhereUniqueInput
  }


  /**
   * event_users findUniqueOrThrow
   */
  export type event_usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_users
     */
    select?: event_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_usersInclude<ExtArgs> | null
    /**
     * Filter, which event_users to fetch.
     */
    where: event_usersWhereUniqueInput
  }


  /**
   * event_users findFirst
   */
  export type event_usersFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_users
     */
    select?: event_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_usersInclude<ExtArgs> | null
    /**
     * Filter, which event_users to fetch.
     */
    where?: event_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_users to fetch.
     */
    orderBy?: event_usersOrderByWithRelationInput | event_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_users.
     */
    cursor?: event_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_users.
     */
    distinct?: Event_usersScalarFieldEnum | Event_usersScalarFieldEnum[]
  }


  /**
   * event_users findFirstOrThrow
   */
  export type event_usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_users
     */
    select?: event_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_usersInclude<ExtArgs> | null
    /**
     * Filter, which event_users to fetch.
     */
    where?: event_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_users to fetch.
     */
    orderBy?: event_usersOrderByWithRelationInput | event_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_users.
     */
    cursor?: event_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_users.
     */
    distinct?: Event_usersScalarFieldEnum | Event_usersScalarFieldEnum[]
  }


  /**
   * event_users findMany
   */
  export type event_usersFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_users
     */
    select?: event_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_usersInclude<ExtArgs> | null
    /**
     * Filter, which event_users to fetch.
     */
    where?: event_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_users to fetch.
     */
    orderBy?: event_usersOrderByWithRelationInput | event_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing event_users.
     */
    cursor?: event_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_users.
     */
    skip?: number
    distinct?: Event_usersScalarFieldEnum | Event_usersScalarFieldEnum[]
  }


  /**
   * event_users create
   */
  export type event_usersCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_users
     */
    select?: event_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_usersInclude<ExtArgs> | null
    /**
     * The data needed to create a event_users.
     */
    data: XOR<event_usersCreateInput, event_usersUncheckedCreateInput>
  }


  /**
   * event_users createMany
   */
  export type event_usersCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many event_users.
     */
    data: event_usersCreateManyInput | event_usersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * event_users update
   */
  export type event_usersUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_users
     */
    select?: event_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_usersInclude<ExtArgs> | null
    /**
     * The data needed to update a event_users.
     */
    data: XOR<event_usersUpdateInput, event_usersUncheckedUpdateInput>
    /**
     * Choose, which event_users to update.
     */
    where: event_usersWhereUniqueInput
  }


  /**
   * event_users updateMany
   */
  export type event_usersUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update event_users.
     */
    data: XOR<event_usersUpdateManyMutationInput, event_usersUncheckedUpdateManyInput>
    /**
     * Filter which event_users to update
     */
    where?: event_usersWhereInput
  }


  /**
   * event_users upsert
   */
  export type event_usersUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_users
     */
    select?: event_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_usersInclude<ExtArgs> | null
    /**
     * The filter to search for the event_users to update in case it exists.
     */
    where: event_usersWhereUniqueInput
    /**
     * In case the event_users found by the `where` argument doesn't exist, create a new event_users with this data.
     */
    create: XOR<event_usersCreateInput, event_usersUncheckedCreateInput>
    /**
     * In case the event_users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<event_usersUpdateInput, event_usersUncheckedUpdateInput>
  }


  /**
   * event_users delete
   */
  export type event_usersDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_users
     */
    select?: event_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_usersInclude<ExtArgs> | null
    /**
     * Filter which event_users to delete.
     */
    where: event_usersWhereUniqueInput
  }


  /**
   * event_users deleteMany
   */
  export type event_usersDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which event_users to delete
     */
    where?: event_usersWhereInput
  }


  /**
   * event_users.event_reminder
   */
  export type event_users$event_reminderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_reminders
     */
    select?: event_remindersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_remindersInclude<ExtArgs> | null
    where?: event_remindersWhereInput
  }


  /**
   * event_users without action
   */
  export type event_usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_users
     */
    select?: event_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_usersInclude<ExtArgs> | null
  }



  /**
   * Model event_reminders
   */


  export type AggregateEvent_reminders = {
    _count: Event_remindersCountAggregateOutputType | null
    _avg: Event_remindersAvgAggregateOutputType | null
    _sum: Event_remindersSumAggregateOutputType | null
    _min: Event_remindersMinAggregateOutputType | null
    _max: Event_remindersMaxAggregateOutputType | null
  }

  export type Event_remindersAvgAggregateOutputType = {
    user_id: number | null
    event_id: number | null
  }

  export type Event_remindersSumAggregateOutputType = {
    user_id: number | null
    event_id: number | null
  }

  export type Event_remindersMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    user_id: number | null
    event_id: number | null
    remind_at: Date | null
    notifying: boolean | null
  }

  export type Event_remindersMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    user_id: number | null
    event_id: number | null
    remind_at: Date | null
    notifying: boolean | null
  }

  export type Event_remindersCountAggregateOutputType = {
    created_at: number
    updated_at: number
    user_id: number
    event_id: number
    remind_at: number
    notifying: number
    _all: number
  }


  export type Event_remindersAvgAggregateInputType = {
    user_id?: true
    event_id?: true
  }

  export type Event_remindersSumAggregateInputType = {
    user_id?: true
    event_id?: true
  }

  export type Event_remindersMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    user_id?: true
    event_id?: true
    remind_at?: true
    notifying?: true
  }

  export type Event_remindersMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    user_id?: true
    event_id?: true
    remind_at?: true
    notifying?: true
  }

  export type Event_remindersCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    user_id?: true
    event_id?: true
    remind_at?: true
    notifying?: true
    _all?: true
  }

  export type Event_remindersAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which event_reminders to aggregate.
     */
    where?: event_remindersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_reminders to fetch.
     */
    orderBy?: event_remindersOrderByWithRelationInput | event_remindersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: event_remindersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_reminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned event_reminders
    **/
    _count?: true | Event_remindersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Event_remindersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Event_remindersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Event_remindersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Event_remindersMaxAggregateInputType
  }

  export type GetEvent_remindersAggregateType<T extends Event_remindersAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent_reminders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent_reminders[P]>
      : GetScalarType<T[P], AggregateEvent_reminders[P]>
  }




  export type event_remindersGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: event_remindersWhereInput
    orderBy?: event_remindersOrderByWithAggregationInput | event_remindersOrderByWithAggregationInput[]
    by: Event_remindersScalarFieldEnum[] | Event_remindersScalarFieldEnum
    having?: event_remindersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Event_remindersCountAggregateInputType | true
    _avg?: Event_remindersAvgAggregateInputType
    _sum?: Event_remindersSumAggregateInputType
    _min?: Event_remindersMinAggregateInputType
    _max?: Event_remindersMaxAggregateInputType
  }


  export type Event_remindersGroupByOutputType = {
    created_at: Date
    updated_at: Date
    user_id: number
    event_id: number
    remind_at: Date
    notifying: boolean
    _count: Event_remindersCountAggregateOutputType | null
    _avg: Event_remindersAvgAggregateOutputType | null
    _sum: Event_remindersSumAggregateOutputType | null
    _min: Event_remindersMinAggregateOutputType | null
    _max: Event_remindersMaxAggregateOutputType | null
  }

  type GetEvent_remindersGroupByPayload<T extends event_remindersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Event_remindersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Event_remindersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Event_remindersGroupByOutputType[P]>
            : GetScalarType<T[P], Event_remindersGroupByOutputType[P]>
        }
      >
    >


  export type event_remindersSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    event_id?: boolean
    remind_at?: boolean
    notifying?: boolean
    event_user?: boolean | event_usersArgs<ExtArgs>
  }, ExtArgs["result"]["event_reminders"]>

  export type event_remindersSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    event_id?: boolean
    remind_at?: boolean
    notifying?: boolean
  }

  export type event_remindersInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    event_user?: boolean | event_usersArgs<ExtArgs>
  }


  type event_remindersGetPayload<S extends boolean | null | undefined | event_remindersArgs> = $Types.GetResult<event_remindersPayload, S>

  type event_remindersCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<event_remindersFindManyArgs, 'select' | 'include'> & {
      select?: Event_remindersCountAggregateInputType | true
    }

  export interface event_remindersDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['event_reminders'], meta: { name: 'event_reminders' } }
    /**
     * Find zero or one Event_reminders that matches the filter.
     * @param {event_remindersFindUniqueArgs} args - Arguments to find a Event_reminders
     * @example
     * // Get one Event_reminders
     * const event_reminders = await prisma.event_reminders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends event_remindersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, event_remindersFindUniqueArgs<ExtArgs>>
    ): Prisma__event_remindersClient<$Types.GetResult<event_remindersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Event_reminders that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {event_remindersFindUniqueOrThrowArgs} args - Arguments to find a Event_reminders
     * @example
     * // Get one Event_reminders
     * const event_reminders = await prisma.event_reminders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends event_remindersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, event_remindersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__event_remindersClient<$Types.GetResult<event_remindersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Event_reminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_remindersFindFirstArgs} args - Arguments to find a Event_reminders
     * @example
     * // Get one Event_reminders
     * const event_reminders = await prisma.event_reminders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends event_remindersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, event_remindersFindFirstArgs<ExtArgs>>
    ): Prisma__event_remindersClient<$Types.GetResult<event_remindersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Event_reminders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_remindersFindFirstOrThrowArgs} args - Arguments to find a Event_reminders
     * @example
     * // Get one Event_reminders
     * const event_reminders = await prisma.event_reminders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends event_remindersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, event_remindersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__event_remindersClient<$Types.GetResult<event_remindersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Event_reminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_remindersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Event_reminders
     * const event_reminders = await prisma.event_reminders.findMany()
     * 
     * // Get first 10 Event_reminders
     * const event_reminders = await prisma.event_reminders.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const event_remindersWithCreated_atOnly = await prisma.event_reminders.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends event_remindersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_remindersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<event_remindersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Event_reminders.
     * @param {event_remindersCreateArgs} args - Arguments to create a Event_reminders.
     * @example
     * // Create one Event_reminders
     * const Event_reminders = await prisma.event_reminders.create({
     *   data: {
     *     // ... data to create a Event_reminders
     *   }
     * })
     * 
    **/
    create<T extends event_remindersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, event_remindersCreateArgs<ExtArgs>>
    ): Prisma__event_remindersClient<$Types.GetResult<event_remindersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Event_reminders.
     *     @param {event_remindersCreateManyArgs} args - Arguments to create many Event_reminders.
     *     @example
     *     // Create many Event_reminders
     *     const event_reminders = await prisma.event_reminders.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends event_remindersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_remindersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event_reminders.
     * @param {event_remindersDeleteArgs} args - Arguments to delete one Event_reminders.
     * @example
     * // Delete one Event_reminders
     * const Event_reminders = await prisma.event_reminders.delete({
     *   where: {
     *     // ... filter to delete one Event_reminders
     *   }
     * })
     * 
    **/
    delete<T extends event_remindersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, event_remindersDeleteArgs<ExtArgs>>
    ): Prisma__event_remindersClient<$Types.GetResult<event_remindersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Event_reminders.
     * @param {event_remindersUpdateArgs} args - Arguments to update one Event_reminders.
     * @example
     * // Update one Event_reminders
     * const event_reminders = await prisma.event_reminders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends event_remindersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, event_remindersUpdateArgs<ExtArgs>>
    ): Prisma__event_remindersClient<$Types.GetResult<event_remindersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Event_reminders.
     * @param {event_remindersDeleteManyArgs} args - Arguments to filter Event_reminders to delete.
     * @example
     * // Delete a few Event_reminders
     * const { count } = await prisma.event_reminders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends event_remindersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, event_remindersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Event_reminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_remindersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Event_reminders
     * const event_reminders = await prisma.event_reminders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends event_remindersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, event_remindersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event_reminders.
     * @param {event_remindersUpsertArgs} args - Arguments to update or create a Event_reminders.
     * @example
     * // Update or create a Event_reminders
     * const event_reminders = await prisma.event_reminders.upsert({
     *   create: {
     *     // ... data to create a Event_reminders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event_reminders we want to update
     *   }
     * })
    **/
    upsert<T extends event_remindersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, event_remindersUpsertArgs<ExtArgs>>
    ): Prisma__event_remindersClient<$Types.GetResult<event_remindersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Event_reminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_remindersCountArgs} args - Arguments to filter Event_reminders to count.
     * @example
     * // Count the number of Event_reminders
     * const count = await prisma.event_reminders.count({
     *   where: {
     *     // ... the filter for the Event_reminders we want to count
     *   }
     * })
    **/
    count<T extends event_remindersCountArgs>(
      args?: Subset<T, event_remindersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Event_remindersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event_reminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Event_remindersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Event_remindersAggregateArgs>(args: Subset<T, Event_remindersAggregateArgs>): Prisma.PrismaPromise<GetEvent_remindersAggregateType<T>>

    /**
     * Group by Event_reminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_remindersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends event_remindersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: event_remindersGroupByArgs['orderBy'] }
        : { orderBy?: event_remindersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, event_remindersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvent_remindersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the event_reminders model
   */
  readonly fields: event_remindersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for event_reminders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__event_remindersClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    event_user<T extends event_usersArgs<ExtArgs> = {}>(args?: Subset<T, event_usersArgs<ExtArgs>>): Prisma__event_usersClient<$Types.GetResult<event_usersPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the event_reminders model
   */ 
  interface event_remindersFieldRefs {
    readonly created_at: FieldRef<"event_reminders", 'DateTime'>
    readonly updated_at: FieldRef<"event_reminders", 'DateTime'>
    readonly user_id: FieldRef<"event_reminders", 'Int'>
    readonly event_id: FieldRef<"event_reminders", 'Int'>
    readonly remind_at: FieldRef<"event_reminders", 'DateTime'>
    readonly notifying: FieldRef<"event_reminders", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * event_reminders findUnique
   */
  export type event_remindersFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_reminders
     */
    select?: event_remindersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_remindersInclude<ExtArgs> | null
    /**
     * Filter, which event_reminders to fetch.
     */
    where: event_remindersWhereUniqueInput
  }


  /**
   * event_reminders findUniqueOrThrow
   */
  export type event_remindersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_reminders
     */
    select?: event_remindersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_remindersInclude<ExtArgs> | null
    /**
     * Filter, which event_reminders to fetch.
     */
    where: event_remindersWhereUniqueInput
  }


  /**
   * event_reminders findFirst
   */
  export type event_remindersFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_reminders
     */
    select?: event_remindersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_remindersInclude<ExtArgs> | null
    /**
     * Filter, which event_reminders to fetch.
     */
    where?: event_remindersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_reminders to fetch.
     */
    orderBy?: event_remindersOrderByWithRelationInput | event_remindersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_reminders.
     */
    cursor?: event_remindersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_reminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_reminders.
     */
    distinct?: Event_remindersScalarFieldEnum | Event_remindersScalarFieldEnum[]
  }


  /**
   * event_reminders findFirstOrThrow
   */
  export type event_remindersFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_reminders
     */
    select?: event_remindersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_remindersInclude<ExtArgs> | null
    /**
     * Filter, which event_reminders to fetch.
     */
    where?: event_remindersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_reminders to fetch.
     */
    orderBy?: event_remindersOrderByWithRelationInput | event_remindersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_reminders.
     */
    cursor?: event_remindersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_reminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_reminders.
     */
    distinct?: Event_remindersScalarFieldEnum | Event_remindersScalarFieldEnum[]
  }


  /**
   * event_reminders findMany
   */
  export type event_remindersFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_reminders
     */
    select?: event_remindersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_remindersInclude<ExtArgs> | null
    /**
     * Filter, which event_reminders to fetch.
     */
    where?: event_remindersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_reminders to fetch.
     */
    orderBy?: event_remindersOrderByWithRelationInput | event_remindersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing event_reminders.
     */
    cursor?: event_remindersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_reminders.
     */
    skip?: number
    distinct?: Event_remindersScalarFieldEnum | Event_remindersScalarFieldEnum[]
  }


  /**
   * event_reminders create
   */
  export type event_remindersCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_reminders
     */
    select?: event_remindersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_remindersInclude<ExtArgs> | null
    /**
     * The data needed to create a event_reminders.
     */
    data: XOR<event_remindersCreateInput, event_remindersUncheckedCreateInput>
  }


  /**
   * event_reminders createMany
   */
  export type event_remindersCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many event_reminders.
     */
    data: event_remindersCreateManyInput | event_remindersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * event_reminders update
   */
  export type event_remindersUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_reminders
     */
    select?: event_remindersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_remindersInclude<ExtArgs> | null
    /**
     * The data needed to update a event_reminders.
     */
    data: XOR<event_remindersUpdateInput, event_remindersUncheckedUpdateInput>
    /**
     * Choose, which event_reminders to update.
     */
    where: event_remindersWhereUniqueInput
  }


  /**
   * event_reminders updateMany
   */
  export type event_remindersUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update event_reminders.
     */
    data: XOR<event_remindersUpdateManyMutationInput, event_remindersUncheckedUpdateManyInput>
    /**
     * Filter which event_reminders to update
     */
    where?: event_remindersWhereInput
  }


  /**
   * event_reminders upsert
   */
  export type event_remindersUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_reminders
     */
    select?: event_remindersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_remindersInclude<ExtArgs> | null
    /**
     * The filter to search for the event_reminders to update in case it exists.
     */
    where: event_remindersWhereUniqueInput
    /**
     * In case the event_reminders found by the `where` argument doesn't exist, create a new event_reminders with this data.
     */
    create: XOR<event_remindersCreateInput, event_remindersUncheckedCreateInput>
    /**
     * In case the event_reminders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<event_remindersUpdateInput, event_remindersUncheckedUpdateInput>
  }


  /**
   * event_reminders delete
   */
  export type event_remindersDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_reminders
     */
    select?: event_remindersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_remindersInclude<ExtArgs> | null
    /**
     * Filter which event_reminders to delete.
     */
    where: event_remindersWhereUniqueInput
  }


  /**
   * event_reminders deleteMany
   */
  export type event_remindersDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which event_reminders to delete
     */
    where?: event_remindersWhereInput
  }


  /**
   * event_reminders without action
   */
  export type event_remindersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_reminders
     */
    select?: event_remindersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_remindersInclude<ExtArgs> | null
  }



  /**
   * Model attendance
   */


  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceAvgAggregateOutputType = {
    id: number | null
  }

  export type AttendanceSumAggregateOutputType = {
    id: number | null
  }

  export type AttendanceMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
  }

  export type AttendanceMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
  }

  export type AttendanceCountAggregateOutputType = {
    created_at: number
    updated_at: number
    id: number
    name: number
    _all: number
  }


  export type AttendanceAvgAggregateInputType = {
    id?: true
  }

  export type AttendanceSumAggregateInputType = {
    id?: true
  }

  export type AttendanceMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
  }

  export type AttendanceMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
  }

  export type AttendanceCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendance to aggregate.
     */
    where?: attendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendanceOrderByWithRelationInput | attendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: attendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type attendanceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: attendanceWhereInput
    orderBy?: attendanceOrderByWithAggregationInput | attendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: attendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _avg?: AttendanceAvgAggregateInputType
    _sum?: AttendanceSumAggregateInputType
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }


  export type AttendanceGroupByOutputType = {
    created_at: Date
    updated_at: Date
    id: number
    name: string
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends attendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type attendanceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
    event_users?: boolean | attendance$event_usersArgs<ExtArgs>
    _count?: boolean | AttendanceCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type attendanceSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
  }

  export type attendanceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    event_users?: boolean | attendance$event_usersArgs<ExtArgs>
    _count?: boolean | AttendanceCountOutputTypeArgs<ExtArgs>
  }


  type attendanceGetPayload<S extends boolean | null | undefined | attendanceArgs> = $Types.GetResult<attendancePayload, S>

  type attendanceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<attendanceFindManyArgs, 'select' | 'include'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface attendanceDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['attendance'], meta: { name: 'attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {attendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends attendanceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, attendanceFindUniqueArgs<ExtArgs>>
    ): Prisma__attendanceClient<$Types.GetResult<attendancePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Attendance that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {attendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends attendanceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, attendanceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__attendanceClient<$Types.GetResult<attendancePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends attendanceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, attendanceFindFirstArgs<ExtArgs>>
    ): Prisma__attendanceClient<$Types.GetResult<attendancePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends attendanceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, attendanceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__attendanceClient<$Types.GetResult<attendancePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendanceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const attendanceWithCreated_atOnly = await prisma.attendance.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends attendanceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, attendanceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<attendancePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Attendance.
     * @param {attendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
    **/
    create<T extends attendanceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, attendanceCreateArgs<ExtArgs>>
    ): Prisma__attendanceClient<$Types.GetResult<attendancePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Attendances.
     *     @param {attendanceCreateManyArgs} args - Arguments to create many Attendances.
     *     @example
     *     // Create many Attendances
     *     const attendance = await prisma.attendance.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends attendanceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, attendanceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attendance.
     * @param {attendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
    **/
    delete<T extends attendanceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, attendanceDeleteArgs<ExtArgs>>
    ): Prisma__attendanceClient<$Types.GetResult<attendancePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Attendance.
     * @param {attendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends attendanceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, attendanceUpdateArgs<ExtArgs>>
    ): Prisma__attendanceClient<$Types.GetResult<attendancePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Attendances.
     * @param {attendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends attendanceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, attendanceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends attendanceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, attendanceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendance.
     * @param {attendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
    **/
    upsert<T extends attendanceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, attendanceUpsertArgs<ExtArgs>>
    ): Prisma__attendanceClient<$Types.GetResult<attendancePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends attendanceCountArgs>(
      args?: Subset<T, attendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends attendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: attendanceGroupByArgs['orderBy'] }
        : { orderBy?: attendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, attendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the attendance model
   */
  readonly fields: attendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__attendanceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    event_users<T extends attendance$event_usersArgs<ExtArgs> = {}>(args?: Subset<T, attendance$event_usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<event_usersPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the attendance model
   */ 
  interface attendanceFieldRefs {
    readonly created_at: FieldRef<"attendance", 'DateTime'>
    readonly updated_at: FieldRef<"attendance", 'DateTime'>
    readonly id: FieldRef<"attendance", 'Int'>
    readonly name: FieldRef<"attendance", 'String'>
  }
    

  // Custom InputTypes

  /**
   * attendance findUnique
   */
  export type attendanceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * Filter, which attendance to fetch.
     */
    where: attendanceWhereUniqueInput
  }


  /**
   * attendance findUniqueOrThrow
   */
  export type attendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * Filter, which attendance to fetch.
     */
    where: attendanceWhereUniqueInput
  }


  /**
   * attendance findFirst
   */
  export type attendanceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * Filter, which attendance to fetch.
     */
    where?: attendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendanceOrderByWithRelationInput | attendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendances.
     */
    cursor?: attendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }


  /**
   * attendance findFirstOrThrow
   */
  export type attendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * Filter, which attendance to fetch.
     */
    where?: attendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendanceOrderByWithRelationInput | attendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendances.
     */
    cursor?: attendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }


  /**
   * attendance findMany
   */
  export type attendanceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * Filter, which attendances to fetch.
     */
    where?: attendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendanceOrderByWithRelationInput | attendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attendances.
     */
    cursor?: attendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }


  /**
   * attendance create
   */
  export type attendanceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a attendance.
     */
    data: XOR<attendanceCreateInput, attendanceUncheckedCreateInput>
  }


  /**
   * attendance createMany
   */
  export type attendanceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many attendances.
     */
    data: attendanceCreateManyInput | attendanceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * attendance update
   */
  export type attendanceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a attendance.
     */
    data: XOR<attendanceUpdateInput, attendanceUncheckedUpdateInput>
    /**
     * Choose, which attendance to update.
     */
    where: attendanceWhereUniqueInput
  }


  /**
   * attendance updateMany
   */
  export type attendanceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update attendances.
     */
    data: XOR<attendanceUpdateManyMutationInput, attendanceUncheckedUpdateManyInput>
    /**
     * Filter which attendances to update
     */
    where?: attendanceWhereInput
  }


  /**
   * attendance upsert
   */
  export type attendanceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the attendance to update in case it exists.
     */
    where: attendanceWhereUniqueInput
    /**
     * In case the attendance found by the `where` argument doesn't exist, create a new attendance with this data.
     */
    create: XOR<attendanceCreateInput, attendanceUncheckedCreateInput>
    /**
     * In case the attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<attendanceUpdateInput, attendanceUncheckedUpdateInput>
  }


  /**
   * attendance delete
   */
  export type attendanceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * Filter which attendance to delete.
     */
    where: attendanceWhereUniqueInput
  }


  /**
   * attendance deleteMany
   */
  export type attendanceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendances to delete
     */
    where?: attendanceWhereInput
  }


  /**
   * attendance.event_users
   */
  export type attendance$event_usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_users
     */
    select?: event_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_usersInclude<ExtArgs> | null
    where?: event_usersWhereInput
    orderBy?: event_usersOrderByWithRelationInput | event_usersOrderByWithRelationInput[]
    cursor?: event_usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Event_usersScalarFieldEnum | Event_usersScalarFieldEnum[]
  }


  /**
   * attendance without action
   */
  export type attendanceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: attendanceInclude<ExtArgs> | null
  }



  /**
   * Model sponsors
   */


  export type AggregateSponsors = {
    _count: SponsorsCountAggregateOutputType | null
    _avg: SponsorsAvgAggregateOutputType | null
    _sum: SponsorsSumAggregateOutputType | null
    _min: SponsorsMinAggregateOutputType | null
    _max: SponsorsMaxAggregateOutputType | null
  }

  export type SponsorsAvgAggregateOutputType = {
    id: number | null
  }

  export type SponsorsSumAggregateOutputType = {
    id: number | null
  }

  export type SponsorsMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
    website: string | null
    logo_path: string | null
    type: string | null
  }

  export type SponsorsMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
    website: string | null
    logo_path: string | null
    type: string | null
  }

  export type SponsorsCountAggregateOutputType = {
    created_at: number
    updated_at: number
    id: number
    name: number
    website: number
    logo_path: number
    type: number
    _all: number
  }


  export type SponsorsAvgAggregateInputType = {
    id?: true
  }

  export type SponsorsSumAggregateInputType = {
    id?: true
  }

  export type SponsorsMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    website?: true
    logo_path?: true
    type?: true
  }

  export type SponsorsMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    website?: true
    logo_path?: true
    type?: true
  }

  export type SponsorsCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    website?: true
    logo_path?: true
    type?: true
    _all?: true
  }

  export type SponsorsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which sponsors to aggregate.
     */
    where?: sponsorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sponsors to fetch.
     */
    orderBy?: sponsorsOrderByWithRelationInput | sponsorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sponsorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sponsors
    **/
    _count?: true | SponsorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SponsorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SponsorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SponsorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SponsorsMaxAggregateInputType
  }

  export type GetSponsorsAggregateType<T extends SponsorsAggregateArgs> = {
        [P in keyof T & keyof AggregateSponsors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSponsors[P]>
      : GetScalarType<T[P], AggregateSponsors[P]>
  }




  export type sponsorsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: sponsorsWhereInput
    orderBy?: sponsorsOrderByWithAggregationInput | sponsorsOrderByWithAggregationInput[]
    by: SponsorsScalarFieldEnum[] | SponsorsScalarFieldEnum
    having?: sponsorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SponsorsCountAggregateInputType | true
    _avg?: SponsorsAvgAggregateInputType
    _sum?: SponsorsSumAggregateInputType
    _min?: SponsorsMinAggregateInputType
    _max?: SponsorsMaxAggregateInputType
  }


  export type SponsorsGroupByOutputType = {
    created_at: Date
    updated_at: Date
    id: number
    name: string
    website: string
    logo_path: string
    type: string
    _count: SponsorsCountAggregateOutputType | null
    _avg: SponsorsAvgAggregateOutputType | null
    _sum: SponsorsSumAggregateOutputType | null
    _min: SponsorsMinAggregateOutputType | null
    _max: SponsorsMaxAggregateOutputType | null
  }

  type GetSponsorsGroupByPayload<T extends sponsorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SponsorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SponsorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SponsorsGroupByOutputType[P]>
            : GetScalarType<T[P], SponsorsGroupByOutputType[P]>
        }
      >
    >


  export type sponsorsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
    website?: boolean
    logo_path?: boolean
    type?: boolean
    event_sponsors?: boolean | sponsors$event_sponsorsArgs<ExtArgs>
    _count?: boolean | SponsorsCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["sponsors"]>

  export type sponsorsSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
    website?: boolean
    logo_path?: boolean
    type?: boolean
  }

  export type sponsorsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    event_sponsors?: boolean | sponsors$event_sponsorsArgs<ExtArgs>
    _count?: boolean | SponsorsCountOutputTypeArgs<ExtArgs>
  }


  type sponsorsGetPayload<S extends boolean | null | undefined | sponsorsArgs> = $Types.GetResult<sponsorsPayload, S>

  type sponsorsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<sponsorsFindManyArgs, 'select' | 'include'> & {
      select?: SponsorsCountAggregateInputType | true
    }

  export interface sponsorsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sponsors'], meta: { name: 'sponsors' } }
    /**
     * Find zero or one Sponsors that matches the filter.
     * @param {sponsorsFindUniqueArgs} args - Arguments to find a Sponsors
     * @example
     * // Get one Sponsors
     * const sponsors = await prisma.sponsors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sponsorsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, sponsorsFindUniqueArgs<ExtArgs>>
    ): Prisma__sponsorsClient<$Types.GetResult<sponsorsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sponsors that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sponsorsFindUniqueOrThrowArgs} args - Arguments to find a Sponsors
     * @example
     * // Get one Sponsors
     * const sponsors = await prisma.sponsors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sponsorsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sponsorsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__sponsorsClient<$Types.GetResult<sponsorsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sponsors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sponsorsFindFirstArgs} args - Arguments to find a Sponsors
     * @example
     * // Get one Sponsors
     * const sponsors = await prisma.sponsors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sponsorsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, sponsorsFindFirstArgs<ExtArgs>>
    ): Prisma__sponsorsClient<$Types.GetResult<sponsorsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sponsors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sponsorsFindFirstOrThrowArgs} args - Arguments to find a Sponsors
     * @example
     * // Get one Sponsors
     * const sponsors = await prisma.sponsors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sponsorsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sponsorsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__sponsorsClient<$Types.GetResult<sponsorsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sponsors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sponsorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sponsors
     * const sponsors = await prisma.sponsors.findMany()
     * 
     * // Get first 10 Sponsors
     * const sponsors = await prisma.sponsors.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const sponsorsWithCreated_atOnly = await prisma.sponsors.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends sponsorsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sponsorsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<sponsorsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sponsors.
     * @param {sponsorsCreateArgs} args - Arguments to create a Sponsors.
     * @example
     * // Create one Sponsors
     * const Sponsors = await prisma.sponsors.create({
     *   data: {
     *     // ... data to create a Sponsors
     *   }
     * })
     * 
    **/
    create<T extends sponsorsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, sponsorsCreateArgs<ExtArgs>>
    ): Prisma__sponsorsClient<$Types.GetResult<sponsorsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sponsors.
     *     @param {sponsorsCreateManyArgs} args - Arguments to create many Sponsors.
     *     @example
     *     // Create many Sponsors
     *     const sponsors = await prisma.sponsors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sponsorsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sponsorsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sponsors.
     * @param {sponsorsDeleteArgs} args - Arguments to delete one Sponsors.
     * @example
     * // Delete one Sponsors
     * const Sponsors = await prisma.sponsors.delete({
     *   where: {
     *     // ... filter to delete one Sponsors
     *   }
     * })
     * 
    **/
    delete<T extends sponsorsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, sponsorsDeleteArgs<ExtArgs>>
    ): Prisma__sponsorsClient<$Types.GetResult<sponsorsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sponsors.
     * @param {sponsorsUpdateArgs} args - Arguments to update one Sponsors.
     * @example
     * // Update one Sponsors
     * const sponsors = await prisma.sponsors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sponsorsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, sponsorsUpdateArgs<ExtArgs>>
    ): Prisma__sponsorsClient<$Types.GetResult<sponsorsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sponsors.
     * @param {sponsorsDeleteManyArgs} args - Arguments to filter Sponsors to delete.
     * @example
     * // Delete a few Sponsors
     * const { count } = await prisma.sponsors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sponsorsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sponsorsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sponsorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sponsors
     * const sponsors = await prisma.sponsors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sponsorsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, sponsorsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sponsors.
     * @param {sponsorsUpsertArgs} args - Arguments to update or create a Sponsors.
     * @example
     * // Update or create a Sponsors
     * const sponsors = await prisma.sponsors.upsert({
     *   create: {
     *     // ... data to create a Sponsors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sponsors we want to update
     *   }
     * })
    **/
    upsert<T extends sponsorsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, sponsorsUpsertArgs<ExtArgs>>
    ): Prisma__sponsorsClient<$Types.GetResult<sponsorsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sponsorsCountArgs} args - Arguments to filter Sponsors to count.
     * @example
     * // Count the number of Sponsors
     * const count = await prisma.sponsors.count({
     *   where: {
     *     // ... the filter for the Sponsors we want to count
     *   }
     * })
    **/
    count<T extends sponsorsCountArgs>(
      args?: Subset<T, sponsorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SponsorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SponsorsAggregateArgs>(args: Subset<T, SponsorsAggregateArgs>): Prisma.PrismaPromise<GetSponsorsAggregateType<T>>

    /**
     * Group by Sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sponsorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sponsorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sponsorsGroupByArgs['orderBy'] }
        : { orderBy?: sponsorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sponsorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSponsorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sponsors model
   */
  readonly fields: sponsorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sponsors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sponsorsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    event_sponsors<T extends sponsors$event_sponsorsArgs<ExtArgs> = {}>(args?: Subset<T, sponsors$event_sponsorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<event_sponsorsPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the sponsors model
   */ 
  interface sponsorsFieldRefs {
    readonly created_at: FieldRef<"sponsors", 'DateTime'>
    readonly updated_at: FieldRef<"sponsors", 'DateTime'>
    readonly id: FieldRef<"sponsors", 'Int'>
    readonly name: FieldRef<"sponsors", 'String'>
    readonly website: FieldRef<"sponsors", 'String'>
    readonly logo_path: FieldRef<"sponsors", 'String'>
    readonly type: FieldRef<"sponsors", 'String'>
  }
    

  // Custom InputTypes

  /**
   * sponsors findUnique
   */
  export type sponsorsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sponsors
     */
    select?: sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sponsorsInclude<ExtArgs> | null
    /**
     * Filter, which sponsors to fetch.
     */
    where: sponsorsWhereUniqueInput
  }


  /**
   * sponsors findUniqueOrThrow
   */
  export type sponsorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sponsors
     */
    select?: sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sponsorsInclude<ExtArgs> | null
    /**
     * Filter, which sponsors to fetch.
     */
    where: sponsorsWhereUniqueInput
  }


  /**
   * sponsors findFirst
   */
  export type sponsorsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sponsors
     */
    select?: sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sponsorsInclude<ExtArgs> | null
    /**
     * Filter, which sponsors to fetch.
     */
    where?: sponsorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sponsors to fetch.
     */
    orderBy?: sponsorsOrderByWithRelationInput | sponsorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sponsors.
     */
    cursor?: sponsorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sponsors.
     */
    distinct?: SponsorsScalarFieldEnum | SponsorsScalarFieldEnum[]
  }


  /**
   * sponsors findFirstOrThrow
   */
  export type sponsorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sponsors
     */
    select?: sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sponsorsInclude<ExtArgs> | null
    /**
     * Filter, which sponsors to fetch.
     */
    where?: sponsorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sponsors to fetch.
     */
    orderBy?: sponsorsOrderByWithRelationInput | sponsorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sponsors.
     */
    cursor?: sponsorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sponsors.
     */
    distinct?: SponsorsScalarFieldEnum | SponsorsScalarFieldEnum[]
  }


  /**
   * sponsors findMany
   */
  export type sponsorsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sponsors
     */
    select?: sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sponsorsInclude<ExtArgs> | null
    /**
     * Filter, which sponsors to fetch.
     */
    where?: sponsorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sponsors to fetch.
     */
    orderBy?: sponsorsOrderByWithRelationInput | sponsorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sponsors.
     */
    cursor?: sponsorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sponsors.
     */
    skip?: number
    distinct?: SponsorsScalarFieldEnum | SponsorsScalarFieldEnum[]
  }


  /**
   * sponsors create
   */
  export type sponsorsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sponsors
     */
    select?: sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sponsorsInclude<ExtArgs> | null
    /**
     * The data needed to create a sponsors.
     */
    data: XOR<sponsorsCreateInput, sponsorsUncheckedCreateInput>
  }


  /**
   * sponsors createMany
   */
  export type sponsorsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sponsors.
     */
    data: sponsorsCreateManyInput | sponsorsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * sponsors update
   */
  export type sponsorsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sponsors
     */
    select?: sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sponsorsInclude<ExtArgs> | null
    /**
     * The data needed to update a sponsors.
     */
    data: XOR<sponsorsUpdateInput, sponsorsUncheckedUpdateInput>
    /**
     * Choose, which sponsors to update.
     */
    where: sponsorsWhereUniqueInput
  }


  /**
   * sponsors updateMany
   */
  export type sponsorsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sponsors.
     */
    data: XOR<sponsorsUpdateManyMutationInput, sponsorsUncheckedUpdateManyInput>
    /**
     * Filter which sponsors to update
     */
    where?: sponsorsWhereInput
  }


  /**
   * sponsors upsert
   */
  export type sponsorsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sponsors
     */
    select?: sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sponsorsInclude<ExtArgs> | null
    /**
     * The filter to search for the sponsors to update in case it exists.
     */
    where: sponsorsWhereUniqueInput
    /**
     * In case the sponsors found by the `where` argument doesn't exist, create a new sponsors with this data.
     */
    create: XOR<sponsorsCreateInput, sponsorsUncheckedCreateInput>
    /**
     * In case the sponsors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sponsorsUpdateInput, sponsorsUncheckedUpdateInput>
  }


  /**
   * sponsors delete
   */
  export type sponsorsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sponsors
     */
    select?: sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sponsorsInclude<ExtArgs> | null
    /**
     * Filter which sponsors to delete.
     */
    where: sponsorsWhereUniqueInput
  }


  /**
   * sponsors deleteMany
   */
  export type sponsorsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which sponsors to delete
     */
    where?: sponsorsWhereInput
  }


  /**
   * sponsors.event_sponsors
   */
  export type sponsors$event_sponsorsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_sponsors
     */
    select?: event_sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_sponsorsInclude<ExtArgs> | null
    where?: event_sponsorsWhereInput
    orderBy?: event_sponsorsOrderByWithRelationInput | event_sponsorsOrderByWithRelationInput[]
    cursor?: event_sponsorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Event_sponsorsScalarFieldEnum | Event_sponsorsScalarFieldEnum[]
  }


  /**
   * sponsors without action
   */
  export type sponsorsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sponsors
     */
    select?: sponsorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sponsorsInclude<ExtArgs> | null
  }



  /**
   * Model tags
   */


  export type AggregateTags = {
    _count: TagsCountAggregateOutputType | null
    _avg: TagsAvgAggregateOutputType | null
    _sum: TagsSumAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  export type TagsAvgAggregateOutputType = {
    id: number | null
  }

  export type TagsSumAggregateOutputType = {
    id: number | null
  }

  export type TagsMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
  }

  export type TagsMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
  }

  export type TagsCountAggregateOutputType = {
    created_at: number
    updated_at: number
    id: number
    name: number
    _all: number
  }


  export type TagsAvgAggregateInputType = {
    id?: true
  }

  export type TagsSumAggregateInputType = {
    id?: true
  }

  export type TagsMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
  }

  export type TagsMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
  }

  export type TagsCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    _all?: true
  }

  export type TagsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tags to aggregate.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tags
    **/
    _count?: true | TagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagsMaxAggregateInputType
  }

  export type GetTagsAggregateType<T extends TagsAggregateArgs> = {
        [P in keyof T & keyof AggregateTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTags[P]>
      : GetScalarType<T[P], AggregateTags[P]>
  }




  export type tagsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: tagsWhereInput
    orderBy?: tagsOrderByWithAggregationInput | tagsOrderByWithAggregationInput[]
    by: TagsScalarFieldEnum[] | TagsScalarFieldEnum
    having?: tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagsCountAggregateInputType | true
    _avg?: TagsAvgAggregateInputType
    _sum?: TagsSumAggregateInputType
    _min?: TagsMinAggregateInputType
    _max?: TagsMaxAggregateInputType
  }


  export type TagsGroupByOutputType = {
    created_at: Date
    updated_at: Date
    id: number
    name: string
    _count: TagsCountAggregateOutputType | null
    _avg: TagsAvgAggregateOutputType | null
    _sum: TagsSumAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  type GetTagsGroupByPayload<T extends tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagsGroupByOutputType[P]>
            : GetScalarType<T[P], TagsGroupByOutputType[P]>
        }
      >
    >


  export type tagsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
    chapter_tags?: boolean | tags$chapter_tagsArgs<ExtArgs>
    event_tags?: boolean | tags$event_tagsArgs<ExtArgs>
    venue_tags?: boolean | tags$venue_tagsArgs<ExtArgs>
    _count?: boolean | TagsCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["tags"]>

  export type tagsSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
  }

  export type tagsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    chapter_tags?: boolean | tags$chapter_tagsArgs<ExtArgs>
    event_tags?: boolean | tags$event_tagsArgs<ExtArgs>
    venue_tags?: boolean | tags$venue_tagsArgs<ExtArgs>
    _count?: boolean | TagsCountOutputTypeArgs<ExtArgs>
  }


  type tagsGetPayload<S extends boolean | null | undefined | tagsArgs> = $Types.GetResult<tagsPayload, S>

  type tagsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<tagsFindManyArgs, 'select' | 'include'> & {
      select?: TagsCountAggregateInputType | true
    }

  export interface tagsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tags'], meta: { name: 'tags' } }
    /**
     * Find zero or one Tags that matches the filter.
     * @param {tagsFindUniqueArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tagsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tagsFindUniqueArgs<ExtArgs>>
    ): Prisma__tagsClient<$Types.GetResult<tagsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tags that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tagsFindUniqueOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tagsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tagsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tagsClient<$Types.GetResult<tagsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsFindFirstArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tagsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tagsFindFirstArgs<ExtArgs>>
    ): Prisma__tagsClient<$Types.GetResult<tagsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsFindFirstOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tagsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tagsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tagsClient<$Types.GetResult<tagsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tags.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tags.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const tagsWithCreated_atOnly = await prisma.tags.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends tagsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tagsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<tagsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tags.
     * @param {tagsCreateArgs} args - Arguments to create a Tags.
     * @example
     * // Create one Tags
     * const Tags = await prisma.tags.create({
     *   data: {
     *     // ... data to create a Tags
     *   }
     * })
     * 
    **/
    create<T extends tagsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tagsCreateArgs<ExtArgs>>
    ): Prisma__tagsClient<$Types.GetResult<tagsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tags.
     *     @param {tagsCreateManyArgs} args - Arguments to create many Tags.
     *     @example
     *     // Create many Tags
     *     const tags = await prisma.tags.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tagsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tagsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tags.
     * @param {tagsDeleteArgs} args - Arguments to delete one Tags.
     * @example
     * // Delete one Tags
     * const Tags = await prisma.tags.delete({
     *   where: {
     *     // ... filter to delete one Tags
     *   }
     * })
     * 
    **/
    delete<T extends tagsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tagsDeleteArgs<ExtArgs>>
    ): Prisma__tagsClient<$Types.GetResult<tagsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tags.
     * @param {tagsUpdateArgs} args - Arguments to update one Tags.
     * @example
     * // Update one Tags
     * const tags = await prisma.tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tagsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tagsUpdateArgs<ExtArgs>>
    ): Prisma__tagsClient<$Types.GetResult<tagsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tags.
     * @param {tagsDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tagsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tagsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tagsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tagsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tags.
     * @param {tagsUpsertArgs} args - Arguments to update or create a Tags.
     * @example
     * // Update or create a Tags
     * const tags = await prisma.tags.upsert({
     *   create: {
     *     // ... data to create a Tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tags we want to update
     *   }
     * })
    **/
    upsert<T extends tagsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tagsUpsertArgs<ExtArgs>>
    ): Prisma__tagsClient<$Types.GetResult<tagsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tags.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends tagsCountArgs>(
      args?: Subset<T, tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagsAggregateArgs>(args: Subset<T, TagsAggregateArgs>): Prisma.PrismaPromise<GetTagsAggregateType<T>>

    /**
     * Group by Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tagsGroupByArgs['orderBy'] }
        : { orderBy?: tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tags model
   */
  readonly fields: tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tagsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    chapter_tags<T extends tags$chapter_tagsArgs<ExtArgs> = {}>(args?: Subset<T, tags$chapter_tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<chapter_tagsPayload<ExtArgs>, T, 'findMany'>| Null>;

    event_tags<T extends tags$event_tagsArgs<ExtArgs> = {}>(args?: Subset<T, tags$event_tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<event_tagsPayload<ExtArgs>, T, 'findMany'>| Null>;

    venue_tags<T extends tags$venue_tagsArgs<ExtArgs> = {}>(args?: Subset<T, tags$venue_tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<venue_tagsPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the tags model
   */ 
  interface tagsFieldRefs {
    readonly created_at: FieldRef<"tags", 'DateTime'>
    readonly updated_at: FieldRef<"tags", 'DateTime'>
    readonly id: FieldRef<"tags", 'Int'>
    readonly name: FieldRef<"tags", 'String'>
  }
    

  // Custom InputTypes

  /**
   * tags findUnique
   */
  export type tagsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where: tagsWhereUniqueInput
  }


  /**
   * tags findUniqueOrThrow
   */
  export type tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where: tagsWhereUniqueInput
  }


  /**
   * tags findFirst
   */
  export type tagsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }


  /**
   * tags findFirstOrThrow
   */
  export type tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }


  /**
   * tags findMany
   */
  export type tagsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tags.
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }


  /**
   * tags create
   */
  export type tagsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a tags.
     */
    data: XOR<tagsCreateInput, tagsUncheckedCreateInput>
  }


  /**
   * tags createMany
   */
  export type tagsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tags.
     */
    data: tagsCreateManyInput | tagsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tags update
   */
  export type tagsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a tags.
     */
    data: XOR<tagsUpdateInput, tagsUncheckedUpdateInput>
    /**
     * Choose, which tags to update.
     */
    where: tagsWhereUniqueInput
  }


  /**
   * tags updateMany
   */
  export type tagsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tags.
     */
    data: XOR<tagsUpdateManyMutationInput, tagsUncheckedUpdateManyInput>
    /**
     * Filter which tags to update
     */
    where?: tagsWhereInput
  }


  /**
   * tags upsert
   */
  export type tagsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the tags to update in case it exists.
     */
    where: tagsWhereUniqueInput
    /**
     * In case the tags found by the `where` argument doesn't exist, create a new tags with this data.
     */
    create: XOR<tagsCreateInput, tagsUncheckedCreateInput>
    /**
     * In case the tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tagsUpdateInput, tagsUncheckedUpdateInput>
  }


  /**
   * tags delete
   */
  export type tagsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter which tags to delete.
     */
    where: tagsWhereUniqueInput
  }


  /**
   * tags deleteMany
   */
  export type tagsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tags to delete
     */
    where?: tagsWhereInput
  }


  /**
   * tags.chapter_tags
   */
  export type tags$chapter_tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_tags
     */
    select?: chapter_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_tagsInclude<ExtArgs> | null
    where?: chapter_tagsWhereInput
    orderBy?: chapter_tagsOrderByWithRelationInput | chapter_tagsOrderByWithRelationInput[]
    cursor?: chapter_tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chapter_tagsScalarFieldEnum | Chapter_tagsScalarFieldEnum[]
  }


  /**
   * tags.event_tags
   */
  export type tags$event_tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_tags
     */
    select?: event_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_tagsInclude<ExtArgs> | null
    where?: event_tagsWhereInput
    orderBy?: event_tagsOrderByWithRelationInput | event_tagsOrderByWithRelationInput[]
    cursor?: event_tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Event_tagsScalarFieldEnum | Event_tagsScalarFieldEnum[]
  }


  /**
   * tags.venue_tags
   */
  export type tags$venue_tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venue_tags
     */
    select?: venue_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venue_tagsInclude<ExtArgs> | null
    where?: venue_tagsWhereInput
    orderBy?: venue_tagsOrderByWithRelationInput | venue_tagsOrderByWithRelationInput[]
    cursor?: venue_tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Venue_tagsScalarFieldEnum | Venue_tagsScalarFieldEnum[]
  }


  /**
   * tags without action
   */
  export type tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tagsInclude<ExtArgs> | null
  }



  /**
   * Model user_bans
   */


  export type AggregateUser_bans = {
    _count: User_bansCountAggregateOutputType | null
    _avg: User_bansAvgAggregateOutputType | null
    _sum: User_bansSumAggregateOutputType | null
    _min: User_bansMinAggregateOutputType | null
    _max: User_bansMaxAggregateOutputType | null
  }

  export type User_bansAvgAggregateOutputType = {
    user_id: number | null
    chapter_id: number | null
  }

  export type User_bansSumAggregateOutputType = {
    user_id: number | null
    chapter_id: number | null
  }

  export type User_bansMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    user_id: number | null
    chapter_id: number | null
  }

  export type User_bansMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    user_id: number | null
    chapter_id: number | null
  }

  export type User_bansCountAggregateOutputType = {
    created_at: number
    updated_at: number
    user_id: number
    chapter_id: number
    _all: number
  }


  export type User_bansAvgAggregateInputType = {
    user_id?: true
    chapter_id?: true
  }

  export type User_bansSumAggregateInputType = {
    user_id?: true
    chapter_id?: true
  }

  export type User_bansMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    user_id?: true
    chapter_id?: true
  }

  export type User_bansMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    user_id?: true
    chapter_id?: true
  }

  export type User_bansCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    user_id?: true
    chapter_id?: true
    _all?: true
  }

  export type User_bansAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_bans to aggregate.
     */
    where?: user_bansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_bans to fetch.
     */
    orderBy?: user_bansOrderByWithRelationInput | user_bansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_bansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_bans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_bans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_bans
    **/
    _count?: true | User_bansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_bansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_bansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_bansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_bansMaxAggregateInputType
  }

  export type GetUser_bansAggregateType<T extends User_bansAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_bans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_bans[P]>
      : GetScalarType<T[P], AggregateUser_bans[P]>
  }




  export type user_bansGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_bansWhereInput
    orderBy?: user_bansOrderByWithAggregationInput | user_bansOrderByWithAggregationInput[]
    by: User_bansScalarFieldEnum[] | User_bansScalarFieldEnum
    having?: user_bansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_bansCountAggregateInputType | true
    _avg?: User_bansAvgAggregateInputType
    _sum?: User_bansSumAggregateInputType
    _min?: User_bansMinAggregateInputType
    _max?: User_bansMaxAggregateInputType
  }


  export type User_bansGroupByOutputType = {
    created_at: Date
    updated_at: Date
    user_id: number
    chapter_id: number
    _count: User_bansCountAggregateOutputType | null
    _avg: User_bansAvgAggregateOutputType | null
    _sum: User_bansSumAggregateOutputType | null
    _min: User_bansMinAggregateOutputType | null
    _max: User_bansMaxAggregateOutputType | null
  }

  type GetUser_bansGroupByPayload<T extends user_bansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_bansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_bansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_bansGroupByOutputType[P]>
            : GetScalarType<T[P], User_bansGroupByOutputType[P]>
        }
      >
    >


  export type user_bansSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    chapter_id?: boolean
    chapter?: boolean | chaptersArgs<ExtArgs>
    user?: boolean | usersArgs<ExtArgs>
  }, ExtArgs["result"]["user_bans"]>

  export type user_bansSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    chapter_id?: boolean
  }

  export type user_bansInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    chapter?: boolean | chaptersArgs<ExtArgs>
    user?: boolean | usersArgs<ExtArgs>
  }


  type user_bansGetPayload<S extends boolean | null | undefined | user_bansArgs> = $Types.GetResult<user_bansPayload, S>

  type user_bansCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<user_bansFindManyArgs, 'select' | 'include'> & {
      select?: User_bansCountAggregateInputType | true
    }

  export interface user_bansDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_bans'], meta: { name: 'user_bans' } }
    /**
     * Find zero or one User_bans that matches the filter.
     * @param {user_bansFindUniqueArgs} args - Arguments to find a User_bans
     * @example
     * // Get one User_bans
     * const user_bans = await prisma.user_bans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_bansFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, user_bansFindUniqueArgs<ExtArgs>>
    ): Prisma__user_bansClient<$Types.GetResult<user_bansPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User_bans that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {user_bansFindUniqueOrThrowArgs} args - Arguments to find a User_bans
     * @example
     * // Get one User_bans
     * const user_bans = await prisma.user_bans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_bansFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_bansFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__user_bansClient<$Types.GetResult<user_bansPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User_bans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_bansFindFirstArgs} args - Arguments to find a User_bans
     * @example
     * // Get one User_bans
     * const user_bans = await prisma.user_bans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_bansFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, user_bansFindFirstArgs<ExtArgs>>
    ): Prisma__user_bansClient<$Types.GetResult<user_bansPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User_bans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_bansFindFirstOrThrowArgs} args - Arguments to find a User_bans
     * @example
     * // Get one User_bans
     * const user_bans = await prisma.user_bans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_bansFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_bansFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__user_bansClient<$Types.GetResult<user_bansPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more User_bans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_bansFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_bans
     * const user_bans = await prisma.user_bans.findMany()
     * 
     * // Get first 10 User_bans
     * const user_bans = await prisma.user_bans.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const user_bansWithCreated_atOnly = await prisma.user_bans.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends user_bansFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_bansFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<user_bansPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User_bans.
     * @param {user_bansCreateArgs} args - Arguments to create a User_bans.
     * @example
     * // Create one User_bans
     * const User_bans = await prisma.user_bans.create({
     *   data: {
     *     // ... data to create a User_bans
     *   }
     * })
     * 
    **/
    create<T extends user_bansCreateArgs<ExtArgs>>(
      args: SelectSubset<T, user_bansCreateArgs<ExtArgs>>
    ): Prisma__user_bansClient<$Types.GetResult<user_bansPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many User_bans.
     *     @param {user_bansCreateManyArgs} args - Arguments to create many User_bans.
     *     @example
     *     // Create many User_bans
     *     const user_bans = await prisma.user_bans.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_bansCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_bansCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_bans.
     * @param {user_bansDeleteArgs} args - Arguments to delete one User_bans.
     * @example
     * // Delete one User_bans
     * const User_bans = await prisma.user_bans.delete({
     *   where: {
     *     // ... filter to delete one User_bans
     *   }
     * })
     * 
    **/
    delete<T extends user_bansDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, user_bansDeleteArgs<ExtArgs>>
    ): Prisma__user_bansClient<$Types.GetResult<user_bansPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User_bans.
     * @param {user_bansUpdateArgs} args - Arguments to update one User_bans.
     * @example
     * // Update one User_bans
     * const user_bans = await prisma.user_bans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_bansUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, user_bansUpdateArgs<ExtArgs>>
    ): Prisma__user_bansClient<$Types.GetResult<user_bansPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more User_bans.
     * @param {user_bansDeleteManyArgs} args - Arguments to filter User_bans to delete.
     * @example
     * // Delete a few User_bans
     * const { count } = await prisma.user_bans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_bansDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_bansDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_bans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_bansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_bans
     * const user_bans = await prisma.user_bans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_bansUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, user_bansUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_bans.
     * @param {user_bansUpsertArgs} args - Arguments to update or create a User_bans.
     * @example
     * // Update or create a User_bans
     * const user_bans = await prisma.user_bans.upsert({
     *   create: {
     *     // ... data to create a User_bans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_bans we want to update
     *   }
     * })
    **/
    upsert<T extends user_bansUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, user_bansUpsertArgs<ExtArgs>>
    ): Prisma__user_bansClient<$Types.GetResult<user_bansPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of User_bans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_bansCountArgs} args - Arguments to filter User_bans to count.
     * @example
     * // Count the number of User_bans
     * const count = await prisma.user_bans.count({
     *   where: {
     *     // ... the filter for the User_bans we want to count
     *   }
     * })
    **/
    count<T extends user_bansCountArgs>(
      args?: Subset<T, user_bansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_bansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_bans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_bansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_bansAggregateArgs>(args: Subset<T, User_bansAggregateArgs>): Prisma.PrismaPromise<GetUser_bansAggregateType<T>>

    /**
     * Group by User_bans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_bansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_bansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_bansGroupByArgs['orderBy'] }
        : { orderBy?: user_bansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_bansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_bansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_bans model
   */
  readonly fields: user_bansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_bans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_bansClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    chapter<T extends chaptersArgs<ExtArgs> = {}>(args?: Subset<T, chaptersArgs<ExtArgs>>): Prisma__chaptersClient<$Types.GetResult<chaptersPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    user<T extends usersArgs<ExtArgs> = {}>(args?: Subset<T, usersArgs<ExtArgs>>): Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the user_bans model
   */ 
  interface user_bansFieldRefs {
    readonly created_at: FieldRef<"user_bans", 'DateTime'>
    readonly updated_at: FieldRef<"user_bans", 'DateTime'>
    readonly user_id: FieldRef<"user_bans", 'Int'>
    readonly chapter_id: FieldRef<"user_bans", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * user_bans findUnique
   */
  export type user_bansFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bans
     */
    select?: user_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bansInclude<ExtArgs> | null
    /**
     * Filter, which user_bans to fetch.
     */
    where: user_bansWhereUniqueInput
  }


  /**
   * user_bans findUniqueOrThrow
   */
  export type user_bansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bans
     */
    select?: user_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bansInclude<ExtArgs> | null
    /**
     * Filter, which user_bans to fetch.
     */
    where: user_bansWhereUniqueInput
  }


  /**
   * user_bans findFirst
   */
  export type user_bansFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bans
     */
    select?: user_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bansInclude<ExtArgs> | null
    /**
     * Filter, which user_bans to fetch.
     */
    where?: user_bansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_bans to fetch.
     */
    orderBy?: user_bansOrderByWithRelationInput | user_bansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_bans.
     */
    cursor?: user_bansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_bans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_bans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_bans.
     */
    distinct?: User_bansScalarFieldEnum | User_bansScalarFieldEnum[]
  }


  /**
   * user_bans findFirstOrThrow
   */
  export type user_bansFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bans
     */
    select?: user_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bansInclude<ExtArgs> | null
    /**
     * Filter, which user_bans to fetch.
     */
    where?: user_bansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_bans to fetch.
     */
    orderBy?: user_bansOrderByWithRelationInput | user_bansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_bans.
     */
    cursor?: user_bansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_bans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_bans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_bans.
     */
    distinct?: User_bansScalarFieldEnum | User_bansScalarFieldEnum[]
  }


  /**
   * user_bans findMany
   */
  export type user_bansFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bans
     */
    select?: user_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bansInclude<ExtArgs> | null
    /**
     * Filter, which user_bans to fetch.
     */
    where?: user_bansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_bans to fetch.
     */
    orderBy?: user_bansOrderByWithRelationInput | user_bansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_bans.
     */
    cursor?: user_bansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_bans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_bans.
     */
    skip?: number
    distinct?: User_bansScalarFieldEnum | User_bansScalarFieldEnum[]
  }


  /**
   * user_bans create
   */
  export type user_bansCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bans
     */
    select?: user_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bansInclude<ExtArgs> | null
    /**
     * The data needed to create a user_bans.
     */
    data: XOR<user_bansCreateInput, user_bansUncheckedCreateInput>
  }


  /**
   * user_bans createMany
   */
  export type user_bansCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_bans.
     */
    data: user_bansCreateManyInput | user_bansCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user_bans update
   */
  export type user_bansUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bans
     */
    select?: user_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bansInclude<ExtArgs> | null
    /**
     * The data needed to update a user_bans.
     */
    data: XOR<user_bansUpdateInput, user_bansUncheckedUpdateInput>
    /**
     * Choose, which user_bans to update.
     */
    where: user_bansWhereUniqueInput
  }


  /**
   * user_bans updateMany
   */
  export type user_bansUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_bans.
     */
    data: XOR<user_bansUpdateManyMutationInput, user_bansUncheckedUpdateManyInput>
    /**
     * Filter which user_bans to update
     */
    where?: user_bansWhereInput
  }


  /**
   * user_bans upsert
   */
  export type user_bansUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bans
     */
    select?: user_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bansInclude<ExtArgs> | null
    /**
     * The filter to search for the user_bans to update in case it exists.
     */
    where: user_bansWhereUniqueInput
    /**
     * In case the user_bans found by the `where` argument doesn't exist, create a new user_bans with this data.
     */
    create: XOR<user_bansCreateInput, user_bansUncheckedCreateInput>
    /**
     * In case the user_bans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_bansUpdateInput, user_bansUncheckedUpdateInput>
  }


  /**
   * user_bans delete
   */
  export type user_bansDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bans
     */
    select?: user_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bansInclude<ExtArgs> | null
    /**
     * Filter which user_bans to delete.
     */
    where: user_bansWhereUniqueInput
  }


  /**
   * user_bans deleteMany
   */
  export type user_bansDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_bans to delete
     */
    where?: user_bansWhereInput
  }


  /**
   * user_bans without action
   */
  export type user_bansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bans
     */
    select?: user_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bansInclude<ExtArgs> | null
  }



  /**
   * Model instance_permissions
   */


  export type AggregateInstance_permissions = {
    _count: Instance_permissionsCountAggregateOutputType | null
    _avg: Instance_permissionsAvgAggregateOutputType | null
    _sum: Instance_permissionsSumAggregateOutputType | null
    _min: Instance_permissionsMinAggregateOutputType | null
    _max: Instance_permissionsMaxAggregateOutputType | null
  }

  export type Instance_permissionsAvgAggregateOutputType = {
    id: number | null
  }

  export type Instance_permissionsSumAggregateOutputType = {
    id: number | null
  }

  export type Instance_permissionsMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
  }

  export type Instance_permissionsMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
  }

  export type Instance_permissionsCountAggregateOutputType = {
    created_at: number
    updated_at: number
    id: number
    name: number
    _all: number
  }


  export type Instance_permissionsAvgAggregateInputType = {
    id?: true
  }

  export type Instance_permissionsSumAggregateInputType = {
    id?: true
  }

  export type Instance_permissionsMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
  }

  export type Instance_permissionsMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
  }

  export type Instance_permissionsCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    _all?: true
  }

  export type Instance_permissionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which instance_permissions to aggregate.
     */
    where?: instance_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instance_permissions to fetch.
     */
    orderBy?: instance_permissionsOrderByWithRelationInput | instance_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: instance_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instance_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instance_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned instance_permissions
    **/
    _count?: true | Instance_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Instance_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Instance_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Instance_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Instance_permissionsMaxAggregateInputType
  }

  export type GetInstance_permissionsAggregateType<T extends Instance_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateInstance_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstance_permissions[P]>
      : GetScalarType<T[P], AggregateInstance_permissions[P]>
  }




  export type instance_permissionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: instance_permissionsWhereInput
    orderBy?: instance_permissionsOrderByWithAggregationInput | instance_permissionsOrderByWithAggregationInput[]
    by: Instance_permissionsScalarFieldEnum[] | Instance_permissionsScalarFieldEnum
    having?: instance_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Instance_permissionsCountAggregateInputType | true
    _avg?: Instance_permissionsAvgAggregateInputType
    _sum?: Instance_permissionsSumAggregateInputType
    _min?: Instance_permissionsMinAggregateInputType
    _max?: Instance_permissionsMaxAggregateInputType
  }


  export type Instance_permissionsGroupByOutputType = {
    created_at: Date
    updated_at: Date
    id: number
    name: string
    _count: Instance_permissionsCountAggregateOutputType | null
    _avg: Instance_permissionsAvgAggregateOutputType | null
    _sum: Instance_permissionsSumAggregateOutputType | null
    _min: Instance_permissionsMinAggregateOutputType | null
    _max: Instance_permissionsMaxAggregateOutputType | null
  }

  type GetInstance_permissionsGroupByPayload<T extends instance_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Instance_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Instance_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Instance_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Instance_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type instance_permissionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
    instance_role_permissions?: boolean | instance_permissions$instance_role_permissionsArgs<ExtArgs>
    _count?: boolean | Instance_permissionsCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["instance_permissions"]>

  export type instance_permissionsSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
  }

  export type instance_permissionsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    instance_role_permissions?: boolean | instance_permissions$instance_role_permissionsArgs<ExtArgs>
    _count?: boolean | Instance_permissionsCountOutputTypeArgs<ExtArgs>
  }


  type instance_permissionsGetPayload<S extends boolean | null | undefined | instance_permissionsArgs> = $Types.GetResult<instance_permissionsPayload, S>

  type instance_permissionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<instance_permissionsFindManyArgs, 'select' | 'include'> & {
      select?: Instance_permissionsCountAggregateInputType | true
    }

  export interface instance_permissionsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['instance_permissions'], meta: { name: 'instance_permissions' } }
    /**
     * Find zero or one Instance_permissions that matches the filter.
     * @param {instance_permissionsFindUniqueArgs} args - Arguments to find a Instance_permissions
     * @example
     * // Get one Instance_permissions
     * const instance_permissions = await prisma.instance_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends instance_permissionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, instance_permissionsFindUniqueArgs<ExtArgs>>
    ): Prisma__instance_permissionsClient<$Types.GetResult<instance_permissionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Instance_permissions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {instance_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Instance_permissions
     * @example
     * // Get one Instance_permissions
     * const instance_permissions = await prisma.instance_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends instance_permissionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, instance_permissionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__instance_permissionsClient<$Types.GetResult<instance_permissionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Instance_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instance_permissionsFindFirstArgs} args - Arguments to find a Instance_permissions
     * @example
     * // Get one Instance_permissions
     * const instance_permissions = await prisma.instance_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends instance_permissionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, instance_permissionsFindFirstArgs<ExtArgs>>
    ): Prisma__instance_permissionsClient<$Types.GetResult<instance_permissionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Instance_permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instance_permissionsFindFirstOrThrowArgs} args - Arguments to find a Instance_permissions
     * @example
     * // Get one Instance_permissions
     * const instance_permissions = await prisma.instance_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends instance_permissionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, instance_permissionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__instance_permissionsClient<$Types.GetResult<instance_permissionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Instance_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instance_permissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instance_permissions
     * const instance_permissions = await prisma.instance_permissions.findMany()
     * 
     * // Get first 10 Instance_permissions
     * const instance_permissions = await prisma.instance_permissions.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const instance_permissionsWithCreated_atOnly = await prisma.instance_permissions.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends instance_permissionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, instance_permissionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<instance_permissionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Instance_permissions.
     * @param {instance_permissionsCreateArgs} args - Arguments to create a Instance_permissions.
     * @example
     * // Create one Instance_permissions
     * const Instance_permissions = await prisma.instance_permissions.create({
     *   data: {
     *     // ... data to create a Instance_permissions
     *   }
     * })
     * 
    **/
    create<T extends instance_permissionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, instance_permissionsCreateArgs<ExtArgs>>
    ): Prisma__instance_permissionsClient<$Types.GetResult<instance_permissionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Instance_permissions.
     *     @param {instance_permissionsCreateManyArgs} args - Arguments to create many Instance_permissions.
     *     @example
     *     // Create many Instance_permissions
     *     const instance_permissions = await prisma.instance_permissions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends instance_permissionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, instance_permissionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Instance_permissions.
     * @param {instance_permissionsDeleteArgs} args - Arguments to delete one Instance_permissions.
     * @example
     * // Delete one Instance_permissions
     * const Instance_permissions = await prisma.instance_permissions.delete({
     *   where: {
     *     // ... filter to delete one Instance_permissions
     *   }
     * })
     * 
    **/
    delete<T extends instance_permissionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, instance_permissionsDeleteArgs<ExtArgs>>
    ): Prisma__instance_permissionsClient<$Types.GetResult<instance_permissionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Instance_permissions.
     * @param {instance_permissionsUpdateArgs} args - Arguments to update one Instance_permissions.
     * @example
     * // Update one Instance_permissions
     * const instance_permissions = await prisma.instance_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends instance_permissionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, instance_permissionsUpdateArgs<ExtArgs>>
    ): Prisma__instance_permissionsClient<$Types.GetResult<instance_permissionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Instance_permissions.
     * @param {instance_permissionsDeleteManyArgs} args - Arguments to filter Instance_permissions to delete.
     * @example
     * // Delete a few Instance_permissions
     * const { count } = await prisma.instance_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends instance_permissionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, instance_permissionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instance_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instance_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instance_permissions
     * const instance_permissions = await prisma.instance_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends instance_permissionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, instance_permissionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Instance_permissions.
     * @param {instance_permissionsUpsertArgs} args - Arguments to update or create a Instance_permissions.
     * @example
     * // Update or create a Instance_permissions
     * const instance_permissions = await prisma.instance_permissions.upsert({
     *   create: {
     *     // ... data to create a Instance_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instance_permissions we want to update
     *   }
     * })
    **/
    upsert<T extends instance_permissionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, instance_permissionsUpsertArgs<ExtArgs>>
    ): Prisma__instance_permissionsClient<$Types.GetResult<instance_permissionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Instance_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instance_permissionsCountArgs} args - Arguments to filter Instance_permissions to count.
     * @example
     * // Count the number of Instance_permissions
     * const count = await prisma.instance_permissions.count({
     *   where: {
     *     // ... the filter for the Instance_permissions we want to count
     *   }
     * })
    **/
    count<T extends instance_permissionsCountArgs>(
      args?: Subset<T, instance_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Instance_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instance_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Instance_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Instance_permissionsAggregateArgs>(args: Subset<T, Instance_permissionsAggregateArgs>): Prisma.PrismaPromise<GetInstance_permissionsAggregateType<T>>

    /**
     * Group by Instance_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instance_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends instance_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: instance_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: instance_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, instance_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstance_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the instance_permissions model
   */
  readonly fields: instance_permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for instance_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__instance_permissionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    instance_role_permissions<T extends instance_permissions$instance_role_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, instance_permissions$instance_role_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<instance_role_permissionsPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the instance_permissions model
   */ 
  interface instance_permissionsFieldRefs {
    readonly created_at: FieldRef<"instance_permissions", 'DateTime'>
    readonly updated_at: FieldRef<"instance_permissions", 'DateTime'>
    readonly id: FieldRef<"instance_permissions", 'Int'>
    readonly name: FieldRef<"instance_permissions", 'String'>
  }
    

  // Custom InputTypes

  /**
   * instance_permissions findUnique
   */
  export type instance_permissionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_permissions
     */
    select?: instance_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which instance_permissions to fetch.
     */
    where: instance_permissionsWhereUniqueInput
  }


  /**
   * instance_permissions findUniqueOrThrow
   */
  export type instance_permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_permissions
     */
    select?: instance_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which instance_permissions to fetch.
     */
    where: instance_permissionsWhereUniqueInput
  }


  /**
   * instance_permissions findFirst
   */
  export type instance_permissionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_permissions
     */
    select?: instance_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which instance_permissions to fetch.
     */
    where?: instance_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instance_permissions to fetch.
     */
    orderBy?: instance_permissionsOrderByWithRelationInput | instance_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for instance_permissions.
     */
    cursor?: instance_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instance_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instance_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of instance_permissions.
     */
    distinct?: Instance_permissionsScalarFieldEnum | Instance_permissionsScalarFieldEnum[]
  }


  /**
   * instance_permissions findFirstOrThrow
   */
  export type instance_permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_permissions
     */
    select?: instance_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which instance_permissions to fetch.
     */
    where?: instance_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instance_permissions to fetch.
     */
    orderBy?: instance_permissionsOrderByWithRelationInput | instance_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for instance_permissions.
     */
    cursor?: instance_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instance_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instance_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of instance_permissions.
     */
    distinct?: Instance_permissionsScalarFieldEnum | Instance_permissionsScalarFieldEnum[]
  }


  /**
   * instance_permissions findMany
   */
  export type instance_permissionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_permissions
     */
    select?: instance_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which instance_permissions to fetch.
     */
    where?: instance_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instance_permissions to fetch.
     */
    orderBy?: instance_permissionsOrderByWithRelationInput | instance_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing instance_permissions.
     */
    cursor?: instance_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instance_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instance_permissions.
     */
    skip?: number
    distinct?: Instance_permissionsScalarFieldEnum | Instance_permissionsScalarFieldEnum[]
  }


  /**
   * instance_permissions create
   */
  export type instance_permissionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_permissions
     */
    select?: instance_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a instance_permissions.
     */
    data: XOR<instance_permissionsCreateInput, instance_permissionsUncheckedCreateInput>
  }


  /**
   * instance_permissions createMany
   */
  export type instance_permissionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many instance_permissions.
     */
    data: instance_permissionsCreateManyInput | instance_permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * instance_permissions update
   */
  export type instance_permissionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_permissions
     */
    select?: instance_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a instance_permissions.
     */
    data: XOR<instance_permissionsUpdateInput, instance_permissionsUncheckedUpdateInput>
    /**
     * Choose, which instance_permissions to update.
     */
    where: instance_permissionsWhereUniqueInput
  }


  /**
   * instance_permissions updateMany
   */
  export type instance_permissionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update instance_permissions.
     */
    data: XOR<instance_permissionsUpdateManyMutationInput, instance_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which instance_permissions to update
     */
    where?: instance_permissionsWhereInput
  }


  /**
   * instance_permissions upsert
   */
  export type instance_permissionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_permissions
     */
    select?: instance_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the instance_permissions to update in case it exists.
     */
    where: instance_permissionsWhereUniqueInput
    /**
     * In case the instance_permissions found by the `where` argument doesn't exist, create a new instance_permissions with this data.
     */
    create: XOR<instance_permissionsCreateInput, instance_permissionsUncheckedCreateInput>
    /**
     * In case the instance_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<instance_permissionsUpdateInput, instance_permissionsUncheckedUpdateInput>
  }


  /**
   * instance_permissions delete
   */
  export type instance_permissionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_permissions
     */
    select?: instance_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_permissionsInclude<ExtArgs> | null
    /**
     * Filter which instance_permissions to delete.
     */
    where: instance_permissionsWhereUniqueInput
  }


  /**
   * instance_permissions deleteMany
   */
  export type instance_permissionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which instance_permissions to delete
     */
    where?: instance_permissionsWhereInput
  }


  /**
   * instance_permissions.instance_role_permissions
   */
  export type instance_permissions$instance_role_permissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_role_permissions
     */
    select?: instance_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_role_permissionsInclude<ExtArgs> | null
    where?: instance_role_permissionsWhereInput
    orderBy?: instance_role_permissionsOrderByWithRelationInput | instance_role_permissionsOrderByWithRelationInput[]
    cursor?: instance_role_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Instance_role_permissionsScalarFieldEnum | Instance_role_permissionsScalarFieldEnum[]
  }


  /**
   * instance_permissions without action
   */
  export type instance_permissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_permissions
     */
    select?: instance_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_permissionsInclude<ExtArgs> | null
  }



  /**
   * Model instance_role_permissions
   */


  export type AggregateInstance_role_permissions = {
    _count: Instance_role_permissionsCountAggregateOutputType | null
    _avg: Instance_role_permissionsAvgAggregateOutputType | null
    _sum: Instance_role_permissionsSumAggregateOutputType | null
    _min: Instance_role_permissionsMinAggregateOutputType | null
    _max: Instance_role_permissionsMaxAggregateOutputType | null
  }

  export type Instance_role_permissionsAvgAggregateOutputType = {
    instance_role_id: number | null
    instance_permission_id: number | null
  }

  export type Instance_role_permissionsSumAggregateOutputType = {
    instance_role_id: number | null
    instance_permission_id: number | null
  }

  export type Instance_role_permissionsMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    instance_role_id: number | null
    instance_permission_id: number | null
  }

  export type Instance_role_permissionsMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    instance_role_id: number | null
    instance_permission_id: number | null
  }

  export type Instance_role_permissionsCountAggregateOutputType = {
    created_at: number
    updated_at: number
    instance_role_id: number
    instance_permission_id: number
    _all: number
  }


  export type Instance_role_permissionsAvgAggregateInputType = {
    instance_role_id?: true
    instance_permission_id?: true
  }

  export type Instance_role_permissionsSumAggregateInputType = {
    instance_role_id?: true
    instance_permission_id?: true
  }

  export type Instance_role_permissionsMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    instance_role_id?: true
    instance_permission_id?: true
  }

  export type Instance_role_permissionsMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    instance_role_id?: true
    instance_permission_id?: true
  }

  export type Instance_role_permissionsCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    instance_role_id?: true
    instance_permission_id?: true
    _all?: true
  }

  export type Instance_role_permissionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which instance_role_permissions to aggregate.
     */
    where?: instance_role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instance_role_permissions to fetch.
     */
    orderBy?: instance_role_permissionsOrderByWithRelationInput | instance_role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: instance_role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instance_role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instance_role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned instance_role_permissions
    **/
    _count?: true | Instance_role_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Instance_role_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Instance_role_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Instance_role_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Instance_role_permissionsMaxAggregateInputType
  }

  export type GetInstance_role_permissionsAggregateType<T extends Instance_role_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateInstance_role_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstance_role_permissions[P]>
      : GetScalarType<T[P], AggregateInstance_role_permissions[P]>
  }




  export type instance_role_permissionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: instance_role_permissionsWhereInput
    orderBy?: instance_role_permissionsOrderByWithAggregationInput | instance_role_permissionsOrderByWithAggregationInput[]
    by: Instance_role_permissionsScalarFieldEnum[] | Instance_role_permissionsScalarFieldEnum
    having?: instance_role_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Instance_role_permissionsCountAggregateInputType | true
    _avg?: Instance_role_permissionsAvgAggregateInputType
    _sum?: Instance_role_permissionsSumAggregateInputType
    _min?: Instance_role_permissionsMinAggregateInputType
    _max?: Instance_role_permissionsMaxAggregateInputType
  }


  export type Instance_role_permissionsGroupByOutputType = {
    created_at: Date
    updated_at: Date
    instance_role_id: number
    instance_permission_id: number
    _count: Instance_role_permissionsCountAggregateOutputType | null
    _avg: Instance_role_permissionsAvgAggregateOutputType | null
    _sum: Instance_role_permissionsSumAggregateOutputType | null
    _min: Instance_role_permissionsMinAggregateOutputType | null
    _max: Instance_role_permissionsMaxAggregateOutputType | null
  }

  type GetInstance_role_permissionsGroupByPayload<T extends instance_role_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Instance_role_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Instance_role_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Instance_role_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Instance_role_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type instance_role_permissionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    instance_role_id?: boolean
    instance_permission_id?: boolean
    instance_role?: boolean | instance_rolesArgs<ExtArgs>
    instance_permission?: boolean | instance_permissionsArgs<ExtArgs>
  }, ExtArgs["result"]["instance_role_permissions"]>

  export type instance_role_permissionsSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    instance_role_id?: boolean
    instance_permission_id?: boolean
  }

  export type instance_role_permissionsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    instance_role?: boolean | instance_rolesArgs<ExtArgs>
    instance_permission?: boolean | instance_permissionsArgs<ExtArgs>
  }


  type instance_role_permissionsGetPayload<S extends boolean | null | undefined | instance_role_permissionsArgs> = $Types.GetResult<instance_role_permissionsPayload, S>

  type instance_role_permissionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<instance_role_permissionsFindManyArgs, 'select' | 'include'> & {
      select?: Instance_role_permissionsCountAggregateInputType | true
    }

  export interface instance_role_permissionsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['instance_role_permissions'], meta: { name: 'instance_role_permissions' } }
    /**
     * Find zero or one Instance_role_permissions that matches the filter.
     * @param {instance_role_permissionsFindUniqueArgs} args - Arguments to find a Instance_role_permissions
     * @example
     * // Get one Instance_role_permissions
     * const instance_role_permissions = await prisma.instance_role_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends instance_role_permissionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, instance_role_permissionsFindUniqueArgs<ExtArgs>>
    ): Prisma__instance_role_permissionsClient<$Types.GetResult<instance_role_permissionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Instance_role_permissions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {instance_role_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Instance_role_permissions
     * @example
     * // Get one Instance_role_permissions
     * const instance_role_permissions = await prisma.instance_role_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends instance_role_permissionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, instance_role_permissionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__instance_role_permissionsClient<$Types.GetResult<instance_role_permissionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Instance_role_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instance_role_permissionsFindFirstArgs} args - Arguments to find a Instance_role_permissions
     * @example
     * // Get one Instance_role_permissions
     * const instance_role_permissions = await prisma.instance_role_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends instance_role_permissionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, instance_role_permissionsFindFirstArgs<ExtArgs>>
    ): Prisma__instance_role_permissionsClient<$Types.GetResult<instance_role_permissionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Instance_role_permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instance_role_permissionsFindFirstOrThrowArgs} args - Arguments to find a Instance_role_permissions
     * @example
     * // Get one Instance_role_permissions
     * const instance_role_permissions = await prisma.instance_role_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends instance_role_permissionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, instance_role_permissionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__instance_role_permissionsClient<$Types.GetResult<instance_role_permissionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Instance_role_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instance_role_permissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instance_role_permissions
     * const instance_role_permissions = await prisma.instance_role_permissions.findMany()
     * 
     * // Get first 10 Instance_role_permissions
     * const instance_role_permissions = await prisma.instance_role_permissions.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const instance_role_permissionsWithCreated_atOnly = await prisma.instance_role_permissions.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends instance_role_permissionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, instance_role_permissionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<instance_role_permissionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Instance_role_permissions.
     * @param {instance_role_permissionsCreateArgs} args - Arguments to create a Instance_role_permissions.
     * @example
     * // Create one Instance_role_permissions
     * const Instance_role_permissions = await prisma.instance_role_permissions.create({
     *   data: {
     *     // ... data to create a Instance_role_permissions
     *   }
     * })
     * 
    **/
    create<T extends instance_role_permissionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, instance_role_permissionsCreateArgs<ExtArgs>>
    ): Prisma__instance_role_permissionsClient<$Types.GetResult<instance_role_permissionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Instance_role_permissions.
     *     @param {instance_role_permissionsCreateManyArgs} args - Arguments to create many Instance_role_permissions.
     *     @example
     *     // Create many Instance_role_permissions
     *     const instance_role_permissions = await prisma.instance_role_permissions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends instance_role_permissionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, instance_role_permissionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Instance_role_permissions.
     * @param {instance_role_permissionsDeleteArgs} args - Arguments to delete one Instance_role_permissions.
     * @example
     * // Delete one Instance_role_permissions
     * const Instance_role_permissions = await prisma.instance_role_permissions.delete({
     *   where: {
     *     // ... filter to delete one Instance_role_permissions
     *   }
     * })
     * 
    **/
    delete<T extends instance_role_permissionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, instance_role_permissionsDeleteArgs<ExtArgs>>
    ): Prisma__instance_role_permissionsClient<$Types.GetResult<instance_role_permissionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Instance_role_permissions.
     * @param {instance_role_permissionsUpdateArgs} args - Arguments to update one Instance_role_permissions.
     * @example
     * // Update one Instance_role_permissions
     * const instance_role_permissions = await prisma.instance_role_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends instance_role_permissionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, instance_role_permissionsUpdateArgs<ExtArgs>>
    ): Prisma__instance_role_permissionsClient<$Types.GetResult<instance_role_permissionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Instance_role_permissions.
     * @param {instance_role_permissionsDeleteManyArgs} args - Arguments to filter Instance_role_permissions to delete.
     * @example
     * // Delete a few Instance_role_permissions
     * const { count } = await prisma.instance_role_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends instance_role_permissionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, instance_role_permissionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instance_role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instance_role_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instance_role_permissions
     * const instance_role_permissions = await prisma.instance_role_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends instance_role_permissionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, instance_role_permissionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Instance_role_permissions.
     * @param {instance_role_permissionsUpsertArgs} args - Arguments to update or create a Instance_role_permissions.
     * @example
     * // Update or create a Instance_role_permissions
     * const instance_role_permissions = await prisma.instance_role_permissions.upsert({
     *   create: {
     *     // ... data to create a Instance_role_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instance_role_permissions we want to update
     *   }
     * })
    **/
    upsert<T extends instance_role_permissionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, instance_role_permissionsUpsertArgs<ExtArgs>>
    ): Prisma__instance_role_permissionsClient<$Types.GetResult<instance_role_permissionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Instance_role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instance_role_permissionsCountArgs} args - Arguments to filter Instance_role_permissions to count.
     * @example
     * // Count the number of Instance_role_permissions
     * const count = await prisma.instance_role_permissions.count({
     *   where: {
     *     // ... the filter for the Instance_role_permissions we want to count
     *   }
     * })
    **/
    count<T extends instance_role_permissionsCountArgs>(
      args?: Subset<T, instance_role_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Instance_role_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instance_role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Instance_role_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Instance_role_permissionsAggregateArgs>(args: Subset<T, Instance_role_permissionsAggregateArgs>): Prisma.PrismaPromise<GetInstance_role_permissionsAggregateType<T>>

    /**
     * Group by Instance_role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instance_role_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends instance_role_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: instance_role_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: instance_role_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, instance_role_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstance_role_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the instance_role_permissions model
   */
  readonly fields: instance_role_permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for instance_role_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__instance_role_permissionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    instance_role<T extends instance_rolesArgs<ExtArgs> = {}>(args?: Subset<T, instance_rolesArgs<ExtArgs>>): Prisma__instance_rolesClient<$Types.GetResult<instance_rolesPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    instance_permission<T extends instance_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, instance_permissionsArgs<ExtArgs>>): Prisma__instance_permissionsClient<$Types.GetResult<instance_permissionsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the instance_role_permissions model
   */ 
  interface instance_role_permissionsFieldRefs {
    readonly created_at: FieldRef<"instance_role_permissions", 'DateTime'>
    readonly updated_at: FieldRef<"instance_role_permissions", 'DateTime'>
    readonly instance_role_id: FieldRef<"instance_role_permissions", 'Int'>
    readonly instance_permission_id: FieldRef<"instance_role_permissions", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * instance_role_permissions findUnique
   */
  export type instance_role_permissionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_role_permissions
     */
    select?: instance_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which instance_role_permissions to fetch.
     */
    where: instance_role_permissionsWhereUniqueInput
  }


  /**
   * instance_role_permissions findUniqueOrThrow
   */
  export type instance_role_permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_role_permissions
     */
    select?: instance_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which instance_role_permissions to fetch.
     */
    where: instance_role_permissionsWhereUniqueInput
  }


  /**
   * instance_role_permissions findFirst
   */
  export type instance_role_permissionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_role_permissions
     */
    select?: instance_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which instance_role_permissions to fetch.
     */
    where?: instance_role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instance_role_permissions to fetch.
     */
    orderBy?: instance_role_permissionsOrderByWithRelationInput | instance_role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for instance_role_permissions.
     */
    cursor?: instance_role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instance_role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instance_role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of instance_role_permissions.
     */
    distinct?: Instance_role_permissionsScalarFieldEnum | Instance_role_permissionsScalarFieldEnum[]
  }


  /**
   * instance_role_permissions findFirstOrThrow
   */
  export type instance_role_permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_role_permissions
     */
    select?: instance_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which instance_role_permissions to fetch.
     */
    where?: instance_role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instance_role_permissions to fetch.
     */
    orderBy?: instance_role_permissionsOrderByWithRelationInput | instance_role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for instance_role_permissions.
     */
    cursor?: instance_role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instance_role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instance_role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of instance_role_permissions.
     */
    distinct?: Instance_role_permissionsScalarFieldEnum | Instance_role_permissionsScalarFieldEnum[]
  }


  /**
   * instance_role_permissions findMany
   */
  export type instance_role_permissionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_role_permissions
     */
    select?: instance_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which instance_role_permissions to fetch.
     */
    where?: instance_role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instance_role_permissions to fetch.
     */
    orderBy?: instance_role_permissionsOrderByWithRelationInput | instance_role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing instance_role_permissions.
     */
    cursor?: instance_role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instance_role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instance_role_permissions.
     */
    skip?: number
    distinct?: Instance_role_permissionsScalarFieldEnum | Instance_role_permissionsScalarFieldEnum[]
  }


  /**
   * instance_role_permissions create
   */
  export type instance_role_permissionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_role_permissions
     */
    select?: instance_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_role_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a instance_role_permissions.
     */
    data: XOR<instance_role_permissionsCreateInput, instance_role_permissionsUncheckedCreateInput>
  }


  /**
   * instance_role_permissions createMany
   */
  export type instance_role_permissionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many instance_role_permissions.
     */
    data: instance_role_permissionsCreateManyInput | instance_role_permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * instance_role_permissions update
   */
  export type instance_role_permissionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_role_permissions
     */
    select?: instance_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_role_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a instance_role_permissions.
     */
    data: XOR<instance_role_permissionsUpdateInput, instance_role_permissionsUncheckedUpdateInput>
    /**
     * Choose, which instance_role_permissions to update.
     */
    where: instance_role_permissionsWhereUniqueInput
  }


  /**
   * instance_role_permissions updateMany
   */
  export type instance_role_permissionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update instance_role_permissions.
     */
    data: XOR<instance_role_permissionsUpdateManyMutationInput, instance_role_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which instance_role_permissions to update
     */
    where?: instance_role_permissionsWhereInput
  }


  /**
   * instance_role_permissions upsert
   */
  export type instance_role_permissionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_role_permissions
     */
    select?: instance_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_role_permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the instance_role_permissions to update in case it exists.
     */
    where: instance_role_permissionsWhereUniqueInput
    /**
     * In case the instance_role_permissions found by the `where` argument doesn't exist, create a new instance_role_permissions with this data.
     */
    create: XOR<instance_role_permissionsCreateInput, instance_role_permissionsUncheckedCreateInput>
    /**
     * In case the instance_role_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<instance_role_permissionsUpdateInput, instance_role_permissionsUncheckedUpdateInput>
  }


  /**
   * instance_role_permissions delete
   */
  export type instance_role_permissionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_role_permissions
     */
    select?: instance_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_role_permissionsInclude<ExtArgs> | null
    /**
     * Filter which instance_role_permissions to delete.
     */
    where: instance_role_permissionsWhereUniqueInput
  }


  /**
   * instance_role_permissions deleteMany
   */
  export type instance_role_permissionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which instance_role_permissions to delete
     */
    where?: instance_role_permissionsWhereInput
  }


  /**
   * instance_role_permissions without action
   */
  export type instance_role_permissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_role_permissions
     */
    select?: instance_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_role_permissionsInclude<ExtArgs> | null
  }



  /**
   * Model instance_roles
   */


  export type AggregateInstance_roles = {
    _count: Instance_rolesCountAggregateOutputType | null
    _avg: Instance_rolesAvgAggregateOutputType | null
    _sum: Instance_rolesSumAggregateOutputType | null
    _min: Instance_rolesMinAggregateOutputType | null
    _max: Instance_rolesMaxAggregateOutputType | null
  }

  export type Instance_rolesAvgAggregateOutputType = {
    id: number | null
  }

  export type Instance_rolesSumAggregateOutputType = {
    id: number | null
  }

  export type Instance_rolesMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
  }

  export type Instance_rolesMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
  }

  export type Instance_rolesCountAggregateOutputType = {
    created_at: number
    updated_at: number
    id: number
    name: number
    _all: number
  }


  export type Instance_rolesAvgAggregateInputType = {
    id?: true
  }

  export type Instance_rolesSumAggregateInputType = {
    id?: true
  }

  export type Instance_rolesMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
  }

  export type Instance_rolesMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
  }

  export type Instance_rolesCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    _all?: true
  }

  export type Instance_rolesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which instance_roles to aggregate.
     */
    where?: instance_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instance_roles to fetch.
     */
    orderBy?: instance_rolesOrderByWithRelationInput | instance_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: instance_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instance_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instance_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned instance_roles
    **/
    _count?: true | Instance_rolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Instance_rolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Instance_rolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Instance_rolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Instance_rolesMaxAggregateInputType
  }

  export type GetInstance_rolesAggregateType<T extends Instance_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateInstance_roles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstance_roles[P]>
      : GetScalarType<T[P], AggregateInstance_roles[P]>
  }




  export type instance_rolesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: instance_rolesWhereInput
    orderBy?: instance_rolesOrderByWithAggregationInput | instance_rolesOrderByWithAggregationInput[]
    by: Instance_rolesScalarFieldEnum[] | Instance_rolesScalarFieldEnum
    having?: instance_rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Instance_rolesCountAggregateInputType | true
    _avg?: Instance_rolesAvgAggregateInputType
    _sum?: Instance_rolesSumAggregateInputType
    _min?: Instance_rolesMinAggregateInputType
    _max?: Instance_rolesMaxAggregateInputType
  }


  export type Instance_rolesGroupByOutputType = {
    created_at: Date
    updated_at: Date
    id: number
    name: string
    _count: Instance_rolesCountAggregateOutputType | null
    _avg: Instance_rolesAvgAggregateOutputType | null
    _sum: Instance_rolesSumAggregateOutputType | null
    _min: Instance_rolesMinAggregateOutputType | null
    _max: Instance_rolesMaxAggregateOutputType | null
  }

  type GetInstance_rolesGroupByPayload<T extends instance_rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Instance_rolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Instance_rolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Instance_rolesGroupByOutputType[P]>
            : GetScalarType<T[P], Instance_rolesGroupByOutputType[P]>
        }
      >
    >


  export type instance_rolesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
    instance_role_permissions?: boolean | instance_roles$instance_role_permissionsArgs<ExtArgs>
    users?: boolean | instance_roles$usersArgs<ExtArgs>
    _count?: boolean | Instance_rolesCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["instance_roles"]>

  export type instance_rolesSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
  }

  export type instance_rolesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    instance_role_permissions?: boolean | instance_roles$instance_role_permissionsArgs<ExtArgs>
    users?: boolean | instance_roles$usersArgs<ExtArgs>
    _count?: boolean | Instance_rolesCountOutputTypeArgs<ExtArgs>
  }


  type instance_rolesGetPayload<S extends boolean | null | undefined | instance_rolesArgs> = $Types.GetResult<instance_rolesPayload, S>

  type instance_rolesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<instance_rolesFindManyArgs, 'select' | 'include'> & {
      select?: Instance_rolesCountAggregateInputType | true
    }

  export interface instance_rolesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['instance_roles'], meta: { name: 'instance_roles' } }
    /**
     * Find zero or one Instance_roles that matches the filter.
     * @param {instance_rolesFindUniqueArgs} args - Arguments to find a Instance_roles
     * @example
     * // Get one Instance_roles
     * const instance_roles = await prisma.instance_roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends instance_rolesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, instance_rolesFindUniqueArgs<ExtArgs>>
    ): Prisma__instance_rolesClient<$Types.GetResult<instance_rolesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Instance_roles that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {instance_rolesFindUniqueOrThrowArgs} args - Arguments to find a Instance_roles
     * @example
     * // Get one Instance_roles
     * const instance_roles = await prisma.instance_roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends instance_rolesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, instance_rolesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__instance_rolesClient<$Types.GetResult<instance_rolesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Instance_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instance_rolesFindFirstArgs} args - Arguments to find a Instance_roles
     * @example
     * // Get one Instance_roles
     * const instance_roles = await prisma.instance_roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends instance_rolesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, instance_rolesFindFirstArgs<ExtArgs>>
    ): Prisma__instance_rolesClient<$Types.GetResult<instance_rolesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Instance_roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instance_rolesFindFirstOrThrowArgs} args - Arguments to find a Instance_roles
     * @example
     * // Get one Instance_roles
     * const instance_roles = await prisma.instance_roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends instance_rolesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, instance_rolesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__instance_rolesClient<$Types.GetResult<instance_rolesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Instance_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instance_rolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instance_roles
     * const instance_roles = await prisma.instance_roles.findMany()
     * 
     * // Get first 10 Instance_roles
     * const instance_roles = await prisma.instance_roles.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const instance_rolesWithCreated_atOnly = await prisma.instance_roles.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends instance_rolesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, instance_rolesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<instance_rolesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Instance_roles.
     * @param {instance_rolesCreateArgs} args - Arguments to create a Instance_roles.
     * @example
     * // Create one Instance_roles
     * const Instance_roles = await prisma.instance_roles.create({
     *   data: {
     *     // ... data to create a Instance_roles
     *   }
     * })
     * 
    **/
    create<T extends instance_rolesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, instance_rolesCreateArgs<ExtArgs>>
    ): Prisma__instance_rolesClient<$Types.GetResult<instance_rolesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Instance_roles.
     *     @param {instance_rolesCreateManyArgs} args - Arguments to create many Instance_roles.
     *     @example
     *     // Create many Instance_roles
     *     const instance_roles = await prisma.instance_roles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends instance_rolesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, instance_rolesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Instance_roles.
     * @param {instance_rolesDeleteArgs} args - Arguments to delete one Instance_roles.
     * @example
     * // Delete one Instance_roles
     * const Instance_roles = await prisma.instance_roles.delete({
     *   where: {
     *     // ... filter to delete one Instance_roles
     *   }
     * })
     * 
    **/
    delete<T extends instance_rolesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, instance_rolesDeleteArgs<ExtArgs>>
    ): Prisma__instance_rolesClient<$Types.GetResult<instance_rolesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Instance_roles.
     * @param {instance_rolesUpdateArgs} args - Arguments to update one Instance_roles.
     * @example
     * // Update one Instance_roles
     * const instance_roles = await prisma.instance_roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends instance_rolesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, instance_rolesUpdateArgs<ExtArgs>>
    ): Prisma__instance_rolesClient<$Types.GetResult<instance_rolesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Instance_roles.
     * @param {instance_rolesDeleteManyArgs} args - Arguments to filter Instance_roles to delete.
     * @example
     * // Delete a few Instance_roles
     * const { count } = await prisma.instance_roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends instance_rolesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, instance_rolesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instance_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instance_rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instance_roles
     * const instance_roles = await prisma.instance_roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends instance_rolesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, instance_rolesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Instance_roles.
     * @param {instance_rolesUpsertArgs} args - Arguments to update or create a Instance_roles.
     * @example
     * // Update or create a Instance_roles
     * const instance_roles = await prisma.instance_roles.upsert({
     *   create: {
     *     // ... data to create a Instance_roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instance_roles we want to update
     *   }
     * })
    **/
    upsert<T extends instance_rolesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, instance_rolesUpsertArgs<ExtArgs>>
    ): Prisma__instance_rolesClient<$Types.GetResult<instance_rolesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Instance_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instance_rolesCountArgs} args - Arguments to filter Instance_roles to count.
     * @example
     * // Count the number of Instance_roles
     * const count = await prisma.instance_roles.count({
     *   where: {
     *     // ... the filter for the Instance_roles we want to count
     *   }
     * })
    **/
    count<T extends instance_rolesCountArgs>(
      args?: Subset<T, instance_rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Instance_rolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instance_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Instance_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Instance_rolesAggregateArgs>(args: Subset<T, Instance_rolesAggregateArgs>): Prisma.PrismaPromise<GetInstance_rolesAggregateType<T>>

    /**
     * Group by Instance_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instance_rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends instance_rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: instance_rolesGroupByArgs['orderBy'] }
        : { orderBy?: instance_rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, instance_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstance_rolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the instance_roles model
   */
  readonly fields: instance_rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for instance_roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__instance_rolesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    instance_role_permissions<T extends instance_roles$instance_role_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, instance_roles$instance_role_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<instance_role_permissionsPayload<ExtArgs>, T, 'findMany'>| Null>;

    users<T extends instance_roles$usersArgs<ExtArgs> = {}>(args?: Subset<T, instance_roles$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<usersPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the instance_roles model
   */ 
  interface instance_rolesFieldRefs {
    readonly created_at: FieldRef<"instance_roles", 'DateTime'>
    readonly updated_at: FieldRef<"instance_roles", 'DateTime'>
    readonly id: FieldRef<"instance_roles", 'Int'>
    readonly name: FieldRef<"instance_roles", 'String'>
  }
    

  // Custom InputTypes

  /**
   * instance_roles findUnique
   */
  export type instance_rolesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_roles
     */
    select?: instance_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_rolesInclude<ExtArgs> | null
    /**
     * Filter, which instance_roles to fetch.
     */
    where: instance_rolesWhereUniqueInput
  }


  /**
   * instance_roles findUniqueOrThrow
   */
  export type instance_rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_roles
     */
    select?: instance_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_rolesInclude<ExtArgs> | null
    /**
     * Filter, which instance_roles to fetch.
     */
    where: instance_rolesWhereUniqueInput
  }


  /**
   * instance_roles findFirst
   */
  export type instance_rolesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_roles
     */
    select?: instance_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_rolesInclude<ExtArgs> | null
    /**
     * Filter, which instance_roles to fetch.
     */
    where?: instance_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instance_roles to fetch.
     */
    orderBy?: instance_rolesOrderByWithRelationInput | instance_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for instance_roles.
     */
    cursor?: instance_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instance_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instance_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of instance_roles.
     */
    distinct?: Instance_rolesScalarFieldEnum | Instance_rolesScalarFieldEnum[]
  }


  /**
   * instance_roles findFirstOrThrow
   */
  export type instance_rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_roles
     */
    select?: instance_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_rolesInclude<ExtArgs> | null
    /**
     * Filter, which instance_roles to fetch.
     */
    where?: instance_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instance_roles to fetch.
     */
    orderBy?: instance_rolesOrderByWithRelationInput | instance_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for instance_roles.
     */
    cursor?: instance_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instance_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instance_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of instance_roles.
     */
    distinct?: Instance_rolesScalarFieldEnum | Instance_rolesScalarFieldEnum[]
  }


  /**
   * instance_roles findMany
   */
  export type instance_rolesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_roles
     */
    select?: instance_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_rolesInclude<ExtArgs> | null
    /**
     * Filter, which instance_roles to fetch.
     */
    where?: instance_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instance_roles to fetch.
     */
    orderBy?: instance_rolesOrderByWithRelationInput | instance_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing instance_roles.
     */
    cursor?: instance_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instance_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instance_roles.
     */
    skip?: number
    distinct?: Instance_rolesScalarFieldEnum | Instance_rolesScalarFieldEnum[]
  }


  /**
   * instance_roles create
   */
  export type instance_rolesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_roles
     */
    select?: instance_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a instance_roles.
     */
    data: XOR<instance_rolesCreateInput, instance_rolesUncheckedCreateInput>
  }


  /**
   * instance_roles createMany
   */
  export type instance_rolesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many instance_roles.
     */
    data: instance_rolesCreateManyInput | instance_rolesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * instance_roles update
   */
  export type instance_rolesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_roles
     */
    select?: instance_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a instance_roles.
     */
    data: XOR<instance_rolesUpdateInput, instance_rolesUncheckedUpdateInput>
    /**
     * Choose, which instance_roles to update.
     */
    where: instance_rolesWhereUniqueInput
  }


  /**
   * instance_roles updateMany
   */
  export type instance_rolesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update instance_roles.
     */
    data: XOR<instance_rolesUpdateManyMutationInput, instance_rolesUncheckedUpdateManyInput>
    /**
     * Filter which instance_roles to update
     */
    where?: instance_rolesWhereInput
  }


  /**
   * instance_roles upsert
   */
  export type instance_rolesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_roles
     */
    select?: instance_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the instance_roles to update in case it exists.
     */
    where: instance_rolesWhereUniqueInput
    /**
     * In case the instance_roles found by the `where` argument doesn't exist, create a new instance_roles with this data.
     */
    create: XOR<instance_rolesCreateInput, instance_rolesUncheckedCreateInput>
    /**
     * In case the instance_roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<instance_rolesUpdateInput, instance_rolesUncheckedUpdateInput>
  }


  /**
   * instance_roles delete
   */
  export type instance_rolesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_roles
     */
    select?: instance_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_rolesInclude<ExtArgs> | null
    /**
     * Filter which instance_roles to delete.
     */
    where: instance_rolesWhereUniqueInput
  }


  /**
   * instance_roles deleteMany
   */
  export type instance_rolesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which instance_roles to delete
     */
    where?: instance_rolesWhereInput
  }


  /**
   * instance_roles.instance_role_permissions
   */
  export type instance_roles$instance_role_permissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_role_permissions
     */
    select?: instance_role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_role_permissionsInclude<ExtArgs> | null
    where?: instance_role_permissionsWhereInput
    orderBy?: instance_role_permissionsOrderByWithRelationInput | instance_role_permissionsOrderByWithRelationInput[]
    cursor?: instance_role_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Instance_role_permissionsScalarFieldEnum | Instance_role_permissionsScalarFieldEnum[]
  }


  /**
   * instance_roles.users
   */
  export type instance_roles$usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }


  /**
   * instance_roles without action
   */
  export type instance_rolesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the instance_roles
     */
    select?: instance_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: instance_rolesInclude<ExtArgs> | null
  }



  /**
   * Model users
   */


  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    instance_role_id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
    instance_role_id: number | null
  }

  export type UsersMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
    image_url: string | null
    email: string | null
    auto_subscribe: boolean | null
    instance_role_id: number | null
  }

  export type UsersMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
    image_url: string | null
    email: string | null
    auto_subscribe: boolean | null
    instance_role_id: number | null
  }

  export type UsersCountAggregateOutputType = {
    created_at: number
    updated_at: number
    id: number
    name: number
    image_url: number
    email: number
    auto_subscribe: number
    instance_role_id: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    instance_role_id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    instance_role_id?: true
  }

  export type UsersMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    image_url?: true
    email?: true
    auto_subscribe?: true
    instance_role_id?: true
  }

  export type UsersMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    image_url?: true
    email?: true
    auto_subscribe?: true
    instance_role_id?: true
  }

  export type UsersCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    image_url?: true
    email?: true
    auto_subscribe?: true
    instance_role_id?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }


  export type UsersGroupByOutputType = {
    created_at: Date
    updated_at: Date
    id: number
    name: string
    image_url: string | null
    email: string
    auto_subscribe: boolean
    instance_role_id: number
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
    image_url?: boolean
    email?: boolean
    auto_subscribe?: boolean
    instance_role_id?: boolean
    user_bans?: boolean | users$user_bansArgs<ExtArgs>
    user_chapters?: boolean | users$user_chaptersArgs<ExtArgs>
    instance_role?: boolean | instance_rolesArgs<ExtArgs>
    user_events?: boolean | users$user_eventsArgs<ExtArgs>
    session?: boolean | users$sessionArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
    image_url?: boolean
    email?: boolean
    auto_subscribe?: boolean
    instance_role_id?: boolean
  }

  export type usersInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user_bans?: boolean | users$user_bansArgs<ExtArgs>
    user_chapters?: boolean | users$user_chaptersArgs<ExtArgs>
    instance_role?: boolean | instance_rolesArgs<ExtArgs>
    user_events?: boolean | users$user_eventsArgs<ExtArgs>
    session?: boolean | users$sessionArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeArgs<ExtArgs>
  }


  type usersGetPayload<S extends boolean | null | undefined | usersArgs> = $Types.GetResult<usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>
    ): Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>
    ): Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const usersWithCreated_atOnly = await prisma.users.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<usersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, usersCreateArgs<ExtArgs>>
    ): Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {usersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, usersDeleteArgs<ExtArgs>>
    ): Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpdateArgs<ExtArgs>>
    ): Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpsertArgs<ExtArgs>>
    ): Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user_bans<T extends users$user_bansArgs<ExtArgs> = {}>(args?: Subset<T, users$user_bansArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<user_bansPayload<ExtArgs>, T, 'findMany'>| Null>;

    user_chapters<T extends users$user_chaptersArgs<ExtArgs> = {}>(args?: Subset<T, users$user_chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<chapter_usersPayload<ExtArgs>, T, 'findMany'>| Null>;

    instance_role<T extends instance_rolesArgs<ExtArgs> = {}>(args?: Subset<T, instance_rolesArgs<ExtArgs>>): Prisma__instance_rolesClient<$Types.GetResult<instance_rolesPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    user_events<T extends users$user_eventsArgs<ExtArgs> = {}>(args?: Subset<T, users$user_eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<event_usersPayload<ExtArgs>, T, 'findMany'>| Null>;

    session<T extends users$sessionArgs<ExtArgs> = {}>(args?: Subset<T, users$sessionArgs<ExtArgs>>): Prisma__sessionsClient<$Types.GetResult<sessionsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
    readonly id: FieldRef<"users", 'Int'>
    readonly name: FieldRef<"users", 'String'>
    readonly image_url: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly auto_subscribe: FieldRef<"users", 'Boolean'>
    readonly instance_role_id: FieldRef<"users", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }


  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }


  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }


  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }


  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }


  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }


  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }


  /**
   * users.user_bans
   */
  export type users$user_bansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bans
     */
    select?: user_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bansInclude<ExtArgs> | null
    where?: user_bansWhereInput
    orderBy?: user_bansOrderByWithRelationInput | user_bansOrderByWithRelationInput[]
    cursor?: user_bansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_bansScalarFieldEnum | User_bansScalarFieldEnum[]
  }


  /**
   * users.user_chapters
   */
  export type users$user_chaptersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter_users
     */
    select?: chapter_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: chapter_usersInclude<ExtArgs> | null
    where?: chapter_usersWhereInput
    orderBy?: chapter_usersOrderByWithRelationInput | chapter_usersOrderByWithRelationInput[]
    cursor?: chapter_usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chapter_usersScalarFieldEnum | Chapter_usersScalarFieldEnum[]
  }


  /**
   * users.user_events
   */
  export type users$user_eventsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_users
     */
    select?: event_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: event_usersInclude<ExtArgs> | null
    where?: event_usersWhereInput
    orderBy?: event_usersOrderByWithRelationInput | event_usersOrderByWithRelationInput[]
    cursor?: event_usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Event_usersScalarFieldEnum | Event_usersScalarFieldEnum[]
  }


  /**
   * users.session
   */
  export type users$sessionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude<ExtArgs> | null
    where?: sessionsWhereInput
  }


  /**
   * users without action
   */
  export type usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
  }



  /**
   * Model venue_tags
   */


  export type AggregateVenue_tags = {
    _count: Venue_tagsCountAggregateOutputType | null
    _avg: Venue_tagsAvgAggregateOutputType | null
    _sum: Venue_tagsSumAggregateOutputType | null
    _min: Venue_tagsMinAggregateOutputType | null
    _max: Venue_tagsMaxAggregateOutputType | null
  }

  export type Venue_tagsAvgAggregateOutputType = {
    venue_id: number | null
    tag_id: number | null
  }

  export type Venue_tagsSumAggregateOutputType = {
    venue_id: number | null
    tag_id: number | null
  }

  export type Venue_tagsMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    venue_id: number | null
    tag_id: number | null
  }

  export type Venue_tagsMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    venue_id: number | null
    tag_id: number | null
  }

  export type Venue_tagsCountAggregateOutputType = {
    created_at: number
    updated_at: number
    venue_id: number
    tag_id: number
    _all: number
  }


  export type Venue_tagsAvgAggregateInputType = {
    venue_id?: true
    tag_id?: true
  }

  export type Venue_tagsSumAggregateInputType = {
    venue_id?: true
    tag_id?: true
  }

  export type Venue_tagsMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    venue_id?: true
    tag_id?: true
  }

  export type Venue_tagsMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    venue_id?: true
    tag_id?: true
  }

  export type Venue_tagsCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    venue_id?: true
    tag_id?: true
    _all?: true
  }

  export type Venue_tagsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which venue_tags to aggregate.
     */
    where?: venue_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of venue_tags to fetch.
     */
    orderBy?: venue_tagsOrderByWithRelationInput | venue_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: venue_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` venue_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` venue_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned venue_tags
    **/
    _count?: true | Venue_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Venue_tagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Venue_tagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Venue_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Venue_tagsMaxAggregateInputType
  }

  export type GetVenue_tagsAggregateType<T extends Venue_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregateVenue_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenue_tags[P]>
      : GetScalarType<T[P], AggregateVenue_tags[P]>
  }




  export type venue_tagsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: venue_tagsWhereInput
    orderBy?: venue_tagsOrderByWithAggregationInput | venue_tagsOrderByWithAggregationInput[]
    by: Venue_tagsScalarFieldEnum[] | Venue_tagsScalarFieldEnum
    having?: venue_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Venue_tagsCountAggregateInputType | true
    _avg?: Venue_tagsAvgAggregateInputType
    _sum?: Venue_tagsSumAggregateInputType
    _min?: Venue_tagsMinAggregateInputType
    _max?: Venue_tagsMaxAggregateInputType
  }


  export type Venue_tagsGroupByOutputType = {
    created_at: Date
    updated_at: Date
    venue_id: number
    tag_id: number
    _count: Venue_tagsCountAggregateOutputType | null
    _avg: Venue_tagsAvgAggregateOutputType | null
    _sum: Venue_tagsSumAggregateOutputType | null
    _min: Venue_tagsMinAggregateOutputType | null
    _max: Venue_tagsMaxAggregateOutputType | null
  }

  type GetVenue_tagsGroupByPayload<T extends venue_tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Venue_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Venue_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Venue_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Venue_tagsGroupByOutputType[P]>
        }
      >
    >


  export type venue_tagsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    venue_id?: boolean
    tag_id?: boolean
    venue?: boolean | venuesArgs<ExtArgs>
    tag?: boolean | tagsArgs<ExtArgs>
  }, ExtArgs["result"]["venue_tags"]>

  export type venue_tagsSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    venue_id?: boolean
    tag_id?: boolean
  }

  export type venue_tagsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    venue?: boolean | venuesArgs<ExtArgs>
    tag?: boolean | tagsArgs<ExtArgs>
  }


  type venue_tagsGetPayload<S extends boolean | null | undefined | venue_tagsArgs> = $Types.GetResult<venue_tagsPayload, S>

  type venue_tagsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<venue_tagsFindManyArgs, 'select' | 'include'> & {
      select?: Venue_tagsCountAggregateInputType | true
    }

  export interface venue_tagsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['venue_tags'], meta: { name: 'venue_tags' } }
    /**
     * Find zero or one Venue_tags that matches the filter.
     * @param {venue_tagsFindUniqueArgs} args - Arguments to find a Venue_tags
     * @example
     * // Get one Venue_tags
     * const venue_tags = await prisma.venue_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends venue_tagsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, venue_tagsFindUniqueArgs<ExtArgs>>
    ): Prisma__venue_tagsClient<$Types.GetResult<venue_tagsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Venue_tags that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {venue_tagsFindUniqueOrThrowArgs} args - Arguments to find a Venue_tags
     * @example
     * // Get one Venue_tags
     * const venue_tags = await prisma.venue_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends venue_tagsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, venue_tagsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__venue_tagsClient<$Types.GetResult<venue_tagsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Venue_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {venue_tagsFindFirstArgs} args - Arguments to find a Venue_tags
     * @example
     * // Get one Venue_tags
     * const venue_tags = await prisma.venue_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends venue_tagsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, venue_tagsFindFirstArgs<ExtArgs>>
    ): Prisma__venue_tagsClient<$Types.GetResult<venue_tagsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Venue_tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {venue_tagsFindFirstOrThrowArgs} args - Arguments to find a Venue_tags
     * @example
     * // Get one Venue_tags
     * const venue_tags = await prisma.venue_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends venue_tagsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, venue_tagsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__venue_tagsClient<$Types.GetResult<venue_tagsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Venue_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {venue_tagsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Venue_tags
     * const venue_tags = await prisma.venue_tags.findMany()
     * 
     * // Get first 10 Venue_tags
     * const venue_tags = await prisma.venue_tags.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const venue_tagsWithCreated_atOnly = await prisma.venue_tags.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends venue_tagsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, venue_tagsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<venue_tagsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Venue_tags.
     * @param {venue_tagsCreateArgs} args - Arguments to create a Venue_tags.
     * @example
     * // Create one Venue_tags
     * const Venue_tags = await prisma.venue_tags.create({
     *   data: {
     *     // ... data to create a Venue_tags
     *   }
     * })
     * 
    **/
    create<T extends venue_tagsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, venue_tagsCreateArgs<ExtArgs>>
    ): Prisma__venue_tagsClient<$Types.GetResult<venue_tagsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Venue_tags.
     *     @param {venue_tagsCreateManyArgs} args - Arguments to create many Venue_tags.
     *     @example
     *     // Create many Venue_tags
     *     const venue_tags = await prisma.venue_tags.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends venue_tagsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, venue_tagsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Venue_tags.
     * @param {venue_tagsDeleteArgs} args - Arguments to delete one Venue_tags.
     * @example
     * // Delete one Venue_tags
     * const Venue_tags = await prisma.venue_tags.delete({
     *   where: {
     *     // ... filter to delete one Venue_tags
     *   }
     * })
     * 
    **/
    delete<T extends venue_tagsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, venue_tagsDeleteArgs<ExtArgs>>
    ): Prisma__venue_tagsClient<$Types.GetResult<venue_tagsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Venue_tags.
     * @param {venue_tagsUpdateArgs} args - Arguments to update one Venue_tags.
     * @example
     * // Update one Venue_tags
     * const venue_tags = await prisma.venue_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends venue_tagsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, venue_tagsUpdateArgs<ExtArgs>>
    ): Prisma__venue_tagsClient<$Types.GetResult<venue_tagsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Venue_tags.
     * @param {venue_tagsDeleteManyArgs} args - Arguments to filter Venue_tags to delete.
     * @example
     * // Delete a few Venue_tags
     * const { count } = await prisma.venue_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends venue_tagsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, venue_tagsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Venue_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {venue_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Venue_tags
     * const venue_tags = await prisma.venue_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends venue_tagsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, venue_tagsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Venue_tags.
     * @param {venue_tagsUpsertArgs} args - Arguments to update or create a Venue_tags.
     * @example
     * // Update or create a Venue_tags
     * const venue_tags = await prisma.venue_tags.upsert({
     *   create: {
     *     // ... data to create a Venue_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Venue_tags we want to update
     *   }
     * })
    **/
    upsert<T extends venue_tagsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, venue_tagsUpsertArgs<ExtArgs>>
    ): Prisma__venue_tagsClient<$Types.GetResult<venue_tagsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Venue_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {venue_tagsCountArgs} args - Arguments to filter Venue_tags to count.
     * @example
     * // Count the number of Venue_tags
     * const count = await prisma.venue_tags.count({
     *   where: {
     *     // ... the filter for the Venue_tags we want to count
     *   }
     * })
    **/
    count<T extends venue_tagsCountArgs>(
      args?: Subset<T, venue_tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Venue_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Venue_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Venue_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Venue_tagsAggregateArgs>(args: Subset<T, Venue_tagsAggregateArgs>): Prisma.PrismaPromise<GetVenue_tagsAggregateType<T>>

    /**
     * Group by Venue_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {venue_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends venue_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: venue_tagsGroupByArgs['orderBy'] }
        : { orderBy?: venue_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, venue_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVenue_tagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the venue_tags model
   */
  readonly fields: venue_tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for venue_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__venue_tagsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    venue<T extends venuesArgs<ExtArgs> = {}>(args?: Subset<T, venuesArgs<ExtArgs>>): Prisma__venuesClient<$Types.GetResult<venuesPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    tag<T extends tagsArgs<ExtArgs> = {}>(args?: Subset<T, tagsArgs<ExtArgs>>): Prisma__tagsClient<$Types.GetResult<tagsPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the venue_tags model
   */ 
  interface venue_tagsFieldRefs {
    readonly created_at: FieldRef<"venue_tags", 'DateTime'>
    readonly updated_at: FieldRef<"venue_tags", 'DateTime'>
    readonly venue_id: FieldRef<"venue_tags", 'Int'>
    readonly tag_id: FieldRef<"venue_tags", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * venue_tags findUnique
   */
  export type venue_tagsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venue_tags
     */
    select?: venue_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venue_tagsInclude<ExtArgs> | null
    /**
     * Filter, which venue_tags to fetch.
     */
    where: venue_tagsWhereUniqueInput
  }


  /**
   * venue_tags findUniqueOrThrow
   */
  export type venue_tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venue_tags
     */
    select?: venue_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venue_tagsInclude<ExtArgs> | null
    /**
     * Filter, which venue_tags to fetch.
     */
    where: venue_tagsWhereUniqueInput
  }


  /**
   * venue_tags findFirst
   */
  export type venue_tagsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venue_tags
     */
    select?: venue_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venue_tagsInclude<ExtArgs> | null
    /**
     * Filter, which venue_tags to fetch.
     */
    where?: venue_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of venue_tags to fetch.
     */
    orderBy?: venue_tagsOrderByWithRelationInput | venue_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for venue_tags.
     */
    cursor?: venue_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` venue_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` venue_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of venue_tags.
     */
    distinct?: Venue_tagsScalarFieldEnum | Venue_tagsScalarFieldEnum[]
  }


  /**
   * venue_tags findFirstOrThrow
   */
  export type venue_tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venue_tags
     */
    select?: venue_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venue_tagsInclude<ExtArgs> | null
    /**
     * Filter, which venue_tags to fetch.
     */
    where?: venue_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of venue_tags to fetch.
     */
    orderBy?: venue_tagsOrderByWithRelationInput | venue_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for venue_tags.
     */
    cursor?: venue_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` venue_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` venue_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of venue_tags.
     */
    distinct?: Venue_tagsScalarFieldEnum | Venue_tagsScalarFieldEnum[]
  }


  /**
   * venue_tags findMany
   */
  export type venue_tagsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venue_tags
     */
    select?: venue_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venue_tagsInclude<ExtArgs> | null
    /**
     * Filter, which venue_tags to fetch.
     */
    where?: venue_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of venue_tags to fetch.
     */
    orderBy?: venue_tagsOrderByWithRelationInput | venue_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing venue_tags.
     */
    cursor?: venue_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` venue_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` venue_tags.
     */
    skip?: number
    distinct?: Venue_tagsScalarFieldEnum | Venue_tagsScalarFieldEnum[]
  }


  /**
   * venue_tags create
   */
  export type venue_tagsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venue_tags
     */
    select?: venue_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venue_tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a venue_tags.
     */
    data: XOR<venue_tagsCreateInput, venue_tagsUncheckedCreateInput>
  }


  /**
   * venue_tags createMany
   */
  export type venue_tagsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many venue_tags.
     */
    data: venue_tagsCreateManyInput | venue_tagsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * venue_tags update
   */
  export type venue_tagsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venue_tags
     */
    select?: venue_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venue_tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a venue_tags.
     */
    data: XOR<venue_tagsUpdateInput, venue_tagsUncheckedUpdateInput>
    /**
     * Choose, which venue_tags to update.
     */
    where: venue_tagsWhereUniqueInput
  }


  /**
   * venue_tags updateMany
   */
  export type venue_tagsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update venue_tags.
     */
    data: XOR<venue_tagsUpdateManyMutationInput, venue_tagsUncheckedUpdateManyInput>
    /**
     * Filter which venue_tags to update
     */
    where?: venue_tagsWhereInput
  }


  /**
   * venue_tags upsert
   */
  export type venue_tagsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venue_tags
     */
    select?: venue_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venue_tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the venue_tags to update in case it exists.
     */
    where: venue_tagsWhereUniqueInput
    /**
     * In case the venue_tags found by the `where` argument doesn't exist, create a new venue_tags with this data.
     */
    create: XOR<venue_tagsCreateInput, venue_tagsUncheckedCreateInput>
    /**
     * In case the venue_tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<venue_tagsUpdateInput, venue_tagsUncheckedUpdateInput>
  }


  /**
   * venue_tags delete
   */
  export type venue_tagsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venue_tags
     */
    select?: venue_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venue_tagsInclude<ExtArgs> | null
    /**
     * Filter which venue_tags to delete.
     */
    where: venue_tagsWhereUniqueInput
  }


  /**
   * venue_tags deleteMany
   */
  export type venue_tagsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which venue_tags to delete
     */
    where?: venue_tagsWhereInput
  }


  /**
   * venue_tags without action
   */
  export type venue_tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venue_tags
     */
    select?: venue_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venue_tagsInclude<ExtArgs> | null
  }



  /**
   * Model venues
   */


  export type AggregateVenues = {
    _count: VenuesCountAggregateOutputType | null
    _avg: VenuesAvgAggregateOutputType | null
    _sum: VenuesSumAggregateOutputType | null
    _min: VenuesMinAggregateOutputType | null
    _max: VenuesMaxAggregateOutputType | null
  }

  export type VenuesAvgAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
    chapter_id: number | null
  }

  export type VenuesSumAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
    chapter_id: number | null
  }

  export type VenuesMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
    street_address: string | null
    city: string | null
    postal_code: string | null
    region: string | null
    country: string | null
    latitude: number | null
    longitude: number | null
    chapter_id: number | null
  }

  export type VenuesMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    id: number | null
    name: string | null
    street_address: string | null
    city: string | null
    postal_code: string | null
    region: string | null
    country: string | null
    latitude: number | null
    longitude: number | null
    chapter_id: number | null
  }

  export type VenuesCountAggregateOutputType = {
    created_at: number
    updated_at: number
    id: number
    name: number
    street_address: number
    city: number
    postal_code: number
    region: number
    country: number
    latitude: number
    longitude: number
    chapter_id: number
    _all: number
  }


  export type VenuesAvgAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    chapter_id?: true
  }

  export type VenuesSumAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    chapter_id?: true
  }

  export type VenuesMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    street_address?: true
    city?: true
    postal_code?: true
    region?: true
    country?: true
    latitude?: true
    longitude?: true
    chapter_id?: true
  }

  export type VenuesMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    street_address?: true
    city?: true
    postal_code?: true
    region?: true
    country?: true
    latitude?: true
    longitude?: true
    chapter_id?: true
  }

  export type VenuesCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    id?: true
    name?: true
    street_address?: true
    city?: true
    postal_code?: true
    region?: true
    country?: true
    latitude?: true
    longitude?: true
    chapter_id?: true
    _all?: true
  }

  export type VenuesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which venues to aggregate.
     */
    where?: venuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of venues to fetch.
     */
    orderBy?: venuesOrderByWithRelationInput | venuesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: venuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned venues
    **/
    _count?: true | VenuesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VenuesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VenuesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VenuesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VenuesMaxAggregateInputType
  }

  export type GetVenuesAggregateType<T extends VenuesAggregateArgs> = {
        [P in keyof T & keyof AggregateVenues]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenues[P]>
      : GetScalarType<T[P], AggregateVenues[P]>
  }




  export type venuesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: venuesWhereInput
    orderBy?: venuesOrderByWithAggregationInput | venuesOrderByWithAggregationInput[]
    by: VenuesScalarFieldEnum[] | VenuesScalarFieldEnum
    having?: venuesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VenuesCountAggregateInputType | true
    _avg?: VenuesAvgAggregateInputType
    _sum?: VenuesSumAggregateInputType
    _min?: VenuesMinAggregateInputType
    _max?: VenuesMaxAggregateInputType
  }


  export type VenuesGroupByOutputType = {
    created_at: Date
    updated_at: Date
    id: number
    name: string
    street_address: string | null
    city: string
    postal_code: string
    region: string
    country: string
    latitude: number | null
    longitude: number | null
    chapter_id: number
    _count: VenuesCountAggregateOutputType | null
    _avg: VenuesAvgAggregateOutputType | null
    _sum: VenuesSumAggregateOutputType | null
    _min: VenuesMinAggregateOutputType | null
    _max: VenuesMaxAggregateOutputType | null
  }

  type GetVenuesGroupByPayload<T extends venuesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VenuesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VenuesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VenuesGroupByOutputType[P]>
            : GetScalarType<T[P], VenuesGroupByOutputType[P]>
        }
      >
    >


  export type venuesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
    street_address?: boolean
    city?: boolean
    postal_code?: boolean
    region?: boolean
    country?: boolean
    latitude?: boolean
    longitude?: boolean
    chapter_id?: boolean
    events?: boolean | venues$eventsArgs<ExtArgs>
    venue_tags?: boolean | venues$venue_tagsArgs<ExtArgs>
    chapter?: boolean | chaptersArgs<ExtArgs>
    _count?: boolean | VenuesCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["venues"]>

  export type venuesSelectScalar = {
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    name?: boolean
    street_address?: boolean
    city?: boolean
    postal_code?: boolean
    region?: boolean
    country?: boolean
    latitude?: boolean
    longitude?: boolean
    chapter_id?: boolean
  }

  export type venuesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    events?: boolean | venues$eventsArgs<ExtArgs>
    venue_tags?: boolean | venues$venue_tagsArgs<ExtArgs>
    chapter?: boolean | chaptersArgs<ExtArgs>
    _count?: boolean | VenuesCountOutputTypeArgs<ExtArgs>
  }


  type venuesGetPayload<S extends boolean | null | undefined | venuesArgs> = $Types.GetResult<venuesPayload, S>

  type venuesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<venuesFindManyArgs, 'select' | 'include'> & {
      select?: VenuesCountAggregateInputType | true
    }

  export interface venuesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['venues'], meta: { name: 'venues' } }
    /**
     * Find zero or one Venues that matches the filter.
     * @param {venuesFindUniqueArgs} args - Arguments to find a Venues
     * @example
     * // Get one Venues
     * const venues = await prisma.venues.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends venuesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, venuesFindUniqueArgs<ExtArgs>>
    ): Prisma__venuesClient<$Types.GetResult<venuesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Venues that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {venuesFindUniqueOrThrowArgs} args - Arguments to find a Venues
     * @example
     * // Get one Venues
     * const venues = await prisma.venues.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends venuesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, venuesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__venuesClient<$Types.GetResult<venuesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Venues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {venuesFindFirstArgs} args - Arguments to find a Venues
     * @example
     * // Get one Venues
     * const venues = await prisma.venues.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends venuesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, venuesFindFirstArgs<ExtArgs>>
    ): Prisma__venuesClient<$Types.GetResult<venuesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Venues that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {venuesFindFirstOrThrowArgs} args - Arguments to find a Venues
     * @example
     * // Get one Venues
     * const venues = await prisma.venues.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends venuesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, venuesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__venuesClient<$Types.GetResult<venuesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Venues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {venuesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Venues
     * const venues = await prisma.venues.findMany()
     * 
     * // Get first 10 Venues
     * const venues = await prisma.venues.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const venuesWithCreated_atOnly = await prisma.venues.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends venuesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, venuesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<venuesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Venues.
     * @param {venuesCreateArgs} args - Arguments to create a Venues.
     * @example
     * // Create one Venues
     * const Venues = await prisma.venues.create({
     *   data: {
     *     // ... data to create a Venues
     *   }
     * })
     * 
    **/
    create<T extends venuesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, venuesCreateArgs<ExtArgs>>
    ): Prisma__venuesClient<$Types.GetResult<venuesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Venues.
     *     @param {venuesCreateManyArgs} args - Arguments to create many Venues.
     *     @example
     *     // Create many Venues
     *     const venues = await prisma.venues.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends venuesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, venuesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Venues.
     * @param {venuesDeleteArgs} args - Arguments to delete one Venues.
     * @example
     * // Delete one Venues
     * const Venues = await prisma.venues.delete({
     *   where: {
     *     // ... filter to delete one Venues
     *   }
     * })
     * 
    **/
    delete<T extends venuesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, venuesDeleteArgs<ExtArgs>>
    ): Prisma__venuesClient<$Types.GetResult<venuesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Venues.
     * @param {venuesUpdateArgs} args - Arguments to update one Venues.
     * @example
     * // Update one Venues
     * const venues = await prisma.venues.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends venuesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, venuesUpdateArgs<ExtArgs>>
    ): Prisma__venuesClient<$Types.GetResult<venuesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Venues.
     * @param {venuesDeleteManyArgs} args - Arguments to filter Venues to delete.
     * @example
     * // Delete a few Venues
     * const { count } = await prisma.venues.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends venuesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, venuesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {venuesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Venues
     * const venues = await prisma.venues.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends venuesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, venuesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Venues.
     * @param {venuesUpsertArgs} args - Arguments to update or create a Venues.
     * @example
     * // Update or create a Venues
     * const venues = await prisma.venues.upsert({
     *   create: {
     *     // ... data to create a Venues
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Venues we want to update
     *   }
     * })
    **/
    upsert<T extends venuesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, venuesUpsertArgs<ExtArgs>>
    ): Prisma__venuesClient<$Types.GetResult<venuesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {venuesCountArgs} args - Arguments to filter Venues to count.
     * @example
     * // Count the number of Venues
     * const count = await prisma.venues.count({
     *   where: {
     *     // ... the filter for the Venues we want to count
     *   }
     * })
    **/
    count<T extends venuesCountArgs>(
      args?: Subset<T, venuesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VenuesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenuesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VenuesAggregateArgs>(args: Subset<T, VenuesAggregateArgs>): Prisma.PrismaPromise<GetVenuesAggregateType<T>>

    /**
     * Group by Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {venuesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends venuesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: venuesGroupByArgs['orderBy'] }
        : { orderBy?: venuesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, venuesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVenuesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the venues model
   */
  readonly fields: venuesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for venues.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__venuesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    events<T extends venues$eventsArgs<ExtArgs> = {}>(args?: Subset<T, venues$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<eventsPayload<ExtArgs>, T, 'findMany'>| Null>;

    venue_tags<T extends venues$venue_tagsArgs<ExtArgs> = {}>(args?: Subset<T, venues$venue_tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<venue_tagsPayload<ExtArgs>, T, 'findMany'>| Null>;

    chapter<T extends chaptersArgs<ExtArgs> = {}>(args?: Subset<T, chaptersArgs<ExtArgs>>): Prisma__chaptersClient<$Types.GetResult<chaptersPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the venues model
   */ 
  interface venuesFieldRefs {
    readonly created_at: FieldRef<"venues", 'DateTime'>
    readonly updated_at: FieldRef<"venues", 'DateTime'>
    readonly id: FieldRef<"venues", 'Int'>
    readonly name: FieldRef<"venues", 'String'>
    readonly street_address: FieldRef<"venues", 'String'>
    readonly city: FieldRef<"venues", 'String'>
    readonly postal_code: FieldRef<"venues", 'String'>
    readonly region: FieldRef<"venues", 'String'>
    readonly country: FieldRef<"venues", 'String'>
    readonly latitude: FieldRef<"venues", 'Float'>
    readonly longitude: FieldRef<"venues", 'Float'>
    readonly chapter_id: FieldRef<"venues", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * venues findUnique
   */
  export type venuesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venues
     */
    select?: venuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venuesInclude<ExtArgs> | null
    /**
     * Filter, which venues to fetch.
     */
    where: venuesWhereUniqueInput
  }


  /**
   * venues findUniqueOrThrow
   */
  export type venuesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venues
     */
    select?: venuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venuesInclude<ExtArgs> | null
    /**
     * Filter, which venues to fetch.
     */
    where: venuesWhereUniqueInput
  }


  /**
   * venues findFirst
   */
  export type venuesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venues
     */
    select?: venuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venuesInclude<ExtArgs> | null
    /**
     * Filter, which venues to fetch.
     */
    where?: venuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of venues to fetch.
     */
    orderBy?: venuesOrderByWithRelationInput | venuesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for venues.
     */
    cursor?: venuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of venues.
     */
    distinct?: VenuesScalarFieldEnum | VenuesScalarFieldEnum[]
  }


  /**
   * venues findFirstOrThrow
   */
  export type venuesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venues
     */
    select?: venuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venuesInclude<ExtArgs> | null
    /**
     * Filter, which venues to fetch.
     */
    where?: venuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of venues to fetch.
     */
    orderBy?: venuesOrderByWithRelationInput | venuesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for venues.
     */
    cursor?: venuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of venues.
     */
    distinct?: VenuesScalarFieldEnum | VenuesScalarFieldEnum[]
  }


  /**
   * venues findMany
   */
  export type venuesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venues
     */
    select?: venuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venuesInclude<ExtArgs> | null
    /**
     * Filter, which venues to fetch.
     */
    where?: venuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of venues to fetch.
     */
    orderBy?: venuesOrderByWithRelationInput | venuesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing venues.
     */
    cursor?: venuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` venues.
     */
    skip?: number
    distinct?: VenuesScalarFieldEnum | VenuesScalarFieldEnum[]
  }


  /**
   * venues create
   */
  export type venuesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venues
     */
    select?: venuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venuesInclude<ExtArgs> | null
    /**
     * The data needed to create a venues.
     */
    data: XOR<venuesCreateInput, venuesUncheckedCreateInput>
  }


  /**
   * venues createMany
   */
  export type venuesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many venues.
     */
    data: venuesCreateManyInput | venuesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * venues update
   */
  export type venuesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venues
     */
    select?: venuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venuesInclude<ExtArgs> | null
    /**
     * The data needed to update a venues.
     */
    data: XOR<venuesUpdateInput, venuesUncheckedUpdateInput>
    /**
     * Choose, which venues to update.
     */
    where: venuesWhereUniqueInput
  }


  /**
   * venues updateMany
   */
  export type venuesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update venues.
     */
    data: XOR<venuesUpdateManyMutationInput, venuesUncheckedUpdateManyInput>
    /**
     * Filter which venues to update
     */
    where?: venuesWhereInput
  }


  /**
   * venues upsert
   */
  export type venuesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venues
     */
    select?: venuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venuesInclude<ExtArgs> | null
    /**
     * The filter to search for the venues to update in case it exists.
     */
    where: venuesWhereUniqueInput
    /**
     * In case the venues found by the `where` argument doesn't exist, create a new venues with this data.
     */
    create: XOR<venuesCreateInput, venuesUncheckedCreateInput>
    /**
     * In case the venues was found with the provided `where` argument, update it with this data.
     */
    update: XOR<venuesUpdateInput, venuesUncheckedUpdateInput>
  }


  /**
   * venues delete
   */
  export type venuesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venues
     */
    select?: venuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venuesInclude<ExtArgs> | null
    /**
     * Filter which venues to delete.
     */
    where: venuesWhereUniqueInput
  }


  /**
   * venues deleteMany
   */
  export type venuesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which venues to delete
     */
    where?: venuesWhereInput
  }


  /**
   * venues.events
   */
  export type venues$eventsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: eventsInclude<ExtArgs> | null
    where?: eventsWhereInput
    orderBy?: eventsOrderByWithRelationInput | eventsOrderByWithRelationInput[]
    cursor?: eventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }


  /**
   * venues.venue_tags
   */
  export type venues$venue_tagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venue_tags
     */
    select?: venue_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venue_tagsInclude<ExtArgs> | null
    where?: venue_tagsWhereInput
    orderBy?: venue_tagsOrderByWithRelationInput | venue_tagsOrderByWithRelationInput[]
    cursor?: venue_tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Venue_tagsScalarFieldEnum | Venue_tagsScalarFieldEnum[]
  }


  /**
   * venues without action
   */
  export type venuesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the venues
     */
    select?: venuesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: venuesInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ChaptersScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    city: 'city',
    region: 'region',
    country: 'country',
    logo_url: 'logo_url',
    banner_url: 'banner_url',
    calendar_id: 'calendar_id',
    chat_url: 'chat_url',
    creator_id: 'creator_id'
  };

  export type ChaptersScalarFieldEnum = (typeof ChaptersScalarFieldEnum)[keyof typeof ChaptersScalarFieldEnum]


  export const SessionsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id'
  };

  export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


  export const Google_tokensScalarFieldEnum: {
    id: 'id',
    email: 'email',
    access_token: 'access_token',
    refresh_token: 'refresh_token',
    expiry_date: 'expiry_date',
    is_valid: 'is_valid'
  };

  export type Google_tokensScalarFieldEnum = (typeof Google_tokensScalarFieldEnum)[keyof typeof Google_tokensScalarFieldEnum]


  export const Chapter_usersScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    joined_date: 'joined_date',
    user_id: 'user_id',
    chapter_id: 'chapter_id',
    chapter_role_id: 'chapter_role_id',
    subscribed: 'subscribed'
  };

  export type Chapter_usersScalarFieldEnum = (typeof Chapter_usersScalarFieldEnum)[keyof typeof Chapter_usersScalarFieldEnum]


  export const Chapter_rolesScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    id: 'id',
    name: 'name'
  };

  export type Chapter_rolesScalarFieldEnum = (typeof Chapter_rolesScalarFieldEnum)[keyof typeof Chapter_rolesScalarFieldEnum]


  export const Chapter_role_permissionsScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    chapter_role_id: 'chapter_role_id',
    chapter_permissions_id: 'chapter_permissions_id'
  };

  export type Chapter_role_permissionsScalarFieldEnum = (typeof Chapter_role_permissionsScalarFieldEnum)[keyof typeof Chapter_role_permissionsScalarFieldEnum]


  export const Chapter_permissionsScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    id: 'id',
    name: 'name'
  };

  export type Chapter_permissionsScalarFieldEnum = (typeof Chapter_permissionsScalarFieldEnum)[keyof typeof Chapter_permissionsScalarFieldEnum]


  export const Chapter_tagsScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    chapter_id: 'chapter_id',
    tag_id: 'tag_id'
  };

  export type Chapter_tagsScalarFieldEnum = (typeof Chapter_tagsScalarFieldEnum)[keyof typeof Chapter_tagsScalarFieldEnum]


  export const Event_sponsorsScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    sponsor_id: 'sponsor_id',
    event_id: 'event_id'
  };

  export type Event_sponsorsScalarFieldEnum = (typeof Event_sponsorsScalarFieldEnum)[keyof typeof Event_sponsorsScalarFieldEnum]


  export const Event_tagsScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    event_id: 'event_id',
    tag_id: 'tag_id'
  };

  export type Event_tagsScalarFieldEnum = (typeof Event_tagsScalarFieldEnum)[keyof typeof Event_tagsScalarFieldEnum]


  export const EventsScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    id: 'id',
    name: 'name',
    description: 'description',
    url: 'url',
    streaming_url: 'streaming_url',
    venue_type: 'venue_type',
    start_at: 'start_at',
    ends_at: 'ends_at',
    canceled: 'canceled',
    capacity: 'capacity',
    invite_only: 'invite_only',
    image_url: 'image_url',
    venue_id: 'venue_id',
    chapter_id: 'chapter_id',
    calendar_event_id: 'calendar_event_id'
  };

  export type EventsScalarFieldEnum = (typeof EventsScalarFieldEnum)[keyof typeof EventsScalarFieldEnum]


  export const Event_rolesScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    id: 'id',
    name: 'name'
  };

  export type Event_rolesScalarFieldEnum = (typeof Event_rolesScalarFieldEnum)[keyof typeof Event_rolesScalarFieldEnum]


  export const Event_role_permissionsScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    event_role_id: 'event_role_id',
    event_permission_id: 'event_permission_id'
  };

  export type Event_role_permissionsScalarFieldEnum = (typeof Event_role_permissionsScalarFieldEnum)[keyof typeof Event_role_permissionsScalarFieldEnum]


  export const Event_permissionsScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    id: 'id',
    name: 'name'
  };

  export type Event_permissionsScalarFieldEnum = (typeof Event_permissionsScalarFieldEnum)[keyof typeof Event_permissionsScalarFieldEnum]


  export const Event_usersScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    joined_date: 'joined_date',
    user_id: 'user_id',
    event_id: 'event_id',
    event_role_id: 'event_role_id',
    attendance_id: 'attendance_id',
    subscribed: 'subscribed',
    title: 'title'
  };

  export type Event_usersScalarFieldEnum = (typeof Event_usersScalarFieldEnum)[keyof typeof Event_usersScalarFieldEnum]


  export const Event_remindersScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    user_id: 'user_id',
    event_id: 'event_id',
    remind_at: 'remind_at',
    notifying: 'notifying'
  };

  export type Event_remindersScalarFieldEnum = (typeof Event_remindersScalarFieldEnum)[keyof typeof Event_remindersScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    id: 'id',
    name: 'name'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const SponsorsScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    id: 'id',
    name: 'name',
    website: 'website',
    logo_path: 'logo_path',
    type: 'type'
  };

  export type SponsorsScalarFieldEnum = (typeof SponsorsScalarFieldEnum)[keyof typeof SponsorsScalarFieldEnum]


  export const TagsScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    id: 'id',
    name: 'name'
  };

  export type TagsScalarFieldEnum = (typeof TagsScalarFieldEnum)[keyof typeof TagsScalarFieldEnum]


  export const User_bansScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    user_id: 'user_id',
    chapter_id: 'chapter_id'
  };

  export type User_bansScalarFieldEnum = (typeof User_bansScalarFieldEnum)[keyof typeof User_bansScalarFieldEnum]


  export const Instance_permissionsScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    id: 'id',
    name: 'name'
  };

  export type Instance_permissionsScalarFieldEnum = (typeof Instance_permissionsScalarFieldEnum)[keyof typeof Instance_permissionsScalarFieldEnum]


  export const Instance_role_permissionsScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    instance_role_id: 'instance_role_id',
    instance_permission_id: 'instance_permission_id'
  };

  export type Instance_role_permissionsScalarFieldEnum = (typeof Instance_role_permissionsScalarFieldEnum)[keyof typeof Instance_role_permissionsScalarFieldEnum]


  export const Instance_rolesScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    id: 'id',
    name: 'name'
  };

  export type Instance_rolesScalarFieldEnum = (typeof Instance_rolesScalarFieldEnum)[keyof typeof Instance_rolesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    id: 'id',
    name: 'name',
    image_url: 'image_url',
    email: 'email',
    auto_subscribe: 'auto_subscribe',
    instance_role_id: 'instance_role_id'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const Venue_tagsScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    venue_id: 'venue_id',
    tag_id: 'tag_id'
  };

  export type Venue_tagsScalarFieldEnum = (typeof Venue_tagsScalarFieldEnum)[keyof typeof Venue_tagsScalarFieldEnum]


  export const VenuesScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    id: 'id',
    name: 'name',
    street_address: 'street_address',
    city: 'city',
    postal_code: 'postal_code',
    region: 'region',
    country: 'country',
    latitude: 'latitude',
    longitude: 'longitude',
    chapter_id: 'chapter_id'
  };

  export type VenuesScalarFieldEnum = (typeof VenuesScalarFieldEnum)[keyof typeof VenuesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'events_venue_type_enum'
   */
  export type Enumevents_venue_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'events_venue_type_enum'>
    


  /**
   * Reference to a field of type 'events_venue_type_enum[]'
   */
  export type ListEnumevents_venue_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'events_venue_type_enum[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type chaptersWhereInput = {
    AND?: chaptersWhereInput | chaptersWhereInput[]
    OR?: chaptersWhereInput[]
    NOT?: chaptersWhereInput | chaptersWhereInput[]
    created_at?: DateTimeFilter<"chapters"> | Date | string
    updated_at?: DateTimeFilter<"chapters"> | Date | string
    id?: IntFilter<"chapters"> | number
    name?: StringFilter<"chapters"> | string
    description?: StringFilter<"chapters"> | string
    category?: StringFilter<"chapters"> | string
    city?: StringFilter<"chapters"> | string
    region?: StringFilter<"chapters"> | string
    country?: StringFilter<"chapters"> | string
    logo_url?: StringNullableFilter<"chapters"> | string | null
    banner_url?: StringNullableFilter<"chapters"> | string | null
    calendar_id?: StringNullableFilter<"chapters"> | string | null
    chat_url?: StringNullableFilter<"chapters"> | string | null
    creator_id?: IntFilter<"chapters"> | number
    events?: EventsListRelationFilter
    user_bans?: User_bansListRelationFilter
    chapter_users?: Chapter_usersListRelationFilter
    chapter_tags?: Chapter_tagsListRelationFilter
    venues?: VenuesListRelationFilter
  }

  export type chaptersOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    logo_url?: SortOrderInput | SortOrder
    banner_url?: SortOrderInput | SortOrder
    calendar_id?: SortOrderInput | SortOrder
    chat_url?: SortOrderInput | SortOrder
    creator_id?: SortOrder
    events?: eventsOrderByRelationAggregateInput
    user_bans?: user_bansOrderByRelationAggregateInput
    chapter_users?: chapter_usersOrderByRelationAggregateInput
    chapter_tags?: chapter_tagsOrderByRelationAggregateInput
    venues?: venuesOrderByRelationAggregateInput
  }

  export type chaptersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: chaptersWhereInput | chaptersWhereInput[]
    OR?: chaptersWhereInput[]
    NOT?: chaptersWhereInput | chaptersWhereInput[]
    created_at?: DateTimeFilter<"chapters"> | Date | string
    updated_at?: DateTimeFilter<"chapters"> | Date | string
    name?: StringFilter<"chapters"> | string
    description?: StringFilter<"chapters"> | string
    category?: StringFilter<"chapters"> | string
    city?: StringFilter<"chapters"> | string
    region?: StringFilter<"chapters"> | string
    country?: StringFilter<"chapters"> | string
    logo_url?: StringNullableFilter<"chapters"> | string | null
    banner_url?: StringNullableFilter<"chapters"> | string | null
    calendar_id?: StringNullableFilter<"chapters"> | string | null
    chat_url?: StringNullableFilter<"chapters"> | string | null
    creator_id?: IntFilter<"chapters"> | number
    events?: EventsListRelationFilter
    user_bans?: User_bansListRelationFilter
    chapter_users?: Chapter_usersListRelationFilter
    chapter_tags?: Chapter_tagsListRelationFilter
    venues?: VenuesListRelationFilter
  }, "id">

  export type chaptersOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    logo_url?: SortOrderInput | SortOrder
    banner_url?: SortOrderInput | SortOrder
    calendar_id?: SortOrderInput | SortOrder
    chat_url?: SortOrderInput | SortOrder
    creator_id?: SortOrder
    _count?: chaptersCountOrderByAggregateInput
    _avg?: chaptersAvgOrderByAggregateInput
    _max?: chaptersMaxOrderByAggregateInput
    _min?: chaptersMinOrderByAggregateInput
    _sum?: chaptersSumOrderByAggregateInput
  }

  export type chaptersScalarWhereWithAggregatesInput = {
    AND?: chaptersScalarWhereWithAggregatesInput | chaptersScalarWhereWithAggregatesInput[]
    OR?: chaptersScalarWhereWithAggregatesInput[]
    NOT?: chaptersScalarWhereWithAggregatesInput | chaptersScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"chapters"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"chapters"> | Date | string
    id?: IntWithAggregatesFilter<"chapters"> | number
    name?: StringWithAggregatesFilter<"chapters"> | string
    description?: StringWithAggregatesFilter<"chapters"> | string
    category?: StringWithAggregatesFilter<"chapters"> | string
    city?: StringWithAggregatesFilter<"chapters"> | string
    region?: StringWithAggregatesFilter<"chapters"> | string
    country?: StringWithAggregatesFilter<"chapters"> | string
    logo_url?: StringNullableWithAggregatesFilter<"chapters"> | string | null
    banner_url?: StringNullableWithAggregatesFilter<"chapters"> | string | null
    calendar_id?: StringNullableWithAggregatesFilter<"chapters"> | string | null
    chat_url?: StringNullableWithAggregatesFilter<"chapters"> | string | null
    creator_id?: IntWithAggregatesFilter<"chapters"> | number
  }

  export type sessionsWhereInput = {
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    id?: IntFilter<"sessions"> | number
    user_id?: IntFilter<"sessions"> | number
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type sessionsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "user_id">

  export type sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    _count?: sessionsCountOrderByAggregateInput
    _avg?: sessionsAvgOrderByAggregateInput
    _max?: sessionsMaxOrderByAggregateInput
    _min?: sessionsMinOrderByAggregateInput
    _sum?: sessionsSumOrderByAggregateInput
  }

  export type sessionsScalarWhereWithAggregatesInput = {
    AND?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    OR?: sessionsScalarWhereWithAggregatesInput[]
    NOT?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sessions"> | number
    user_id?: IntWithAggregatesFilter<"sessions"> | number
  }

  export type google_tokensWhereInput = {
    AND?: google_tokensWhereInput | google_tokensWhereInput[]
    OR?: google_tokensWhereInput[]
    NOT?: google_tokensWhereInput | google_tokensWhereInput[]
    id?: IntFilter<"google_tokens"> | number
    email?: StringFilter<"google_tokens"> | string
    access_token?: StringFilter<"google_tokens"> | string
    refresh_token?: StringFilter<"google_tokens"> | string
    expiry_date?: BigIntFilter<"google_tokens"> | bigint | number
    is_valid?: BoolFilter<"google_tokens"> | boolean
  }

  export type google_tokensOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    access_token?: SortOrder
    refresh_token?: SortOrder
    expiry_date?: SortOrder
    is_valid?: SortOrder
  }

  export type google_tokensWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: google_tokensWhereInput | google_tokensWhereInput[]
    OR?: google_tokensWhereInput[]
    NOT?: google_tokensWhereInput | google_tokensWhereInput[]
    access_token?: StringFilter<"google_tokens"> | string
    refresh_token?: StringFilter<"google_tokens"> | string
    expiry_date?: BigIntFilter<"google_tokens"> | bigint | number
    is_valid?: BoolFilter<"google_tokens"> | boolean
  }, "id" | "email">

  export type google_tokensOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    access_token?: SortOrder
    refresh_token?: SortOrder
    expiry_date?: SortOrder
    is_valid?: SortOrder
    _count?: google_tokensCountOrderByAggregateInput
    _avg?: google_tokensAvgOrderByAggregateInput
    _max?: google_tokensMaxOrderByAggregateInput
    _min?: google_tokensMinOrderByAggregateInput
    _sum?: google_tokensSumOrderByAggregateInput
  }

  export type google_tokensScalarWhereWithAggregatesInput = {
    AND?: google_tokensScalarWhereWithAggregatesInput | google_tokensScalarWhereWithAggregatesInput[]
    OR?: google_tokensScalarWhereWithAggregatesInput[]
    NOT?: google_tokensScalarWhereWithAggregatesInput | google_tokensScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"google_tokens"> | number
    email?: StringWithAggregatesFilter<"google_tokens"> | string
    access_token?: StringWithAggregatesFilter<"google_tokens"> | string
    refresh_token?: StringWithAggregatesFilter<"google_tokens"> | string
    expiry_date?: BigIntWithAggregatesFilter<"google_tokens"> | bigint | number
    is_valid?: BoolWithAggregatesFilter<"google_tokens"> | boolean
  }

  export type chapter_usersWhereInput = {
    AND?: chapter_usersWhereInput | chapter_usersWhereInput[]
    OR?: chapter_usersWhereInput[]
    NOT?: chapter_usersWhereInput | chapter_usersWhereInput[]
    created_at?: DateTimeFilter<"chapter_users"> | Date | string
    updated_at?: DateTimeFilter<"chapter_users"> | Date | string
    joined_date?: DateTimeFilter<"chapter_users"> | Date | string
    user_id?: IntFilter<"chapter_users"> | number
    chapter_id?: IntFilter<"chapter_users"> | number
    chapter_role_id?: IntFilter<"chapter_users"> | number
    subscribed?: BoolFilter<"chapter_users"> | boolean
    user?: XOR<UsersRelationFilter, usersWhereInput>
    chapter?: XOR<ChaptersRelationFilter, chaptersWhereInput>
    chapter_role?: XOR<Chapter_rolesRelationFilter, chapter_rolesWhereInput>
  }

  export type chapter_usersOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    joined_date?: SortOrder
    user_id?: SortOrder
    chapter_id?: SortOrder
    chapter_role_id?: SortOrder
    subscribed?: SortOrder
    user?: usersOrderByWithRelationInput
    chapter?: chaptersOrderByWithRelationInput
    chapter_role?: chapter_rolesOrderByWithRelationInput
  }

  export type chapter_usersWhereUniqueInput = Prisma.AtLeast<{
    user_id_chapter_id?: chapter_usersUser_idChapter_idCompoundUniqueInput
    AND?: chapter_usersWhereInput | chapter_usersWhereInput[]
    OR?: chapter_usersWhereInput[]
    NOT?: chapter_usersWhereInput | chapter_usersWhereInput[]
    created_at?: DateTimeFilter<"chapter_users"> | Date | string
    updated_at?: DateTimeFilter<"chapter_users"> | Date | string
    joined_date?: DateTimeFilter<"chapter_users"> | Date | string
    user_id?: IntFilter<"chapter_users"> | number
    chapter_id?: IntFilter<"chapter_users"> | number
    chapter_role_id?: IntFilter<"chapter_users"> | number
    subscribed?: BoolFilter<"chapter_users"> | boolean
    user?: XOR<UsersRelationFilter, usersWhereInput>
    chapter?: XOR<ChaptersRelationFilter, chaptersWhereInput>
    chapter_role?: XOR<Chapter_rolesRelationFilter, chapter_rolesWhereInput>
  }, "user_id_chapter_id">

  export type chapter_usersOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    joined_date?: SortOrder
    user_id?: SortOrder
    chapter_id?: SortOrder
    chapter_role_id?: SortOrder
    subscribed?: SortOrder
    _count?: chapter_usersCountOrderByAggregateInput
    _avg?: chapter_usersAvgOrderByAggregateInput
    _max?: chapter_usersMaxOrderByAggregateInput
    _min?: chapter_usersMinOrderByAggregateInput
    _sum?: chapter_usersSumOrderByAggregateInput
  }

  export type chapter_usersScalarWhereWithAggregatesInput = {
    AND?: chapter_usersScalarWhereWithAggregatesInput | chapter_usersScalarWhereWithAggregatesInput[]
    OR?: chapter_usersScalarWhereWithAggregatesInput[]
    NOT?: chapter_usersScalarWhereWithAggregatesInput | chapter_usersScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"chapter_users"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"chapter_users"> | Date | string
    joined_date?: DateTimeWithAggregatesFilter<"chapter_users"> | Date | string
    user_id?: IntWithAggregatesFilter<"chapter_users"> | number
    chapter_id?: IntWithAggregatesFilter<"chapter_users"> | number
    chapter_role_id?: IntWithAggregatesFilter<"chapter_users"> | number
    subscribed?: BoolWithAggregatesFilter<"chapter_users"> | boolean
  }

  export type chapter_rolesWhereInput = {
    AND?: chapter_rolesWhereInput | chapter_rolesWhereInput[]
    OR?: chapter_rolesWhereInput[]
    NOT?: chapter_rolesWhereInput | chapter_rolesWhereInput[]
    created_at?: DateTimeFilter<"chapter_roles"> | Date | string
    updated_at?: DateTimeFilter<"chapter_roles"> | Date | string
    id?: IntFilter<"chapter_roles"> | number
    name?: StringFilter<"chapter_roles"> | string
    chapter_users?: Chapter_usersListRelationFilter
    chapter_role_permissions?: Chapter_role_permissionsListRelationFilter
  }

  export type chapter_rolesOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    chapter_users?: chapter_usersOrderByRelationAggregateInput
    chapter_role_permissions?: chapter_role_permissionsOrderByRelationAggregateInput
  }

  export type chapter_rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: chapter_rolesWhereInput | chapter_rolesWhereInput[]
    OR?: chapter_rolesWhereInput[]
    NOT?: chapter_rolesWhereInput | chapter_rolesWhereInput[]
    created_at?: DateTimeFilter<"chapter_roles"> | Date | string
    updated_at?: DateTimeFilter<"chapter_roles"> | Date | string
    chapter_users?: Chapter_usersListRelationFilter
    chapter_role_permissions?: Chapter_role_permissionsListRelationFilter
  }, "id" | "name">

  export type chapter_rolesOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    _count?: chapter_rolesCountOrderByAggregateInput
    _avg?: chapter_rolesAvgOrderByAggregateInput
    _max?: chapter_rolesMaxOrderByAggregateInput
    _min?: chapter_rolesMinOrderByAggregateInput
    _sum?: chapter_rolesSumOrderByAggregateInput
  }

  export type chapter_rolesScalarWhereWithAggregatesInput = {
    AND?: chapter_rolesScalarWhereWithAggregatesInput | chapter_rolesScalarWhereWithAggregatesInput[]
    OR?: chapter_rolesScalarWhereWithAggregatesInput[]
    NOT?: chapter_rolesScalarWhereWithAggregatesInput | chapter_rolesScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"chapter_roles"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"chapter_roles"> | Date | string
    id?: IntWithAggregatesFilter<"chapter_roles"> | number
    name?: StringWithAggregatesFilter<"chapter_roles"> | string
  }

  export type chapter_role_permissionsWhereInput = {
    AND?: chapter_role_permissionsWhereInput | chapter_role_permissionsWhereInput[]
    OR?: chapter_role_permissionsWhereInput[]
    NOT?: chapter_role_permissionsWhereInput | chapter_role_permissionsWhereInput[]
    created_at?: DateTimeFilter<"chapter_role_permissions"> | Date | string
    updated_at?: DateTimeFilter<"chapter_role_permissions"> | Date | string
    chapter_role_id?: IntFilter<"chapter_role_permissions"> | number
    chapter_permissions_id?: IntFilter<"chapter_role_permissions"> | number
    chapter_role?: XOR<Chapter_rolesRelationFilter, chapter_rolesWhereInput>
    chapter_permission?: XOR<Chapter_permissionsRelationFilter, chapter_permissionsWhereInput>
  }

  export type chapter_role_permissionsOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    chapter_role_id?: SortOrder
    chapter_permissions_id?: SortOrder
    chapter_role?: chapter_rolesOrderByWithRelationInput
    chapter_permission?: chapter_permissionsOrderByWithRelationInput
  }

  export type chapter_role_permissionsWhereUniqueInput = Prisma.AtLeast<{
    chapter_role_id_chapter_permissions_id?: chapter_role_permissionsChapter_role_idChapter_permissions_idCompoundUniqueInput
    AND?: chapter_role_permissionsWhereInput | chapter_role_permissionsWhereInput[]
    OR?: chapter_role_permissionsWhereInput[]
    NOT?: chapter_role_permissionsWhereInput | chapter_role_permissionsWhereInput[]
    created_at?: DateTimeFilter<"chapter_role_permissions"> | Date | string
    updated_at?: DateTimeFilter<"chapter_role_permissions"> | Date | string
    chapter_role_id?: IntFilter<"chapter_role_permissions"> | number
    chapter_permissions_id?: IntFilter<"chapter_role_permissions"> | number
    chapter_role?: XOR<Chapter_rolesRelationFilter, chapter_rolesWhereInput>
    chapter_permission?: XOR<Chapter_permissionsRelationFilter, chapter_permissionsWhereInput>
  }, "chapter_role_id_chapter_permissions_id">

  export type chapter_role_permissionsOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    chapter_role_id?: SortOrder
    chapter_permissions_id?: SortOrder
    _count?: chapter_role_permissionsCountOrderByAggregateInput
    _avg?: chapter_role_permissionsAvgOrderByAggregateInput
    _max?: chapter_role_permissionsMaxOrderByAggregateInput
    _min?: chapter_role_permissionsMinOrderByAggregateInput
    _sum?: chapter_role_permissionsSumOrderByAggregateInput
  }

  export type chapter_role_permissionsScalarWhereWithAggregatesInput = {
    AND?: chapter_role_permissionsScalarWhereWithAggregatesInput | chapter_role_permissionsScalarWhereWithAggregatesInput[]
    OR?: chapter_role_permissionsScalarWhereWithAggregatesInput[]
    NOT?: chapter_role_permissionsScalarWhereWithAggregatesInput | chapter_role_permissionsScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"chapter_role_permissions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"chapter_role_permissions"> | Date | string
    chapter_role_id?: IntWithAggregatesFilter<"chapter_role_permissions"> | number
    chapter_permissions_id?: IntWithAggregatesFilter<"chapter_role_permissions"> | number
  }

  export type chapter_permissionsWhereInput = {
    AND?: chapter_permissionsWhereInput | chapter_permissionsWhereInput[]
    OR?: chapter_permissionsWhereInput[]
    NOT?: chapter_permissionsWhereInput | chapter_permissionsWhereInput[]
    created_at?: DateTimeFilter<"chapter_permissions"> | Date | string
    updated_at?: DateTimeFilter<"chapter_permissions"> | Date | string
    id?: IntFilter<"chapter_permissions"> | number
    name?: StringFilter<"chapter_permissions"> | string
    chapter_role_permissions?: Chapter_role_permissionsListRelationFilter
  }

  export type chapter_permissionsOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    chapter_role_permissions?: chapter_role_permissionsOrderByRelationAggregateInput
  }

  export type chapter_permissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: chapter_permissionsWhereInput | chapter_permissionsWhereInput[]
    OR?: chapter_permissionsWhereInput[]
    NOT?: chapter_permissionsWhereInput | chapter_permissionsWhereInput[]
    created_at?: DateTimeFilter<"chapter_permissions"> | Date | string
    updated_at?: DateTimeFilter<"chapter_permissions"> | Date | string
    chapter_role_permissions?: Chapter_role_permissionsListRelationFilter
  }, "id" | "name">

  export type chapter_permissionsOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    _count?: chapter_permissionsCountOrderByAggregateInput
    _avg?: chapter_permissionsAvgOrderByAggregateInput
    _max?: chapter_permissionsMaxOrderByAggregateInput
    _min?: chapter_permissionsMinOrderByAggregateInput
    _sum?: chapter_permissionsSumOrderByAggregateInput
  }

  export type chapter_permissionsScalarWhereWithAggregatesInput = {
    AND?: chapter_permissionsScalarWhereWithAggregatesInput | chapter_permissionsScalarWhereWithAggregatesInput[]
    OR?: chapter_permissionsScalarWhereWithAggregatesInput[]
    NOT?: chapter_permissionsScalarWhereWithAggregatesInput | chapter_permissionsScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"chapter_permissions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"chapter_permissions"> | Date | string
    id?: IntWithAggregatesFilter<"chapter_permissions"> | number
    name?: StringWithAggregatesFilter<"chapter_permissions"> | string
  }

  export type chapter_tagsWhereInput = {
    AND?: chapter_tagsWhereInput | chapter_tagsWhereInput[]
    OR?: chapter_tagsWhereInput[]
    NOT?: chapter_tagsWhereInput | chapter_tagsWhereInput[]
    created_at?: DateTimeFilter<"chapter_tags"> | Date | string
    updated_at?: DateTimeFilter<"chapter_tags"> | Date | string
    chapter_id?: IntFilter<"chapter_tags"> | number
    tag_id?: IntFilter<"chapter_tags"> | number
    chapter?: XOR<ChaptersRelationFilter, chaptersWhereInput>
    tag?: XOR<TagsRelationFilter, tagsWhereInput>
  }

  export type chapter_tagsOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    chapter_id?: SortOrder
    tag_id?: SortOrder
    chapter?: chaptersOrderByWithRelationInput
    tag?: tagsOrderByWithRelationInput
  }

  export type chapter_tagsWhereUniqueInput = Prisma.AtLeast<{
    chapter_id_tag_id?: chapter_tagsChapter_idTag_idCompoundUniqueInput
    AND?: chapter_tagsWhereInput | chapter_tagsWhereInput[]
    OR?: chapter_tagsWhereInput[]
    NOT?: chapter_tagsWhereInput | chapter_tagsWhereInput[]
    created_at?: DateTimeFilter<"chapter_tags"> | Date | string
    updated_at?: DateTimeFilter<"chapter_tags"> | Date | string
    chapter_id?: IntFilter<"chapter_tags"> | number
    tag_id?: IntFilter<"chapter_tags"> | number
    chapter?: XOR<ChaptersRelationFilter, chaptersWhereInput>
    tag?: XOR<TagsRelationFilter, tagsWhereInput>
  }, "chapter_id_tag_id">

  export type chapter_tagsOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    chapter_id?: SortOrder
    tag_id?: SortOrder
    _count?: chapter_tagsCountOrderByAggregateInput
    _avg?: chapter_tagsAvgOrderByAggregateInput
    _max?: chapter_tagsMaxOrderByAggregateInput
    _min?: chapter_tagsMinOrderByAggregateInput
    _sum?: chapter_tagsSumOrderByAggregateInput
  }

  export type chapter_tagsScalarWhereWithAggregatesInput = {
    AND?: chapter_tagsScalarWhereWithAggregatesInput | chapter_tagsScalarWhereWithAggregatesInput[]
    OR?: chapter_tagsScalarWhereWithAggregatesInput[]
    NOT?: chapter_tagsScalarWhereWithAggregatesInput | chapter_tagsScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"chapter_tags"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"chapter_tags"> | Date | string
    chapter_id?: IntWithAggregatesFilter<"chapter_tags"> | number
    tag_id?: IntWithAggregatesFilter<"chapter_tags"> | number
  }

  export type event_sponsorsWhereInput = {
    AND?: event_sponsorsWhereInput | event_sponsorsWhereInput[]
    OR?: event_sponsorsWhereInput[]
    NOT?: event_sponsorsWhereInput | event_sponsorsWhereInput[]
    created_at?: DateTimeFilter<"event_sponsors"> | Date | string
    updated_at?: DateTimeFilter<"event_sponsors"> | Date | string
    sponsor_id?: IntFilter<"event_sponsors"> | number
    event_id?: IntFilter<"event_sponsors"> | number
    event?: XOR<EventsRelationFilter, eventsWhereInput>
    sponsor?: XOR<SponsorsRelationFilter, sponsorsWhereInput>
  }

  export type event_sponsorsOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    sponsor_id?: SortOrder
    event_id?: SortOrder
    event?: eventsOrderByWithRelationInput
    sponsor?: sponsorsOrderByWithRelationInput
  }

  export type event_sponsorsWhereUniqueInput = Prisma.AtLeast<{
    sponsor_id_event_id?: event_sponsorsSponsor_idEvent_idCompoundUniqueInput
    AND?: event_sponsorsWhereInput | event_sponsorsWhereInput[]
    OR?: event_sponsorsWhereInput[]
    NOT?: event_sponsorsWhereInput | event_sponsorsWhereInput[]
    created_at?: DateTimeFilter<"event_sponsors"> | Date | string
    updated_at?: DateTimeFilter<"event_sponsors"> | Date | string
    sponsor_id?: IntFilter<"event_sponsors"> | number
    event_id?: IntFilter<"event_sponsors"> | number
    event?: XOR<EventsRelationFilter, eventsWhereInput>
    sponsor?: XOR<SponsorsRelationFilter, sponsorsWhereInput>
  }, "sponsor_id_event_id">

  export type event_sponsorsOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    sponsor_id?: SortOrder
    event_id?: SortOrder
    _count?: event_sponsorsCountOrderByAggregateInput
    _avg?: event_sponsorsAvgOrderByAggregateInput
    _max?: event_sponsorsMaxOrderByAggregateInput
    _min?: event_sponsorsMinOrderByAggregateInput
    _sum?: event_sponsorsSumOrderByAggregateInput
  }

  export type event_sponsorsScalarWhereWithAggregatesInput = {
    AND?: event_sponsorsScalarWhereWithAggregatesInput | event_sponsorsScalarWhereWithAggregatesInput[]
    OR?: event_sponsorsScalarWhereWithAggregatesInput[]
    NOT?: event_sponsorsScalarWhereWithAggregatesInput | event_sponsorsScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"event_sponsors"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"event_sponsors"> | Date | string
    sponsor_id?: IntWithAggregatesFilter<"event_sponsors"> | number
    event_id?: IntWithAggregatesFilter<"event_sponsors"> | number
  }

  export type event_tagsWhereInput = {
    AND?: event_tagsWhereInput | event_tagsWhereInput[]
    OR?: event_tagsWhereInput[]
    NOT?: event_tagsWhereInput | event_tagsWhereInput[]
    created_at?: DateTimeFilter<"event_tags"> | Date | string
    updated_at?: DateTimeFilter<"event_tags"> | Date | string
    event_id?: IntFilter<"event_tags"> | number
    tag_id?: IntFilter<"event_tags"> | number
    event?: XOR<EventsRelationFilter, eventsWhereInput>
    tag?: XOR<TagsRelationFilter, tagsWhereInput>
  }

  export type event_tagsOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    event_id?: SortOrder
    tag_id?: SortOrder
    event?: eventsOrderByWithRelationInput
    tag?: tagsOrderByWithRelationInput
  }

  export type event_tagsWhereUniqueInput = Prisma.AtLeast<{
    event_id_tag_id?: event_tagsEvent_idTag_idCompoundUniqueInput
    AND?: event_tagsWhereInput | event_tagsWhereInput[]
    OR?: event_tagsWhereInput[]
    NOT?: event_tagsWhereInput | event_tagsWhereInput[]
    created_at?: DateTimeFilter<"event_tags"> | Date | string
    updated_at?: DateTimeFilter<"event_tags"> | Date | string
    event_id?: IntFilter<"event_tags"> | number
    tag_id?: IntFilter<"event_tags"> | number
    event?: XOR<EventsRelationFilter, eventsWhereInput>
    tag?: XOR<TagsRelationFilter, tagsWhereInput>
  }, "event_id_tag_id">

  export type event_tagsOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    event_id?: SortOrder
    tag_id?: SortOrder
    _count?: event_tagsCountOrderByAggregateInput
    _avg?: event_tagsAvgOrderByAggregateInput
    _max?: event_tagsMaxOrderByAggregateInput
    _min?: event_tagsMinOrderByAggregateInput
    _sum?: event_tagsSumOrderByAggregateInput
  }

  export type event_tagsScalarWhereWithAggregatesInput = {
    AND?: event_tagsScalarWhereWithAggregatesInput | event_tagsScalarWhereWithAggregatesInput[]
    OR?: event_tagsScalarWhereWithAggregatesInput[]
    NOT?: event_tagsScalarWhereWithAggregatesInput | event_tagsScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"event_tags"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"event_tags"> | Date | string
    event_id?: IntWithAggregatesFilter<"event_tags"> | number
    tag_id?: IntWithAggregatesFilter<"event_tags"> | number
  }

  export type eventsWhereInput = {
    AND?: eventsWhereInput | eventsWhereInput[]
    OR?: eventsWhereInput[]
    NOT?: eventsWhereInput | eventsWhereInput[]
    created_at?: DateTimeFilter<"events"> | Date | string
    updated_at?: DateTimeFilter<"events"> | Date | string
    id?: IntFilter<"events"> | number
    name?: StringFilter<"events"> | string
    description?: StringFilter<"events"> | string
    url?: StringNullableFilter<"events"> | string | null
    streaming_url?: StringNullableFilter<"events"> | string | null
    venue_type?: Enumevents_venue_type_enumFilter<"events"> | events_venue_type_enum
    start_at?: DateTimeFilter<"events"> | Date | string
    ends_at?: DateTimeFilter<"events"> | Date | string
    canceled?: BoolFilter<"events"> | boolean
    capacity?: IntFilter<"events"> | number
    invite_only?: BoolFilter<"events"> | boolean
    image_url?: StringFilter<"events"> | string
    venue_id?: IntNullableFilter<"events"> | number | null
    chapter_id?: IntFilter<"events"> | number
    calendar_event_id?: StringNullableFilter<"events"> | string | null
    chapter?: XOR<ChaptersRelationFilter, chaptersWhereInput>
    venue?: XOR<VenuesNullableRelationFilter, venuesWhereInput> | null
    sponsors?: Event_sponsorsListRelationFilter
    event_tags?: Event_tagsListRelationFilter
    event_users?: Event_usersListRelationFilter
  }

  export type eventsOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrderInput | SortOrder
    streaming_url?: SortOrderInput | SortOrder
    venue_type?: SortOrder
    start_at?: SortOrder
    ends_at?: SortOrder
    canceled?: SortOrder
    capacity?: SortOrder
    invite_only?: SortOrder
    image_url?: SortOrder
    venue_id?: SortOrderInput | SortOrder
    chapter_id?: SortOrder
    calendar_event_id?: SortOrderInput | SortOrder
    chapter?: chaptersOrderByWithRelationInput
    venue?: venuesOrderByWithRelationInput
    sponsors?: event_sponsorsOrderByRelationAggregateInput
    event_tags?: event_tagsOrderByRelationAggregateInput
    event_users?: event_usersOrderByRelationAggregateInput
  }

  export type eventsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: eventsWhereInput | eventsWhereInput[]
    OR?: eventsWhereInput[]
    NOT?: eventsWhereInput | eventsWhereInput[]
    created_at?: DateTimeFilter<"events"> | Date | string
    updated_at?: DateTimeFilter<"events"> | Date | string
    name?: StringFilter<"events"> | string
    description?: StringFilter<"events"> | string
    url?: StringNullableFilter<"events"> | string | null
    streaming_url?: StringNullableFilter<"events"> | string | null
    venue_type?: Enumevents_venue_type_enumFilter<"events"> | events_venue_type_enum
    start_at?: DateTimeFilter<"events"> | Date | string
    ends_at?: DateTimeFilter<"events"> | Date | string
    canceled?: BoolFilter<"events"> | boolean
    capacity?: IntFilter<"events"> | number
    invite_only?: BoolFilter<"events"> | boolean
    image_url?: StringFilter<"events"> | string
    venue_id?: IntNullableFilter<"events"> | number | null
    chapter_id?: IntFilter<"events"> | number
    calendar_event_id?: StringNullableFilter<"events"> | string | null
    chapter?: XOR<ChaptersRelationFilter, chaptersWhereInput>
    venue?: XOR<VenuesNullableRelationFilter, venuesWhereInput> | null
    sponsors?: Event_sponsorsListRelationFilter
    event_tags?: Event_tagsListRelationFilter
    event_users?: Event_usersListRelationFilter
  }, "id">

  export type eventsOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrderInput | SortOrder
    streaming_url?: SortOrderInput | SortOrder
    venue_type?: SortOrder
    start_at?: SortOrder
    ends_at?: SortOrder
    canceled?: SortOrder
    capacity?: SortOrder
    invite_only?: SortOrder
    image_url?: SortOrder
    venue_id?: SortOrderInput | SortOrder
    chapter_id?: SortOrder
    calendar_event_id?: SortOrderInput | SortOrder
    _count?: eventsCountOrderByAggregateInput
    _avg?: eventsAvgOrderByAggregateInput
    _max?: eventsMaxOrderByAggregateInput
    _min?: eventsMinOrderByAggregateInput
    _sum?: eventsSumOrderByAggregateInput
  }

  export type eventsScalarWhereWithAggregatesInput = {
    AND?: eventsScalarWhereWithAggregatesInput | eventsScalarWhereWithAggregatesInput[]
    OR?: eventsScalarWhereWithAggregatesInput[]
    NOT?: eventsScalarWhereWithAggregatesInput | eventsScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"events"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"events"> | Date | string
    id?: IntWithAggregatesFilter<"events"> | number
    name?: StringWithAggregatesFilter<"events"> | string
    description?: StringWithAggregatesFilter<"events"> | string
    url?: StringNullableWithAggregatesFilter<"events"> | string | null
    streaming_url?: StringNullableWithAggregatesFilter<"events"> | string | null
    venue_type?: Enumevents_venue_type_enumWithAggregatesFilter<"events"> | events_venue_type_enum
    start_at?: DateTimeWithAggregatesFilter<"events"> | Date | string
    ends_at?: DateTimeWithAggregatesFilter<"events"> | Date | string
    canceled?: BoolWithAggregatesFilter<"events"> | boolean
    capacity?: IntWithAggregatesFilter<"events"> | number
    invite_only?: BoolWithAggregatesFilter<"events"> | boolean
    image_url?: StringWithAggregatesFilter<"events"> | string
    venue_id?: IntNullableWithAggregatesFilter<"events"> | number | null
    chapter_id?: IntWithAggregatesFilter<"events"> | number
    calendar_event_id?: StringNullableWithAggregatesFilter<"events"> | string | null
  }

  export type event_rolesWhereInput = {
    AND?: event_rolesWhereInput | event_rolesWhereInput[]
    OR?: event_rolesWhereInput[]
    NOT?: event_rolesWhereInput | event_rolesWhereInput[]
    created_at?: DateTimeFilter<"event_roles"> | Date | string
    updated_at?: DateTimeFilter<"event_roles"> | Date | string
    id?: IntFilter<"event_roles"> | number
    name?: StringFilter<"event_roles"> | string
    event_role_permissions?: Event_role_permissionsListRelationFilter
    event_users?: Event_usersListRelationFilter
  }

  export type event_rolesOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    event_role_permissions?: event_role_permissionsOrderByRelationAggregateInput
    event_users?: event_usersOrderByRelationAggregateInput
  }

  export type event_rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: event_rolesWhereInput | event_rolesWhereInput[]
    OR?: event_rolesWhereInput[]
    NOT?: event_rolesWhereInput | event_rolesWhereInput[]
    created_at?: DateTimeFilter<"event_roles"> | Date | string
    updated_at?: DateTimeFilter<"event_roles"> | Date | string
    event_role_permissions?: Event_role_permissionsListRelationFilter
    event_users?: Event_usersListRelationFilter
  }, "id" | "name">

  export type event_rolesOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    _count?: event_rolesCountOrderByAggregateInput
    _avg?: event_rolesAvgOrderByAggregateInput
    _max?: event_rolesMaxOrderByAggregateInput
    _min?: event_rolesMinOrderByAggregateInput
    _sum?: event_rolesSumOrderByAggregateInput
  }

  export type event_rolesScalarWhereWithAggregatesInput = {
    AND?: event_rolesScalarWhereWithAggregatesInput | event_rolesScalarWhereWithAggregatesInput[]
    OR?: event_rolesScalarWhereWithAggregatesInput[]
    NOT?: event_rolesScalarWhereWithAggregatesInput | event_rolesScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"event_roles"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"event_roles"> | Date | string
    id?: IntWithAggregatesFilter<"event_roles"> | number
    name?: StringWithAggregatesFilter<"event_roles"> | string
  }

  export type event_role_permissionsWhereInput = {
    AND?: event_role_permissionsWhereInput | event_role_permissionsWhereInput[]
    OR?: event_role_permissionsWhereInput[]
    NOT?: event_role_permissionsWhereInput | event_role_permissionsWhereInput[]
    created_at?: DateTimeFilter<"event_role_permissions"> | Date | string
    updated_at?: DateTimeFilter<"event_role_permissions"> | Date | string
    event_role_id?: IntFilter<"event_role_permissions"> | number
    event_permission_id?: IntFilter<"event_role_permissions"> | number
    event_role?: XOR<Event_rolesRelationFilter, event_rolesWhereInput>
    event_permission?: XOR<Event_permissionsRelationFilter, event_permissionsWhereInput>
  }

  export type event_role_permissionsOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    event_role_id?: SortOrder
    event_permission_id?: SortOrder
    event_role?: event_rolesOrderByWithRelationInput
    event_permission?: event_permissionsOrderByWithRelationInput
  }

  export type event_role_permissionsWhereUniqueInput = Prisma.AtLeast<{
    event_role_id_event_permission_id?: event_role_permissionsEvent_role_idEvent_permission_idCompoundUniqueInput
    AND?: event_role_permissionsWhereInput | event_role_permissionsWhereInput[]
    OR?: event_role_permissionsWhereInput[]
    NOT?: event_role_permissionsWhereInput | event_role_permissionsWhereInput[]
    created_at?: DateTimeFilter<"event_role_permissions"> | Date | string
    updated_at?: DateTimeFilter<"event_role_permissions"> | Date | string
    event_role_id?: IntFilter<"event_role_permissions"> | number
    event_permission_id?: IntFilter<"event_role_permissions"> | number
    event_role?: XOR<Event_rolesRelationFilter, event_rolesWhereInput>
    event_permission?: XOR<Event_permissionsRelationFilter, event_permissionsWhereInput>
  }, "event_role_id_event_permission_id">

  export type event_role_permissionsOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    event_role_id?: SortOrder
    event_permission_id?: SortOrder
    _count?: event_role_permissionsCountOrderByAggregateInput
    _avg?: event_role_permissionsAvgOrderByAggregateInput
    _max?: event_role_permissionsMaxOrderByAggregateInput
    _min?: event_role_permissionsMinOrderByAggregateInput
    _sum?: event_role_permissionsSumOrderByAggregateInput
  }

  export type event_role_permissionsScalarWhereWithAggregatesInput = {
    AND?: event_role_permissionsScalarWhereWithAggregatesInput | event_role_permissionsScalarWhereWithAggregatesInput[]
    OR?: event_role_permissionsScalarWhereWithAggregatesInput[]
    NOT?: event_role_permissionsScalarWhereWithAggregatesInput | event_role_permissionsScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"event_role_permissions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"event_role_permissions"> | Date | string
    event_role_id?: IntWithAggregatesFilter<"event_role_permissions"> | number
    event_permission_id?: IntWithAggregatesFilter<"event_role_permissions"> | number
  }

  export type event_permissionsWhereInput = {
    AND?: event_permissionsWhereInput | event_permissionsWhereInput[]
    OR?: event_permissionsWhereInput[]
    NOT?: event_permissionsWhereInput | event_permissionsWhereInput[]
    created_at?: DateTimeFilter<"event_permissions"> | Date | string
    updated_at?: DateTimeFilter<"event_permissions"> | Date | string
    id?: IntFilter<"event_permissions"> | number
    name?: StringFilter<"event_permissions"> | string
    event_role_permissions?: Event_role_permissionsListRelationFilter
  }

  export type event_permissionsOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    event_role_permissions?: event_role_permissionsOrderByRelationAggregateInput
  }

  export type event_permissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: event_permissionsWhereInput | event_permissionsWhereInput[]
    OR?: event_permissionsWhereInput[]
    NOT?: event_permissionsWhereInput | event_permissionsWhereInput[]
    created_at?: DateTimeFilter<"event_permissions"> | Date | string
    updated_at?: DateTimeFilter<"event_permissions"> | Date | string
    event_role_permissions?: Event_role_permissionsListRelationFilter
  }, "id" | "name">

  export type event_permissionsOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    _count?: event_permissionsCountOrderByAggregateInput
    _avg?: event_permissionsAvgOrderByAggregateInput
    _max?: event_permissionsMaxOrderByAggregateInput
    _min?: event_permissionsMinOrderByAggregateInput
    _sum?: event_permissionsSumOrderByAggregateInput
  }

  export type event_permissionsScalarWhereWithAggregatesInput = {
    AND?: event_permissionsScalarWhereWithAggregatesInput | event_permissionsScalarWhereWithAggregatesInput[]
    OR?: event_permissionsScalarWhereWithAggregatesInput[]
    NOT?: event_permissionsScalarWhereWithAggregatesInput | event_permissionsScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"event_permissions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"event_permissions"> | Date | string
    id?: IntWithAggregatesFilter<"event_permissions"> | number
    name?: StringWithAggregatesFilter<"event_permissions"> | string
  }

  export type event_usersWhereInput = {
    AND?: event_usersWhereInput | event_usersWhereInput[]
    OR?: event_usersWhereInput[]
    NOT?: event_usersWhereInput | event_usersWhereInput[]
    created_at?: DateTimeFilter<"event_users"> | Date | string
    updated_at?: DateTimeFilter<"event_users"> | Date | string
    joined_date?: DateTimeFilter<"event_users"> | Date | string
    user_id?: IntFilter<"event_users"> | number
    event_id?: IntFilter<"event_users"> | number
    event_role_id?: IntFilter<"event_users"> | number
    attendance_id?: IntFilter<"event_users"> | number
    subscribed?: BoolFilter<"event_users"> | boolean
    title?: StringNullableListFilter<"event_users">
    user?: XOR<UsersRelationFilter, usersWhereInput>
    event?: XOR<EventsRelationFilter, eventsWhereInput>
    event_role?: XOR<Event_rolesRelationFilter, event_rolesWhereInput>
    attendance?: XOR<AttendanceRelationFilter, attendanceWhereInput>
    event_reminder?: XOR<Event_remindersNullableRelationFilter, event_remindersWhereInput> | null
  }

  export type event_usersOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    joined_date?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
    event_role_id?: SortOrder
    attendance_id?: SortOrder
    subscribed?: SortOrder
    title?: SortOrder
    user?: usersOrderByWithRelationInput
    event?: eventsOrderByWithRelationInput
    event_role?: event_rolesOrderByWithRelationInput
    attendance?: attendanceOrderByWithRelationInput
    event_reminder?: event_remindersOrderByWithRelationInput
  }

  export type event_usersWhereUniqueInput = Prisma.AtLeast<{
    user_id_event_id?: event_usersUser_idEvent_idCompoundUniqueInput
    AND?: event_usersWhereInput | event_usersWhereInput[]
    OR?: event_usersWhereInput[]
    NOT?: event_usersWhereInput | event_usersWhereInput[]
    created_at?: DateTimeFilter<"event_users"> | Date | string
    updated_at?: DateTimeFilter<"event_users"> | Date | string
    joined_date?: DateTimeFilter<"event_users"> | Date | string
    user_id?: IntFilter<"event_users"> | number
    event_id?: IntFilter<"event_users"> | number
    event_role_id?: IntFilter<"event_users"> | number
    attendance_id?: IntFilter<"event_users"> | number
    subscribed?: BoolFilter<"event_users"> | boolean
    title?: StringNullableListFilter<"event_users">
    user?: XOR<UsersRelationFilter, usersWhereInput>
    event?: XOR<EventsRelationFilter, eventsWhereInput>
    event_role?: XOR<Event_rolesRelationFilter, event_rolesWhereInput>
    attendance?: XOR<AttendanceRelationFilter, attendanceWhereInput>
    event_reminder?: XOR<Event_remindersNullableRelationFilter, event_remindersWhereInput> | null
  }, "user_id_event_id">

  export type event_usersOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    joined_date?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
    event_role_id?: SortOrder
    attendance_id?: SortOrder
    subscribed?: SortOrder
    title?: SortOrder
    _count?: event_usersCountOrderByAggregateInput
    _avg?: event_usersAvgOrderByAggregateInput
    _max?: event_usersMaxOrderByAggregateInput
    _min?: event_usersMinOrderByAggregateInput
    _sum?: event_usersSumOrderByAggregateInput
  }

  export type event_usersScalarWhereWithAggregatesInput = {
    AND?: event_usersScalarWhereWithAggregatesInput | event_usersScalarWhereWithAggregatesInput[]
    OR?: event_usersScalarWhereWithAggregatesInput[]
    NOT?: event_usersScalarWhereWithAggregatesInput | event_usersScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"event_users"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"event_users"> | Date | string
    joined_date?: DateTimeWithAggregatesFilter<"event_users"> | Date | string
    user_id?: IntWithAggregatesFilter<"event_users"> | number
    event_id?: IntWithAggregatesFilter<"event_users"> | number
    event_role_id?: IntWithAggregatesFilter<"event_users"> | number
    attendance_id?: IntWithAggregatesFilter<"event_users"> | number
    subscribed?: BoolWithAggregatesFilter<"event_users"> | boolean
    title?: StringNullableListFilter<"event_users">
  }

  export type event_remindersWhereInput = {
    AND?: event_remindersWhereInput | event_remindersWhereInput[]
    OR?: event_remindersWhereInput[]
    NOT?: event_remindersWhereInput | event_remindersWhereInput[]
    created_at?: DateTimeFilter<"event_reminders"> | Date | string
    updated_at?: DateTimeFilter<"event_reminders"> | Date | string
    user_id?: IntFilter<"event_reminders"> | number
    event_id?: IntFilter<"event_reminders"> | number
    remind_at?: DateTimeFilter<"event_reminders"> | Date | string
    notifying?: BoolFilter<"event_reminders"> | boolean
    event_user?: XOR<Event_usersRelationFilter, event_usersWhereInput>
  }

  export type event_remindersOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
    remind_at?: SortOrder
    notifying?: SortOrder
    event_user?: event_usersOrderByWithRelationInput
  }

  export type event_remindersWhereUniqueInput = Prisma.AtLeast<{
    user_id_event_id?: event_remindersUser_idEvent_idCompoundUniqueInput
    AND?: event_remindersWhereInput | event_remindersWhereInput[]
    OR?: event_remindersWhereInput[]
    NOT?: event_remindersWhereInput | event_remindersWhereInput[]
    created_at?: DateTimeFilter<"event_reminders"> | Date | string
    updated_at?: DateTimeFilter<"event_reminders"> | Date | string
    user_id?: IntFilter<"event_reminders"> | number
    event_id?: IntFilter<"event_reminders"> | number
    remind_at?: DateTimeFilter<"event_reminders"> | Date | string
    notifying?: BoolFilter<"event_reminders"> | boolean
    event_user?: XOR<Event_usersRelationFilter, event_usersWhereInput>
  }, "user_id_event_id">

  export type event_remindersOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
    remind_at?: SortOrder
    notifying?: SortOrder
    _count?: event_remindersCountOrderByAggregateInput
    _avg?: event_remindersAvgOrderByAggregateInput
    _max?: event_remindersMaxOrderByAggregateInput
    _min?: event_remindersMinOrderByAggregateInput
    _sum?: event_remindersSumOrderByAggregateInput
  }

  export type event_remindersScalarWhereWithAggregatesInput = {
    AND?: event_remindersScalarWhereWithAggregatesInput | event_remindersScalarWhereWithAggregatesInput[]
    OR?: event_remindersScalarWhereWithAggregatesInput[]
    NOT?: event_remindersScalarWhereWithAggregatesInput | event_remindersScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"event_reminders"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"event_reminders"> | Date | string
    user_id?: IntWithAggregatesFilter<"event_reminders"> | number
    event_id?: IntWithAggregatesFilter<"event_reminders"> | number
    remind_at?: DateTimeWithAggregatesFilter<"event_reminders"> | Date | string
    notifying?: BoolWithAggregatesFilter<"event_reminders"> | boolean
  }

  export type attendanceWhereInput = {
    AND?: attendanceWhereInput | attendanceWhereInput[]
    OR?: attendanceWhereInput[]
    NOT?: attendanceWhereInput | attendanceWhereInput[]
    created_at?: DateTimeFilter<"attendance"> | Date | string
    updated_at?: DateTimeFilter<"attendance"> | Date | string
    id?: IntFilter<"attendance"> | number
    name?: StringFilter<"attendance"> | string
    event_users?: Event_usersListRelationFilter
  }

  export type attendanceOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    event_users?: event_usersOrderByRelationAggregateInput
  }

  export type attendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: attendanceWhereInput | attendanceWhereInput[]
    OR?: attendanceWhereInput[]
    NOT?: attendanceWhereInput | attendanceWhereInput[]
    created_at?: DateTimeFilter<"attendance"> | Date | string
    updated_at?: DateTimeFilter<"attendance"> | Date | string
    event_users?: Event_usersListRelationFilter
  }, "id" | "name">

  export type attendanceOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    _count?: attendanceCountOrderByAggregateInput
    _avg?: attendanceAvgOrderByAggregateInput
    _max?: attendanceMaxOrderByAggregateInput
    _min?: attendanceMinOrderByAggregateInput
    _sum?: attendanceSumOrderByAggregateInput
  }

  export type attendanceScalarWhereWithAggregatesInput = {
    AND?: attendanceScalarWhereWithAggregatesInput | attendanceScalarWhereWithAggregatesInput[]
    OR?: attendanceScalarWhereWithAggregatesInput[]
    NOT?: attendanceScalarWhereWithAggregatesInput | attendanceScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"attendance"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"attendance"> | Date | string
    id?: IntWithAggregatesFilter<"attendance"> | number
    name?: StringWithAggregatesFilter<"attendance"> | string
  }

  export type sponsorsWhereInput = {
    AND?: sponsorsWhereInput | sponsorsWhereInput[]
    OR?: sponsorsWhereInput[]
    NOT?: sponsorsWhereInput | sponsorsWhereInput[]
    created_at?: DateTimeFilter<"sponsors"> | Date | string
    updated_at?: DateTimeFilter<"sponsors"> | Date | string
    id?: IntFilter<"sponsors"> | number
    name?: StringFilter<"sponsors"> | string
    website?: StringFilter<"sponsors"> | string
    logo_path?: StringFilter<"sponsors"> | string
    type?: StringFilter<"sponsors"> | string
    event_sponsors?: Event_sponsorsListRelationFilter
  }

  export type sponsorsOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    logo_path?: SortOrder
    type?: SortOrder
    event_sponsors?: event_sponsorsOrderByRelationAggregateInput
  }

  export type sponsorsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: sponsorsWhereInput | sponsorsWhereInput[]
    OR?: sponsorsWhereInput[]
    NOT?: sponsorsWhereInput | sponsorsWhereInput[]
    created_at?: DateTimeFilter<"sponsors"> | Date | string
    updated_at?: DateTimeFilter<"sponsors"> | Date | string
    name?: StringFilter<"sponsors"> | string
    website?: StringFilter<"sponsors"> | string
    logo_path?: StringFilter<"sponsors"> | string
    type?: StringFilter<"sponsors"> | string
    event_sponsors?: Event_sponsorsListRelationFilter
  }, "id">

  export type sponsorsOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    logo_path?: SortOrder
    type?: SortOrder
    _count?: sponsorsCountOrderByAggregateInput
    _avg?: sponsorsAvgOrderByAggregateInput
    _max?: sponsorsMaxOrderByAggregateInput
    _min?: sponsorsMinOrderByAggregateInput
    _sum?: sponsorsSumOrderByAggregateInput
  }

  export type sponsorsScalarWhereWithAggregatesInput = {
    AND?: sponsorsScalarWhereWithAggregatesInput | sponsorsScalarWhereWithAggregatesInput[]
    OR?: sponsorsScalarWhereWithAggregatesInput[]
    NOT?: sponsorsScalarWhereWithAggregatesInput | sponsorsScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"sponsors"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"sponsors"> | Date | string
    id?: IntWithAggregatesFilter<"sponsors"> | number
    name?: StringWithAggregatesFilter<"sponsors"> | string
    website?: StringWithAggregatesFilter<"sponsors"> | string
    logo_path?: StringWithAggregatesFilter<"sponsors"> | string
    type?: StringWithAggregatesFilter<"sponsors"> | string
  }

  export type tagsWhereInput = {
    AND?: tagsWhereInput | tagsWhereInput[]
    OR?: tagsWhereInput[]
    NOT?: tagsWhereInput | tagsWhereInput[]
    created_at?: DateTimeFilter<"tags"> | Date | string
    updated_at?: DateTimeFilter<"tags"> | Date | string
    id?: IntFilter<"tags"> | number
    name?: StringFilter<"tags"> | string
    chapter_tags?: Chapter_tagsListRelationFilter
    event_tags?: Event_tagsListRelationFilter
    venue_tags?: Venue_tagsListRelationFilter
  }

  export type tagsOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    chapter_tags?: chapter_tagsOrderByRelationAggregateInput
    event_tags?: event_tagsOrderByRelationAggregateInput
    venue_tags?: venue_tagsOrderByRelationAggregateInput
  }

  export type tagsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: tagsWhereInput | tagsWhereInput[]
    OR?: tagsWhereInput[]
    NOT?: tagsWhereInput | tagsWhereInput[]
    created_at?: DateTimeFilter<"tags"> | Date | string
    updated_at?: DateTimeFilter<"tags"> | Date | string
    chapter_tags?: Chapter_tagsListRelationFilter
    event_tags?: Event_tagsListRelationFilter
    venue_tags?: Venue_tagsListRelationFilter
  }, "id" | "name">

  export type tagsOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    _count?: tagsCountOrderByAggregateInput
    _avg?: tagsAvgOrderByAggregateInput
    _max?: tagsMaxOrderByAggregateInput
    _min?: tagsMinOrderByAggregateInput
    _sum?: tagsSumOrderByAggregateInput
  }

  export type tagsScalarWhereWithAggregatesInput = {
    AND?: tagsScalarWhereWithAggregatesInput | tagsScalarWhereWithAggregatesInput[]
    OR?: tagsScalarWhereWithAggregatesInput[]
    NOT?: tagsScalarWhereWithAggregatesInput | tagsScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"tags"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"tags"> | Date | string
    id?: IntWithAggregatesFilter<"tags"> | number
    name?: StringWithAggregatesFilter<"tags"> | string
  }

  export type user_bansWhereInput = {
    AND?: user_bansWhereInput | user_bansWhereInput[]
    OR?: user_bansWhereInput[]
    NOT?: user_bansWhereInput | user_bansWhereInput[]
    created_at?: DateTimeFilter<"user_bans"> | Date | string
    updated_at?: DateTimeFilter<"user_bans"> | Date | string
    user_id?: IntFilter<"user_bans"> | number
    chapter_id?: IntFilter<"user_bans"> | number
    chapter?: XOR<ChaptersRelationFilter, chaptersWhereInput>
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type user_bansOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    chapter_id?: SortOrder
    chapter?: chaptersOrderByWithRelationInput
    user?: usersOrderByWithRelationInput
  }

  export type user_bansWhereUniqueInput = Prisma.AtLeast<{
    user_id_chapter_id?: user_bansUser_idChapter_idCompoundUniqueInput
    AND?: user_bansWhereInput | user_bansWhereInput[]
    OR?: user_bansWhereInput[]
    NOT?: user_bansWhereInput | user_bansWhereInput[]
    created_at?: DateTimeFilter<"user_bans"> | Date | string
    updated_at?: DateTimeFilter<"user_bans"> | Date | string
    user_id?: IntFilter<"user_bans"> | number
    chapter_id?: IntFilter<"user_bans"> | number
    chapter?: XOR<ChaptersRelationFilter, chaptersWhereInput>
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "user_id_chapter_id">

  export type user_bansOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    chapter_id?: SortOrder
    _count?: user_bansCountOrderByAggregateInput
    _avg?: user_bansAvgOrderByAggregateInput
    _max?: user_bansMaxOrderByAggregateInput
    _min?: user_bansMinOrderByAggregateInput
    _sum?: user_bansSumOrderByAggregateInput
  }

  export type user_bansScalarWhereWithAggregatesInput = {
    AND?: user_bansScalarWhereWithAggregatesInput | user_bansScalarWhereWithAggregatesInput[]
    OR?: user_bansScalarWhereWithAggregatesInput[]
    NOT?: user_bansScalarWhereWithAggregatesInput | user_bansScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"user_bans"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"user_bans"> | Date | string
    user_id?: IntWithAggregatesFilter<"user_bans"> | number
    chapter_id?: IntWithAggregatesFilter<"user_bans"> | number
  }

  export type instance_permissionsWhereInput = {
    AND?: instance_permissionsWhereInput | instance_permissionsWhereInput[]
    OR?: instance_permissionsWhereInput[]
    NOT?: instance_permissionsWhereInput | instance_permissionsWhereInput[]
    created_at?: DateTimeFilter<"instance_permissions"> | Date | string
    updated_at?: DateTimeFilter<"instance_permissions"> | Date | string
    id?: IntFilter<"instance_permissions"> | number
    name?: StringFilter<"instance_permissions"> | string
    instance_role_permissions?: Instance_role_permissionsListRelationFilter
  }

  export type instance_permissionsOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    instance_role_permissions?: instance_role_permissionsOrderByRelationAggregateInput
  }

  export type instance_permissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: instance_permissionsWhereInput | instance_permissionsWhereInput[]
    OR?: instance_permissionsWhereInput[]
    NOT?: instance_permissionsWhereInput | instance_permissionsWhereInput[]
    created_at?: DateTimeFilter<"instance_permissions"> | Date | string
    updated_at?: DateTimeFilter<"instance_permissions"> | Date | string
    instance_role_permissions?: Instance_role_permissionsListRelationFilter
  }, "id" | "name">

  export type instance_permissionsOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    _count?: instance_permissionsCountOrderByAggregateInput
    _avg?: instance_permissionsAvgOrderByAggregateInput
    _max?: instance_permissionsMaxOrderByAggregateInput
    _min?: instance_permissionsMinOrderByAggregateInput
    _sum?: instance_permissionsSumOrderByAggregateInput
  }

  export type instance_permissionsScalarWhereWithAggregatesInput = {
    AND?: instance_permissionsScalarWhereWithAggregatesInput | instance_permissionsScalarWhereWithAggregatesInput[]
    OR?: instance_permissionsScalarWhereWithAggregatesInput[]
    NOT?: instance_permissionsScalarWhereWithAggregatesInput | instance_permissionsScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"instance_permissions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"instance_permissions"> | Date | string
    id?: IntWithAggregatesFilter<"instance_permissions"> | number
    name?: StringWithAggregatesFilter<"instance_permissions"> | string
  }

  export type instance_role_permissionsWhereInput = {
    AND?: instance_role_permissionsWhereInput | instance_role_permissionsWhereInput[]
    OR?: instance_role_permissionsWhereInput[]
    NOT?: instance_role_permissionsWhereInput | instance_role_permissionsWhereInput[]
    created_at?: DateTimeFilter<"instance_role_permissions"> | Date | string
    updated_at?: DateTimeFilter<"instance_role_permissions"> | Date | string
    instance_role_id?: IntFilter<"instance_role_permissions"> | number
    instance_permission_id?: IntFilter<"instance_role_permissions"> | number
    instance_role?: XOR<Instance_rolesRelationFilter, instance_rolesWhereInput>
    instance_permission?: XOR<Instance_permissionsRelationFilter, instance_permissionsWhereInput>
  }

  export type instance_role_permissionsOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    instance_role_id?: SortOrder
    instance_permission_id?: SortOrder
    instance_role?: instance_rolesOrderByWithRelationInput
    instance_permission?: instance_permissionsOrderByWithRelationInput
  }

  export type instance_role_permissionsWhereUniqueInput = Prisma.AtLeast<{
    instance_role_id_instance_permission_id?: instance_role_permissionsInstance_role_idInstance_permission_idCompoundUniqueInput
    AND?: instance_role_permissionsWhereInput | instance_role_permissionsWhereInput[]
    OR?: instance_role_permissionsWhereInput[]
    NOT?: instance_role_permissionsWhereInput | instance_role_permissionsWhereInput[]
    created_at?: DateTimeFilter<"instance_role_permissions"> | Date | string
    updated_at?: DateTimeFilter<"instance_role_permissions"> | Date | string
    instance_role_id?: IntFilter<"instance_role_permissions"> | number
    instance_permission_id?: IntFilter<"instance_role_permissions"> | number
    instance_role?: XOR<Instance_rolesRelationFilter, instance_rolesWhereInput>
    instance_permission?: XOR<Instance_permissionsRelationFilter, instance_permissionsWhereInput>
  }, "instance_role_id_instance_permission_id">

  export type instance_role_permissionsOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    instance_role_id?: SortOrder
    instance_permission_id?: SortOrder
    _count?: instance_role_permissionsCountOrderByAggregateInput
    _avg?: instance_role_permissionsAvgOrderByAggregateInput
    _max?: instance_role_permissionsMaxOrderByAggregateInput
    _min?: instance_role_permissionsMinOrderByAggregateInput
    _sum?: instance_role_permissionsSumOrderByAggregateInput
  }

  export type instance_role_permissionsScalarWhereWithAggregatesInput = {
    AND?: instance_role_permissionsScalarWhereWithAggregatesInput | instance_role_permissionsScalarWhereWithAggregatesInput[]
    OR?: instance_role_permissionsScalarWhereWithAggregatesInput[]
    NOT?: instance_role_permissionsScalarWhereWithAggregatesInput | instance_role_permissionsScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"instance_role_permissions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"instance_role_permissions"> | Date | string
    instance_role_id?: IntWithAggregatesFilter<"instance_role_permissions"> | number
    instance_permission_id?: IntWithAggregatesFilter<"instance_role_permissions"> | number
  }

  export type instance_rolesWhereInput = {
    AND?: instance_rolesWhereInput | instance_rolesWhereInput[]
    OR?: instance_rolesWhereInput[]
    NOT?: instance_rolesWhereInput | instance_rolesWhereInput[]
    created_at?: DateTimeFilter<"instance_roles"> | Date | string
    updated_at?: DateTimeFilter<"instance_roles"> | Date | string
    id?: IntFilter<"instance_roles"> | number
    name?: StringFilter<"instance_roles"> | string
    instance_role_permissions?: Instance_role_permissionsListRelationFilter
    users?: UsersListRelationFilter
  }

  export type instance_rolesOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    instance_role_permissions?: instance_role_permissionsOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
  }

  export type instance_rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: instance_rolesWhereInput | instance_rolesWhereInput[]
    OR?: instance_rolesWhereInput[]
    NOT?: instance_rolesWhereInput | instance_rolesWhereInput[]
    created_at?: DateTimeFilter<"instance_roles"> | Date | string
    updated_at?: DateTimeFilter<"instance_roles"> | Date | string
    instance_role_permissions?: Instance_role_permissionsListRelationFilter
    users?: UsersListRelationFilter
  }, "id" | "name">

  export type instance_rolesOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    _count?: instance_rolesCountOrderByAggregateInput
    _avg?: instance_rolesAvgOrderByAggregateInput
    _max?: instance_rolesMaxOrderByAggregateInput
    _min?: instance_rolesMinOrderByAggregateInput
    _sum?: instance_rolesSumOrderByAggregateInput
  }

  export type instance_rolesScalarWhereWithAggregatesInput = {
    AND?: instance_rolesScalarWhereWithAggregatesInput | instance_rolesScalarWhereWithAggregatesInput[]
    OR?: instance_rolesScalarWhereWithAggregatesInput[]
    NOT?: instance_rolesScalarWhereWithAggregatesInput | instance_rolesScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"instance_roles"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"instance_roles"> | Date | string
    id?: IntWithAggregatesFilter<"instance_roles"> | number
    name?: StringWithAggregatesFilter<"instance_roles"> | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    id?: IntFilter<"users"> | number
    name?: StringFilter<"users"> | string
    image_url?: StringNullableFilter<"users"> | string | null
    email?: StringFilter<"users"> | string
    auto_subscribe?: BoolFilter<"users"> | boolean
    instance_role_id?: IntFilter<"users"> | number
    user_bans?: User_bansListRelationFilter
    user_chapters?: Chapter_usersListRelationFilter
    instance_role?: XOR<Instance_rolesRelationFilter, instance_rolesWhereInput>
    user_events?: Event_usersListRelationFilter
    session?: XOR<SessionsNullableRelationFilter, sessionsWhereInput> | null
  }

  export type usersOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    image_url?: SortOrderInput | SortOrder
    email?: SortOrder
    auto_subscribe?: SortOrder
    instance_role_id?: SortOrder
    user_bans?: user_bansOrderByRelationAggregateInput
    user_chapters?: chapter_usersOrderByRelationAggregateInput
    instance_role?: instance_rolesOrderByWithRelationInput
    user_events?: event_usersOrderByRelationAggregateInput
    session?: sessionsOrderByWithRelationInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    name?: StringFilter<"users"> | string
    image_url?: StringNullableFilter<"users"> | string | null
    auto_subscribe?: BoolFilter<"users"> | boolean
    instance_role_id?: IntFilter<"users"> | number
    user_bans?: User_bansListRelationFilter
    user_chapters?: Chapter_usersListRelationFilter
    instance_role?: XOR<Instance_rolesRelationFilter, instance_rolesWhereInput>
    user_events?: Event_usersListRelationFilter
    session?: XOR<SessionsNullableRelationFilter, sessionsWhereInput> | null
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    image_url?: SortOrderInput | SortOrder
    email?: SortOrder
    auto_subscribe?: SortOrder
    instance_role_id?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    id?: IntWithAggregatesFilter<"users"> | number
    name?: StringWithAggregatesFilter<"users"> | string
    image_url?: StringNullableWithAggregatesFilter<"users"> | string | null
    email?: StringWithAggregatesFilter<"users"> | string
    auto_subscribe?: BoolWithAggregatesFilter<"users"> | boolean
    instance_role_id?: IntWithAggregatesFilter<"users"> | number
  }

  export type venue_tagsWhereInput = {
    AND?: venue_tagsWhereInput | venue_tagsWhereInput[]
    OR?: venue_tagsWhereInput[]
    NOT?: venue_tagsWhereInput | venue_tagsWhereInput[]
    created_at?: DateTimeFilter<"venue_tags"> | Date | string
    updated_at?: DateTimeFilter<"venue_tags"> | Date | string
    venue_id?: IntFilter<"venue_tags"> | number
    tag_id?: IntFilter<"venue_tags"> | number
    venue?: XOR<VenuesRelationFilter, venuesWhereInput>
    tag?: XOR<TagsRelationFilter, tagsWhereInput>
  }

  export type venue_tagsOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    venue_id?: SortOrder
    tag_id?: SortOrder
    venue?: venuesOrderByWithRelationInput
    tag?: tagsOrderByWithRelationInput
  }

  export type venue_tagsWhereUniqueInput = Prisma.AtLeast<{
    venue_id_tag_id?: venue_tagsVenue_idTag_idCompoundUniqueInput
    AND?: venue_tagsWhereInput | venue_tagsWhereInput[]
    OR?: venue_tagsWhereInput[]
    NOT?: venue_tagsWhereInput | venue_tagsWhereInput[]
    created_at?: DateTimeFilter<"venue_tags"> | Date | string
    updated_at?: DateTimeFilter<"venue_tags"> | Date | string
    venue_id?: IntFilter<"venue_tags"> | number
    tag_id?: IntFilter<"venue_tags"> | number
    venue?: XOR<VenuesRelationFilter, venuesWhereInput>
    tag?: XOR<TagsRelationFilter, tagsWhereInput>
  }, "venue_id_tag_id">

  export type venue_tagsOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    venue_id?: SortOrder
    tag_id?: SortOrder
    _count?: venue_tagsCountOrderByAggregateInput
    _avg?: venue_tagsAvgOrderByAggregateInput
    _max?: venue_tagsMaxOrderByAggregateInput
    _min?: venue_tagsMinOrderByAggregateInput
    _sum?: venue_tagsSumOrderByAggregateInput
  }

  export type venue_tagsScalarWhereWithAggregatesInput = {
    AND?: venue_tagsScalarWhereWithAggregatesInput | venue_tagsScalarWhereWithAggregatesInput[]
    OR?: venue_tagsScalarWhereWithAggregatesInput[]
    NOT?: venue_tagsScalarWhereWithAggregatesInput | venue_tagsScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"venue_tags"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"venue_tags"> | Date | string
    venue_id?: IntWithAggregatesFilter<"venue_tags"> | number
    tag_id?: IntWithAggregatesFilter<"venue_tags"> | number
  }

  export type venuesWhereInput = {
    AND?: venuesWhereInput | venuesWhereInput[]
    OR?: venuesWhereInput[]
    NOT?: venuesWhereInput | venuesWhereInput[]
    created_at?: DateTimeFilter<"venues"> | Date | string
    updated_at?: DateTimeFilter<"venues"> | Date | string
    id?: IntFilter<"venues"> | number
    name?: StringFilter<"venues"> | string
    street_address?: StringNullableFilter<"venues"> | string | null
    city?: StringFilter<"venues"> | string
    postal_code?: StringFilter<"venues"> | string
    region?: StringFilter<"venues"> | string
    country?: StringFilter<"venues"> | string
    latitude?: FloatNullableFilter<"venues"> | number | null
    longitude?: FloatNullableFilter<"venues"> | number | null
    chapter_id?: IntFilter<"venues"> | number
    events?: EventsListRelationFilter
    venue_tags?: Venue_tagsListRelationFilter
    chapter?: XOR<ChaptersRelationFilter, chaptersWhereInput>
  }

  export type venuesOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    street_address?: SortOrderInput | SortOrder
    city?: SortOrder
    postal_code?: SortOrder
    region?: SortOrder
    country?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    chapter_id?: SortOrder
    events?: eventsOrderByRelationAggregateInput
    venue_tags?: venue_tagsOrderByRelationAggregateInput
    chapter?: chaptersOrderByWithRelationInput
  }

  export type venuesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: venuesWhereInput | venuesWhereInput[]
    OR?: venuesWhereInput[]
    NOT?: venuesWhereInput | venuesWhereInput[]
    created_at?: DateTimeFilter<"venues"> | Date | string
    updated_at?: DateTimeFilter<"venues"> | Date | string
    name?: StringFilter<"venues"> | string
    street_address?: StringNullableFilter<"venues"> | string | null
    city?: StringFilter<"venues"> | string
    postal_code?: StringFilter<"venues"> | string
    region?: StringFilter<"venues"> | string
    country?: StringFilter<"venues"> | string
    latitude?: FloatNullableFilter<"venues"> | number | null
    longitude?: FloatNullableFilter<"venues"> | number | null
    chapter_id?: IntFilter<"venues"> | number
    events?: EventsListRelationFilter
    venue_tags?: Venue_tagsListRelationFilter
    chapter?: XOR<ChaptersRelationFilter, chaptersWhereInput>
  }, "id">

  export type venuesOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    street_address?: SortOrderInput | SortOrder
    city?: SortOrder
    postal_code?: SortOrder
    region?: SortOrder
    country?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    chapter_id?: SortOrder
    _count?: venuesCountOrderByAggregateInput
    _avg?: venuesAvgOrderByAggregateInput
    _max?: venuesMaxOrderByAggregateInput
    _min?: venuesMinOrderByAggregateInput
    _sum?: venuesSumOrderByAggregateInput
  }

  export type venuesScalarWhereWithAggregatesInput = {
    AND?: venuesScalarWhereWithAggregatesInput | venuesScalarWhereWithAggregatesInput[]
    OR?: venuesScalarWhereWithAggregatesInput[]
    NOT?: venuesScalarWhereWithAggregatesInput | venuesScalarWhereWithAggregatesInput[]
    created_at?: DateTimeWithAggregatesFilter<"venues"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"venues"> | Date | string
    id?: IntWithAggregatesFilter<"venues"> | number
    name?: StringWithAggregatesFilter<"venues"> | string
    street_address?: StringNullableWithAggregatesFilter<"venues"> | string | null
    city?: StringWithAggregatesFilter<"venues"> | string
    postal_code?: StringWithAggregatesFilter<"venues"> | string
    region?: StringWithAggregatesFilter<"venues"> | string
    country?: StringWithAggregatesFilter<"venues"> | string
    latitude?: FloatNullableWithAggregatesFilter<"venues"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"venues"> | number | null
    chapter_id?: IntWithAggregatesFilter<"venues"> | number
  }

  export type chaptersCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    description: string
    category: string
    city: string
    region: string
    country: string
    logo_url?: string | null
    banner_url?: string | null
    calendar_id?: string | null
    chat_url?: string | null
    creator_id: number
    events?: eventsCreateNestedManyWithoutChapterInput
    user_bans?: user_bansCreateNestedManyWithoutChapterInput
    chapter_users?: chapter_usersCreateNestedManyWithoutChapterInput
    chapter_tags?: chapter_tagsCreateNestedManyWithoutChapterInput
    venues?: venuesCreateNestedManyWithoutChapterInput
  }

  export type chaptersUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    description: string
    category: string
    city: string
    region: string
    country: string
    logo_url?: string | null
    banner_url?: string | null
    calendar_id?: string | null
    chat_url?: string | null
    creator_id: number
    events?: eventsUncheckedCreateNestedManyWithoutChapterInput
    user_bans?: user_bansUncheckedCreateNestedManyWithoutChapterInput
    chapter_users?: chapter_usersUncheckedCreateNestedManyWithoutChapterInput
    chapter_tags?: chapter_tagsUncheckedCreateNestedManyWithoutChapterInput
    venues?: venuesUncheckedCreateNestedManyWithoutChapterInput
  }

  export type chaptersUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    calendar_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_url?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    events?: eventsUpdateManyWithoutChapterNestedInput
    user_bans?: user_bansUpdateManyWithoutChapterNestedInput
    chapter_users?: chapter_usersUpdateManyWithoutChapterNestedInput
    chapter_tags?: chapter_tagsUpdateManyWithoutChapterNestedInput
    venues?: venuesUpdateManyWithoutChapterNestedInput
  }

  export type chaptersUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    calendar_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_url?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    events?: eventsUncheckedUpdateManyWithoutChapterNestedInput
    user_bans?: user_bansUncheckedUpdateManyWithoutChapterNestedInput
    chapter_users?: chapter_usersUncheckedUpdateManyWithoutChapterNestedInput
    chapter_tags?: chapter_tagsUncheckedUpdateManyWithoutChapterNestedInput
    venues?: venuesUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type chaptersCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    description: string
    category: string
    city: string
    region: string
    country: string
    logo_url?: string | null
    banner_url?: string | null
    calendar_id?: string | null
    chat_url?: string | null
    creator_id: number
  }

  export type chaptersUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    calendar_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_url?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
  }

  export type chaptersUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    calendar_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_url?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
  }

  export type sessionsCreateInput = {
    user: usersCreateNestedOneWithoutSessionInput
  }

  export type sessionsUncheckedCreateInput = {
    id?: number
    user_id: number
  }

  export type sessionsUpdateInput = {
    user?: usersUpdateOneRequiredWithoutSessionNestedInput
  }

  export type sessionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type sessionsCreateManyInput = {
    id?: number
    user_id: number
  }

  export type sessionsUpdateManyMutationInput = {

  }

  export type sessionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type google_tokensCreateInput = {
    email: string
    access_token: string
    refresh_token: string
    expiry_date: bigint | number
    is_valid?: boolean
  }

  export type google_tokensUncheckedCreateInput = {
    id?: number
    email: string
    access_token: string
    refresh_token: string
    expiry_date: bigint | number
    is_valid?: boolean
  }

  export type google_tokensUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    access_token?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    expiry_date?: BigIntFieldUpdateOperationsInput | bigint | number
    is_valid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type google_tokensUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    access_token?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    expiry_date?: BigIntFieldUpdateOperationsInput | bigint | number
    is_valid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type google_tokensCreateManyInput = {
    id?: number
    email: string
    access_token: string
    refresh_token: string
    expiry_date: bigint | number
    is_valid?: boolean
  }

  export type google_tokensUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    access_token?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    expiry_date?: BigIntFieldUpdateOperationsInput | bigint | number
    is_valid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type google_tokensUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    access_token?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    expiry_date?: BigIntFieldUpdateOperationsInput | bigint | number
    is_valid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chapter_usersCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date: Date | string
    subscribed: boolean
    user: usersCreateNestedOneWithoutUser_chaptersInput
    chapter: chaptersCreateNestedOneWithoutChapter_usersInput
    chapter_role: chapter_rolesCreateNestedOneWithoutChapter_usersInput
  }

  export type chapter_usersUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date: Date | string
    user_id: number
    chapter_id: number
    chapter_role_id: number
    subscribed: boolean
  }

  export type chapter_usersUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    user?: usersUpdateOneRequiredWithoutUser_chaptersNestedInput
    chapter?: chaptersUpdateOneRequiredWithoutChapter_usersNestedInput
    chapter_role?: chapter_rolesUpdateOneRequiredWithoutChapter_usersNestedInput
  }

  export type chapter_usersUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    chapter_id?: IntFieldUpdateOperationsInput | number
    chapter_role_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chapter_usersCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date: Date | string
    user_id: number
    chapter_id: number
    chapter_role_id: number
    subscribed: boolean
  }

  export type chapter_usersUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chapter_usersUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    chapter_id?: IntFieldUpdateOperationsInput | number
    chapter_role_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chapter_rolesCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    chapter_users?: chapter_usersCreateNestedManyWithoutChapter_roleInput
    chapter_role_permissions?: chapter_role_permissionsCreateNestedManyWithoutChapter_roleInput
  }

  export type chapter_rolesUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    chapter_users?: chapter_usersUncheckedCreateNestedManyWithoutChapter_roleInput
    chapter_role_permissions?: chapter_role_permissionsUncheckedCreateNestedManyWithoutChapter_roleInput
  }

  export type chapter_rolesUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    chapter_users?: chapter_usersUpdateManyWithoutChapter_roleNestedInput
    chapter_role_permissions?: chapter_role_permissionsUpdateManyWithoutChapter_roleNestedInput
  }

  export type chapter_rolesUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    chapter_users?: chapter_usersUncheckedUpdateManyWithoutChapter_roleNestedInput
    chapter_role_permissions?: chapter_role_permissionsUncheckedUpdateManyWithoutChapter_roleNestedInput
  }

  export type chapter_rolesCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
  }

  export type chapter_rolesUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type chapter_rolesUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type chapter_role_permissionsCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter_role: chapter_rolesCreateNestedOneWithoutChapter_role_permissionsInput
    chapter_permission: chapter_permissionsCreateNestedOneWithoutChapter_role_permissionsInput
  }

  export type chapter_role_permissionsUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter_role_id: number
    chapter_permissions_id: number
  }

  export type chapter_role_permissionsUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter_role?: chapter_rolesUpdateOneRequiredWithoutChapter_role_permissionsNestedInput
    chapter_permission?: chapter_permissionsUpdateOneRequiredWithoutChapter_role_permissionsNestedInput
  }

  export type chapter_role_permissionsUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter_role_id?: IntFieldUpdateOperationsInput | number
    chapter_permissions_id?: IntFieldUpdateOperationsInput | number
  }

  export type chapter_role_permissionsCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter_role_id: number
    chapter_permissions_id: number
  }

  export type chapter_role_permissionsUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chapter_role_permissionsUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter_role_id?: IntFieldUpdateOperationsInput | number
    chapter_permissions_id?: IntFieldUpdateOperationsInput | number
  }

  export type chapter_permissionsCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    chapter_role_permissions?: chapter_role_permissionsCreateNestedManyWithoutChapter_permissionInput
  }

  export type chapter_permissionsUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    chapter_role_permissions?: chapter_role_permissionsUncheckedCreateNestedManyWithoutChapter_permissionInput
  }

  export type chapter_permissionsUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    chapter_role_permissions?: chapter_role_permissionsUpdateManyWithoutChapter_permissionNestedInput
  }

  export type chapter_permissionsUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    chapter_role_permissions?: chapter_role_permissionsUncheckedUpdateManyWithoutChapter_permissionNestedInput
  }

  export type chapter_permissionsCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
  }

  export type chapter_permissionsUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type chapter_permissionsUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type chapter_tagsCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter: chaptersCreateNestedOneWithoutChapter_tagsInput
    tag: tagsCreateNestedOneWithoutChapter_tagsInput
  }

  export type chapter_tagsUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter_id: number
    tag_id: number
  }

  export type chapter_tagsUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: chaptersUpdateOneRequiredWithoutChapter_tagsNestedInput
    tag?: tagsUpdateOneRequiredWithoutChapter_tagsNestedInput
  }

  export type chapter_tagsUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter_id?: IntFieldUpdateOperationsInput | number
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type chapter_tagsCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter_id: number
    tag_id: number
  }

  export type chapter_tagsUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chapter_tagsUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter_id?: IntFieldUpdateOperationsInput | number
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type event_sponsorsCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event: eventsCreateNestedOneWithoutSponsorsInput
    sponsor: sponsorsCreateNestedOneWithoutEvent_sponsorsInput
  }

  export type event_sponsorsUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    sponsor_id: number
    event_id: number
  }

  export type event_sponsorsUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: eventsUpdateOneRequiredWithoutSponsorsNestedInput
    sponsor?: sponsorsUpdateOneRequiredWithoutEvent_sponsorsNestedInput
  }

  export type event_sponsorsUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sponsor_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type event_sponsorsCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    sponsor_id: number
    event_id: number
  }

  export type event_sponsorsUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type event_sponsorsUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sponsor_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type event_tagsCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event: eventsCreateNestedOneWithoutEvent_tagsInput
    tag: tagsCreateNestedOneWithoutEvent_tagsInput
  }

  export type event_tagsUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event_id: number
    tag_id: number
  }

  export type event_tagsUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: eventsUpdateOneRequiredWithoutEvent_tagsNestedInput
    tag?: tagsUpdateOneRequiredWithoutEvent_tagsNestedInput
  }

  export type event_tagsUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_id?: IntFieldUpdateOperationsInput | number
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type event_tagsCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event_id: number
    tag_id: number
  }

  export type event_tagsUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type event_tagsUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_id?: IntFieldUpdateOperationsInput | number
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type eventsCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    description: string
    url?: string | null
    streaming_url?: string | null
    venue_type?: events_venue_type_enum
    start_at: Date | string
    ends_at: Date | string
    canceled?: boolean
    capacity: number
    invite_only?: boolean
    image_url: string
    calendar_event_id?: string | null
    chapter: chaptersCreateNestedOneWithoutEventsInput
    venue?: venuesCreateNestedOneWithoutEventsInput
    sponsors?: event_sponsorsCreateNestedManyWithoutEventInput
    event_tags?: event_tagsCreateNestedManyWithoutEventInput
    event_users?: event_usersCreateNestedManyWithoutEventInput
  }

  export type eventsUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    description: string
    url?: string | null
    streaming_url?: string | null
    venue_type?: events_venue_type_enum
    start_at: Date | string
    ends_at: Date | string
    canceled?: boolean
    capacity: number
    invite_only?: boolean
    image_url: string
    venue_id?: number | null
    chapter_id: number
    calendar_event_id?: string | null
    sponsors?: event_sponsorsUncheckedCreateNestedManyWithoutEventInput
    event_tags?: event_tagsUncheckedCreateNestedManyWithoutEventInput
    event_users?: event_usersUncheckedCreateNestedManyWithoutEventInput
  }

  export type eventsUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    venue_type?: Enumevents_venue_type_enumFieldUpdateOperationsInput | events_venue_type_enum
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    canceled?: BoolFieldUpdateOperationsInput | boolean
    capacity?: IntFieldUpdateOperationsInput | number
    invite_only?: BoolFieldUpdateOperationsInput | boolean
    image_url?: StringFieldUpdateOperationsInput | string
    calendar_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: chaptersUpdateOneRequiredWithoutEventsNestedInput
    venue?: venuesUpdateOneWithoutEventsNestedInput
    sponsors?: event_sponsorsUpdateManyWithoutEventNestedInput
    event_tags?: event_tagsUpdateManyWithoutEventNestedInput
    event_users?: event_usersUpdateManyWithoutEventNestedInput
  }

  export type eventsUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    venue_type?: Enumevents_venue_type_enumFieldUpdateOperationsInput | events_venue_type_enum
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    canceled?: BoolFieldUpdateOperationsInput | boolean
    capacity?: IntFieldUpdateOperationsInput | number
    invite_only?: BoolFieldUpdateOperationsInput | boolean
    image_url?: StringFieldUpdateOperationsInput | string
    venue_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_id?: IntFieldUpdateOperationsInput | number
    calendar_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    sponsors?: event_sponsorsUncheckedUpdateManyWithoutEventNestedInput
    event_tags?: event_tagsUncheckedUpdateManyWithoutEventNestedInput
    event_users?: event_usersUncheckedUpdateManyWithoutEventNestedInput
  }

  export type eventsCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    description: string
    url?: string | null
    streaming_url?: string | null
    venue_type?: events_venue_type_enum
    start_at: Date | string
    ends_at: Date | string
    canceled?: boolean
    capacity: number
    invite_only?: boolean
    image_url: string
    venue_id?: number | null
    chapter_id: number
    calendar_event_id?: string | null
  }

  export type eventsUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    venue_type?: Enumevents_venue_type_enumFieldUpdateOperationsInput | events_venue_type_enum
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    canceled?: BoolFieldUpdateOperationsInput | boolean
    capacity?: IntFieldUpdateOperationsInput | number
    invite_only?: BoolFieldUpdateOperationsInput | boolean
    image_url?: StringFieldUpdateOperationsInput | string
    calendar_event_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eventsUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    venue_type?: Enumevents_venue_type_enumFieldUpdateOperationsInput | events_venue_type_enum
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    canceled?: BoolFieldUpdateOperationsInput | boolean
    capacity?: IntFieldUpdateOperationsInput | number
    invite_only?: BoolFieldUpdateOperationsInput | boolean
    image_url?: StringFieldUpdateOperationsInput | string
    venue_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_id?: IntFieldUpdateOperationsInput | number
    calendar_event_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type event_rolesCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    event_role_permissions?: event_role_permissionsCreateNestedManyWithoutEvent_roleInput
    event_users?: event_usersCreateNestedManyWithoutEvent_roleInput
  }

  export type event_rolesUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    event_role_permissions?: event_role_permissionsUncheckedCreateNestedManyWithoutEvent_roleInput
    event_users?: event_usersUncheckedCreateNestedManyWithoutEvent_roleInput
  }

  export type event_rolesUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    event_role_permissions?: event_role_permissionsUpdateManyWithoutEvent_roleNestedInput
    event_users?: event_usersUpdateManyWithoutEvent_roleNestedInput
  }

  export type event_rolesUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    event_role_permissions?: event_role_permissionsUncheckedUpdateManyWithoutEvent_roleNestedInput
    event_users?: event_usersUncheckedUpdateManyWithoutEvent_roleNestedInput
  }

  export type event_rolesCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
  }

  export type event_rolesUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type event_rolesUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type event_role_permissionsCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event_role: event_rolesCreateNestedOneWithoutEvent_role_permissionsInput
    event_permission: event_permissionsCreateNestedOneWithoutEvent_role_permissionsInput
  }

  export type event_role_permissionsUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event_role_id: number
    event_permission_id: number
  }

  export type event_role_permissionsUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_role?: event_rolesUpdateOneRequiredWithoutEvent_role_permissionsNestedInput
    event_permission?: event_permissionsUpdateOneRequiredWithoutEvent_role_permissionsNestedInput
  }

  export type event_role_permissionsUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_role_id?: IntFieldUpdateOperationsInput | number
    event_permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type event_role_permissionsCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event_role_id: number
    event_permission_id: number
  }

  export type event_role_permissionsUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type event_role_permissionsUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_role_id?: IntFieldUpdateOperationsInput | number
    event_permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type event_permissionsCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    event_role_permissions?: event_role_permissionsCreateNestedManyWithoutEvent_permissionInput
  }

  export type event_permissionsUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    event_role_permissions?: event_role_permissionsUncheckedCreateNestedManyWithoutEvent_permissionInput
  }

  export type event_permissionsUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    event_role_permissions?: event_role_permissionsUpdateManyWithoutEvent_permissionNestedInput
  }

  export type event_permissionsUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    event_role_permissions?: event_role_permissionsUncheckedUpdateManyWithoutEvent_permissionNestedInput
  }

  export type event_permissionsCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
  }

  export type event_permissionsUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type event_permissionsUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type event_usersCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date?: Date | string
    subscribed: boolean
    title?: event_usersCreatetitleInput | string[]
    user: usersCreateNestedOneWithoutUser_eventsInput
    event: eventsCreateNestedOneWithoutEvent_usersInput
    event_role: event_rolesCreateNestedOneWithoutEvent_usersInput
    attendance: attendanceCreateNestedOneWithoutEvent_usersInput
    event_reminder?: event_remindersCreateNestedOneWithoutEvent_userInput
  }

  export type event_usersUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date?: Date | string
    user_id: number
    event_id: number
    event_role_id: number
    attendance_id: number
    subscribed: boolean
    title?: event_usersCreatetitleInput | string[]
    event_reminder?: event_remindersUncheckedCreateNestedOneWithoutEvent_userInput
  }

  export type event_usersUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    title?: event_usersUpdatetitleInput | string[]
    user?: usersUpdateOneRequiredWithoutUser_eventsNestedInput
    event?: eventsUpdateOneRequiredWithoutEvent_usersNestedInput
    event_role?: event_rolesUpdateOneRequiredWithoutEvent_usersNestedInput
    attendance?: attendanceUpdateOneRequiredWithoutEvent_usersNestedInput
    event_reminder?: event_remindersUpdateOneWithoutEvent_userNestedInput
  }

  export type event_usersUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    event_role_id?: IntFieldUpdateOperationsInput | number
    attendance_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    title?: event_usersUpdatetitleInput | string[]
    event_reminder?: event_remindersUncheckedUpdateOneWithoutEvent_userNestedInput
  }

  export type event_usersCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date?: Date | string
    user_id: number
    event_id: number
    event_role_id: number
    attendance_id: number
    subscribed: boolean
    title?: event_usersCreatetitleInput | string[]
  }

  export type event_usersUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    title?: event_usersUpdatetitleInput | string[]
  }

  export type event_usersUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    event_role_id?: IntFieldUpdateOperationsInput | number
    attendance_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    title?: event_usersUpdatetitleInput | string[]
  }

  export type event_remindersCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    remind_at: Date | string
    notifying?: boolean
    event_user: event_usersCreateNestedOneWithoutEvent_reminderInput
  }

  export type event_remindersUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    user_id: number
    event_id: number
    remind_at: Date | string
    notifying?: boolean
  }

  export type event_remindersUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    remind_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notifying?: BoolFieldUpdateOperationsInput | boolean
    event_user?: event_usersUpdateOneRequiredWithoutEvent_reminderNestedInput
  }

  export type event_remindersUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    remind_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notifying?: BoolFieldUpdateOperationsInput | boolean
  }

  export type event_remindersCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    user_id: number
    event_id: number
    remind_at: Date | string
    notifying?: boolean
  }

  export type event_remindersUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    remind_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notifying?: BoolFieldUpdateOperationsInput | boolean
  }

  export type event_remindersUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    remind_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notifying?: BoolFieldUpdateOperationsInput | boolean
  }

  export type attendanceCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    event_users?: event_usersCreateNestedManyWithoutAttendanceInput
  }

  export type attendanceUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    event_users?: event_usersUncheckedCreateNestedManyWithoutAttendanceInput
  }

  export type attendanceUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    event_users?: event_usersUpdateManyWithoutAttendanceNestedInput
  }

  export type attendanceUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    event_users?: event_usersUncheckedUpdateManyWithoutAttendanceNestedInput
  }

  export type attendanceCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
  }

  export type attendanceUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type attendanceUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type sponsorsCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    website: string
    logo_path: string
    type: string
    event_sponsors?: event_sponsorsCreateNestedManyWithoutSponsorInput
  }

  export type sponsorsUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    website: string
    logo_path: string
    type: string
    event_sponsors?: event_sponsorsUncheckedCreateNestedManyWithoutSponsorInput
  }

  export type sponsorsUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    logo_path?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    event_sponsors?: event_sponsorsUpdateManyWithoutSponsorNestedInput
  }

  export type sponsorsUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    logo_path?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    event_sponsors?: event_sponsorsUncheckedUpdateManyWithoutSponsorNestedInput
  }

  export type sponsorsCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    website: string
    logo_path: string
    type: string
  }

  export type sponsorsUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    logo_path?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type sponsorsUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    logo_path?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type tagsCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    chapter_tags?: chapter_tagsCreateNestedManyWithoutTagInput
    event_tags?: event_tagsCreateNestedManyWithoutTagInput
    venue_tags?: venue_tagsCreateNestedManyWithoutTagInput
  }

  export type tagsUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    chapter_tags?: chapter_tagsUncheckedCreateNestedManyWithoutTagInput
    event_tags?: event_tagsUncheckedCreateNestedManyWithoutTagInput
    venue_tags?: venue_tagsUncheckedCreateNestedManyWithoutTagInput
  }

  export type tagsUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    chapter_tags?: chapter_tagsUpdateManyWithoutTagNestedInput
    event_tags?: event_tagsUpdateManyWithoutTagNestedInput
    venue_tags?: venue_tagsUpdateManyWithoutTagNestedInput
  }

  export type tagsUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    chapter_tags?: chapter_tagsUncheckedUpdateManyWithoutTagNestedInput
    event_tags?: event_tagsUncheckedUpdateManyWithoutTagNestedInput
    venue_tags?: venue_tagsUncheckedUpdateManyWithoutTagNestedInput
  }

  export type tagsCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
  }

  export type tagsUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type tagsUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type user_bansCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter: chaptersCreateNestedOneWithoutUser_bansInput
    user: usersCreateNestedOneWithoutUser_bansInput
  }

  export type user_bansUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    user_id: number
    chapter_id: number
  }

  export type user_bansUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: chaptersUpdateOneRequiredWithoutUser_bansNestedInput
    user?: usersUpdateOneRequiredWithoutUser_bansNestedInput
  }

  export type user_bansUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    chapter_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_bansCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    user_id: number
    chapter_id: number
  }

  export type user_bansUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_bansUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    chapter_id?: IntFieldUpdateOperationsInput | number
  }

  export type instance_permissionsCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    instance_role_permissions?: instance_role_permissionsCreateNestedManyWithoutInstance_permissionInput
  }

  export type instance_permissionsUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    instance_role_permissions?: instance_role_permissionsUncheckedCreateNestedManyWithoutInstance_permissionInput
  }

  export type instance_permissionsUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    instance_role_permissions?: instance_role_permissionsUpdateManyWithoutInstance_permissionNestedInput
  }

  export type instance_permissionsUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    instance_role_permissions?: instance_role_permissionsUncheckedUpdateManyWithoutInstance_permissionNestedInput
  }

  export type instance_permissionsCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
  }

  export type instance_permissionsUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type instance_permissionsUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type instance_role_permissionsCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    instance_role: instance_rolesCreateNestedOneWithoutInstance_role_permissionsInput
    instance_permission: instance_permissionsCreateNestedOneWithoutInstance_role_permissionsInput
  }

  export type instance_role_permissionsUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    instance_role_id: number
    instance_permission_id: number
  }

  export type instance_role_permissionsUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_role?: instance_rolesUpdateOneRequiredWithoutInstance_role_permissionsNestedInput
    instance_permission?: instance_permissionsUpdateOneRequiredWithoutInstance_role_permissionsNestedInput
  }

  export type instance_role_permissionsUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_role_id?: IntFieldUpdateOperationsInput | number
    instance_permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type instance_role_permissionsCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    instance_role_id: number
    instance_permission_id: number
  }

  export type instance_role_permissionsUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type instance_role_permissionsUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_role_id?: IntFieldUpdateOperationsInput | number
    instance_permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type instance_rolesCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    instance_role_permissions?: instance_role_permissionsCreateNestedManyWithoutInstance_roleInput
    users?: usersCreateNestedManyWithoutInstance_roleInput
  }

  export type instance_rolesUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    instance_role_permissions?: instance_role_permissionsUncheckedCreateNestedManyWithoutInstance_roleInput
    users?: usersUncheckedCreateNestedManyWithoutInstance_roleInput
  }

  export type instance_rolesUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    instance_role_permissions?: instance_role_permissionsUpdateManyWithoutInstance_roleNestedInput
    users?: usersUpdateManyWithoutInstance_roleNestedInput
  }

  export type instance_rolesUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    instance_role_permissions?: instance_role_permissionsUncheckedUpdateManyWithoutInstance_roleNestedInput
    users?: usersUncheckedUpdateManyWithoutInstance_roleNestedInput
  }

  export type instance_rolesCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
  }

  export type instance_rolesUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type instance_rolesUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type usersCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    image_url?: string | null
    email: string
    auto_subscribe?: boolean
    user_bans?: user_bansCreateNestedManyWithoutUserInput
    user_chapters?: chapter_usersCreateNestedManyWithoutUserInput
    instance_role: instance_rolesCreateNestedOneWithoutUsersInput
    user_events?: event_usersCreateNestedManyWithoutUserInput
    session?: sessionsCreateNestedOneWithoutUserInput
  }

  export type usersUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    image_url?: string | null
    email: string
    auto_subscribe?: boolean
    instance_role_id: number
    user_bans?: user_bansUncheckedCreateNestedManyWithoutUserInput
    user_chapters?: chapter_usersUncheckedCreateNestedManyWithoutUserInput
    user_events?: event_usersUncheckedCreateNestedManyWithoutUserInput
    session?: sessionsUncheckedCreateNestedOneWithoutUserInput
  }

  export type usersUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    auto_subscribe?: BoolFieldUpdateOperationsInput | boolean
    user_bans?: user_bansUpdateManyWithoutUserNestedInput
    user_chapters?: chapter_usersUpdateManyWithoutUserNestedInput
    instance_role?: instance_rolesUpdateOneRequiredWithoutUsersNestedInput
    user_events?: event_usersUpdateManyWithoutUserNestedInput
    session?: sessionsUpdateOneWithoutUserNestedInput
  }

  export type usersUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    auto_subscribe?: BoolFieldUpdateOperationsInput | boolean
    instance_role_id?: IntFieldUpdateOperationsInput | number
    user_bans?: user_bansUncheckedUpdateManyWithoutUserNestedInput
    user_chapters?: chapter_usersUncheckedUpdateManyWithoutUserNestedInput
    user_events?: event_usersUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type usersCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    image_url?: string | null
    email: string
    auto_subscribe?: boolean
    instance_role_id: number
  }

  export type usersUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    auto_subscribe?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usersUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    auto_subscribe?: BoolFieldUpdateOperationsInput | boolean
    instance_role_id?: IntFieldUpdateOperationsInput | number
  }

  export type venue_tagsCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    venue: venuesCreateNestedOneWithoutVenue_tagsInput
    tag: tagsCreateNestedOneWithoutVenue_tagsInput
  }

  export type venue_tagsUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    venue_id: number
    tag_id: number
  }

  export type venue_tagsUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: venuesUpdateOneRequiredWithoutVenue_tagsNestedInput
    tag?: tagsUpdateOneRequiredWithoutVenue_tagsNestedInput
  }

  export type venue_tagsUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type venue_tagsCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    venue_id: number
    tag_id: number
  }

  export type venue_tagsUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type venue_tagsUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type venuesCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    street_address?: string | null
    city: string
    postal_code: string
    region: string
    country: string
    latitude?: number | null
    longitude?: number | null
    events?: eventsCreateNestedManyWithoutVenueInput
    venue_tags?: venue_tagsCreateNestedManyWithoutVenueInput
    chapter: chaptersCreateNestedOneWithoutVenuesInput
  }

  export type venuesUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    street_address?: string | null
    city: string
    postal_code: string
    region: string
    country: string
    latitude?: number | null
    longitude?: number | null
    chapter_id: number
    events?: eventsUncheckedCreateNestedManyWithoutVenueInput
    venue_tags?: venue_tagsUncheckedCreateNestedManyWithoutVenueInput
  }

  export type venuesUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    events?: eventsUpdateManyWithoutVenueNestedInput
    venue_tags?: venue_tagsUpdateManyWithoutVenueNestedInput
    chapter?: chaptersUpdateOneRequiredWithoutVenuesNestedInput
  }

  export type venuesUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    chapter_id?: IntFieldUpdateOperationsInput | number
    events?: eventsUncheckedUpdateManyWithoutVenueNestedInput
    venue_tags?: venue_tagsUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type venuesCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    street_address?: string | null
    city: string
    postal_code: string
    region: string
    country: string
    latitude?: number | null
    longitude?: number | null
    chapter_id: number
  }

  export type venuesUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type venuesUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    chapter_id?: IntFieldUpdateOperationsInput | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EventsListRelationFilter = {
    every?: eventsWhereInput
    some?: eventsWhereInput
    none?: eventsWhereInput
  }

  export type User_bansListRelationFilter = {
    every?: user_bansWhereInput
    some?: user_bansWhereInput
    none?: user_bansWhereInput
  }

  export type Chapter_usersListRelationFilter = {
    every?: chapter_usersWhereInput
    some?: chapter_usersWhereInput
    none?: chapter_usersWhereInput
  }

  export type Chapter_tagsListRelationFilter = {
    every?: chapter_tagsWhereInput
    some?: chapter_tagsWhereInput
    none?: chapter_tagsWhereInput
  }

  export type VenuesListRelationFilter = {
    every?: venuesWhereInput
    some?: venuesWhereInput
    none?: venuesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type eventsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_bansOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chapter_usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chapter_tagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type venuesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chaptersCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    logo_url?: SortOrder
    banner_url?: SortOrder
    calendar_id?: SortOrder
    chat_url?: SortOrder
    creator_id?: SortOrder
  }

  export type chaptersAvgOrderByAggregateInput = {
    id?: SortOrder
    creator_id?: SortOrder
  }

  export type chaptersMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    logo_url?: SortOrder
    banner_url?: SortOrder
    calendar_id?: SortOrder
    chat_url?: SortOrder
    creator_id?: SortOrder
  }

  export type chaptersMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    logo_url?: SortOrder
    banner_url?: SortOrder
    calendar_id?: SortOrder
    chat_url?: SortOrder
    creator_id?: SortOrder
  }

  export type chaptersSumOrderByAggregateInput = {
    id?: SortOrder
    creator_id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type sessionsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type sessionsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type google_tokensCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    access_token?: SortOrder
    refresh_token?: SortOrder
    expiry_date?: SortOrder
    is_valid?: SortOrder
  }

  export type google_tokensAvgOrderByAggregateInput = {
    id?: SortOrder
    expiry_date?: SortOrder
  }

  export type google_tokensMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    access_token?: SortOrder
    refresh_token?: SortOrder
    expiry_date?: SortOrder
    is_valid?: SortOrder
  }

  export type google_tokensMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    access_token?: SortOrder
    refresh_token?: SortOrder
    expiry_date?: SortOrder
    is_valid?: SortOrder
  }

  export type google_tokensSumOrderByAggregateInput = {
    id?: SortOrder
    expiry_date?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ChaptersRelationFilter = {
    is?: chaptersWhereInput
    isNot?: chaptersWhereInput
  }

  export type Chapter_rolesRelationFilter = {
    is?: chapter_rolesWhereInput
    isNot?: chapter_rolesWhereInput
  }

  export type chapter_usersUser_idChapter_idCompoundUniqueInput = {
    user_id: number
    chapter_id: number
  }

  export type chapter_usersCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    joined_date?: SortOrder
    user_id?: SortOrder
    chapter_id?: SortOrder
    chapter_role_id?: SortOrder
    subscribed?: SortOrder
  }

  export type chapter_usersAvgOrderByAggregateInput = {
    user_id?: SortOrder
    chapter_id?: SortOrder
    chapter_role_id?: SortOrder
  }

  export type chapter_usersMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    joined_date?: SortOrder
    user_id?: SortOrder
    chapter_id?: SortOrder
    chapter_role_id?: SortOrder
    subscribed?: SortOrder
  }

  export type chapter_usersMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    joined_date?: SortOrder
    user_id?: SortOrder
    chapter_id?: SortOrder
    chapter_role_id?: SortOrder
    subscribed?: SortOrder
  }

  export type chapter_usersSumOrderByAggregateInput = {
    user_id?: SortOrder
    chapter_id?: SortOrder
    chapter_role_id?: SortOrder
  }

  export type Chapter_role_permissionsListRelationFilter = {
    every?: chapter_role_permissionsWhereInput
    some?: chapter_role_permissionsWhereInput
    none?: chapter_role_permissionsWhereInput
  }

  export type chapter_role_permissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chapter_rolesCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type chapter_rolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type chapter_rolesMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type chapter_rolesMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type chapter_rolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Chapter_permissionsRelationFilter = {
    is?: chapter_permissionsWhereInput
    isNot?: chapter_permissionsWhereInput
  }

  export type chapter_role_permissionsChapter_role_idChapter_permissions_idCompoundUniqueInput = {
    chapter_role_id: number
    chapter_permissions_id: number
  }

  export type chapter_role_permissionsCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    chapter_role_id?: SortOrder
    chapter_permissions_id?: SortOrder
  }

  export type chapter_role_permissionsAvgOrderByAggregateInput = {
    chapter_role_id?: SortOrder
    chapter_permissions_id?: SortOrder
  }

  export type chapter_role_permissionsMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    chapter_role_id?: SortOrder
    chapter_permissions_id?: SortOrder
  }

  export type chapter_role_permissionsMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    chapter_role_id?: SortOrder
    chapter_permissions_id?: SortOrder
  }

  export type chapter_role_permissionsSumOrderByAggregateInput = {
    chapter_role_id?: SortOrder
    chapter_permissions_id?: SortOrder
  }

  export type chapter_permissionsCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type chapter_permissionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type chapter_permissionsMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type chapter_permissionsMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type chapter_permissionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagsRelationFilter = {
    is?: tagsWhereInput
    isNot?: tagsWhereInput
  }

  export type chapter_tagsChapter_idTag_idCompoundUniqueInput = {
    chapter_id: number
    tag_id: number
  }

  export type chapter_tagsCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    chapter_id?: SortOrder
    tag_id?: SortOrder
  }

  export type chapter_tagsAvgOrderByAggregateInput = {
    chapter_id?: SortOrder
    tag_id?: SortOrder
  }

  export type chapter_tagsMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    chapter_id?: SortOrder
    tag_id?: SortOrder
  }

  export type chapter_tagsMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    chapter_id?: SortOrder
    tag_id?: SortOrder
  }

  export type chapter_tagsSumOrderByAggregateInput = {
    chapter_id?: SortOrder
    tag_id?: SortOrder
  }

  export type EventsRelationFilter = {
    is?: eventsWhereInput
    isNot?: eventsWhereInput
  }

  export type SponsorsRelationFilter = {
    is?: sponsorsWhereInput
    isNot?: sponsorsWhereInput
  }

  export type event_sponsorsSponsor_idEvent_idCompoundUniqueInput = {
    sponsor_id: number
    event_id: number
  }

  export type event_sponsorsCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    sponsor_id?: SortOrder
    event_id?: SortOrder
  }

  export type event_sponsorsAvgOrderByAggregateInput = {
    sponsor_id?: SortOrder
    event_id?: SortOrder
  }

  export type event_sponsorsMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    sponsor_id?: SortOrder
    event_id?: SortOrder
  }

  export type event_sponsorsMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    sponsor_id?: SortOrder
    event_id?: SortOrder
  }

  export type event_sponsorsSumOrderByAggregateInput = {
    sponsor_id?: SortOrder
    event_id?: SortOrder
  }

  export type event_tagsEvent_idTag_idCompoundUniqueInput = {
    event_id: number
    tag_id: number
  }

  export type event_tagsCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    event_id?: SortOrder
    tag_id?: SortOrder
  }

  export type event_tagsAvgOrderByAggregateInput = {
    event_id?: SortOrder
    tag_id?: SortOrder
  }

  export type event_tagsMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    event_id?: SortOrder
    tag_id?: SortOrder
  }

  export type event_tagsMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    event_id?: SortOrder
    tag_id?: SortOrder
  }

  export type event_tagsSumOrderByAggregateInput = {
    event_id?: SortOrder
    tag_id?: SortOrder
  }

  export type Enumevents_venue_type_enumFilter<$PrismaModel = never> = {
    equals?: events_venue_type_enum | Enumevents_venue_type_enumFieldRefInput<$PrismaModel>
    in?: events_venue_type_enum[] | ListEnumevents_venue_type_enumFieldRefInput<$PrismaModel>
    notIn?: events_venue_type_enum[] | ListEnumevents_venue_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumevents_venue_type_enumFilter<$PrismaModel> | events_venue_type_enum
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type VenuesNullableRelationFilter = {
    is?: venuesWhereInput | null
    isNot?: venuesWhereInput | null
  }

  export type Event_sponsorsListRelationFilter = {
    every?: event_sponsorsWhereInput
    some?: event_sponsorsWhereInput
    none?: event_sponsorsWhereInput
  }

  export type Event_tagsListRelationFilter = {
    every?: event_tagsWhereInput
    some?: event_tagsWhereInput
    none?: event_tagsWhereInput
  }

  export type Event_usersListRelationFilter = {
    every?: event_usersWhereInput
    some?: event_usersWhereInput
    none?: event_usersWhereInput
  }

  export type event_sponsorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type event_tagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type event_usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type eventsCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    streaming_url?: SortOrder
    venue_type?: SortOrder
    start_at?: SortOrder
    ends_at?: SortOrder
    canceled?: SortOrder
    capacity?: SortOrder
    invite_only?: SortOrder
    image_url?: SortOrder
    venue_id?: SortOrder
    chapter_id?: SortOrder
    calendar_event_id?: SortOrder
  }

  export type eventsAvgOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
    venue_id?: SortOrder
    chapter_id?: SortOrder
  }

  export type eventsMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    streaming_url?: SortOrder
    venue_type?: SortOrder
    start_at?: SortOrder
    ends_at?: SortOrder
    canceled?: SortOrder
    capacity?: SortOrder
    invite_only?: SortOrder
    image_url?: SortOrder
    venue_id?: SortOrder
    chapter_id?: SortOrder
    calendar_event_id?: SortOrder
  }

  export type eventsMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    streaming_url?: SortOrder
    venue_type?: SortOrder
    start_at?: SortOrder
    ends_at?: SortOrder
    canceled?: SortOrder
    capacity?: SortOrder
    invite_only?: SortOrder
    image_url?: SortOrder
    venue_id?: SortOrder
    chapter_id?: SortOrder
    calendar_event_id?: SortOrder
  }

  export type eventsSumOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
    venue_id?: SortOrder
    chapter_id?: SortOrder
  }

  export type Enumevents_venue_type_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: events_venue_type_enum | Enumevents_venue_type_enumFieldRefInput<$PrismaModel>
    in?: events_venue_type_enum[] | ListEnumevents_venue_type_enumFieldRefInput<$PrismaModel>
    notIn?: events_venue_type_enum[] | ListEnumevents_venue_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumevents_venue_type_enumWithAggregatesFilter<$PrismaModel> | events_venue_type_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumevents_venue_type_enumFilter<$PrismaModel>
    _max?: NestedEnumevents_venue_type_enumFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type Event_role_permissionsListRelationFilter = {
    every?: event_role_permissionsWhereInput
    some?: event_role_permissionsWhereInput
    none?: event_role_permissionsWhereInput
  }

  export type event_role_permissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type event_rolesCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type event_rolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type event_rolesMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type event_rolesMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type event_rolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Event_rolesRelationFilter = {
    is?: event_rolesWhereInput
    isNot?: event_rolesWhereInput
  }

  export type Event_permissionsRelationFilter = {
    is?: event_permissionsWhereInput
    isNot?: event_permissionsWhereInput
  }

  export type event_role_permissionsEvent_role_idEvent_permission_idCompoundUniqueInput = {
    event_role_id: number
    event_permission_id: number
  }

  export type event_role_permissionsCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    event_role_id?: SortOrder
    event_permission_id?: SortOrder
  }

  export type event_role_permissionsAvgOrderByAggregateInput = {
    event_role_id?: SortOrder
    event_permission_id?: SortOrder
  }

  export type event_role_permissionsMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    event_role_id?: SortOrder
    event_permission_id?: SortOrder
  }

  export type event_role_permissionsMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    event_role_id?: SortOrder
    event_permission_id?: SortOrder
  }

  export type event_role_permissionsSumOrderByAggregateInput = {
    event_role_id?: SortOrder
    event_permission_id?: SortOrder
  }

  export type event_permissionsCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type event_permissionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type event_permissionsMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type event_permissionsMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type event_permissionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AttendanceRelationFilter = {
    is?: attendanceWhereInput
    isNot?: attendanceWhereInput
  }

  export type Event_remindersNullableRelationFilter = {
    is?: event_remindersWhereInput | null
    isNot?: event_remindersWhereInput | null
  }

  export type event_usersUser_idEvent_idCompoundUniqueInput = {
    user_id: number
    event_id: number
  }

  export type event_usersCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    joined_date?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
    event_role_id?: SortOrder
    attendance_id?: SortOrder
    subscribed?: SortOrder
    title?: SortOrder
  }

  export type event_usersAvgOrderByAggregateInput = {
    user_id?: SortOrder
    event_id?: SortOrder
    event_role_id?: SortOrder
    attendance_id?: SortOrder
  }

  export type event_usersMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    joined_date?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
    event_role_id?: SortOrder
    attendance_id?: SortOrder
    subscribed?: SortOrder
  }

  export type event_usersMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    joined_date?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
    event_role_id?: SortOrder
    attendance_id?: SortOrder
    subscribed?: SortOrder
  }

  export type event_usersSumOrderByAggregateInput = {
    user_id?: SortOrder
    event_id?: SortOrder
    event_role_id?: SortOrder
    attendance_id?: SortOrder
  }

  export type Event_usersRelationFilter = {
    is?: event_usersWhereInput
    isNot?: event_usersWhereInput
  }

  export type event_remindersUser_idEvent_idCompoundUniqueInput = {
    user_id: number
    event_id: number
  }

  export type event_remindersCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
    remind_at?: SortOrder
    notifying?: SortOrder
  }

  export type event_remindersAvgOrderByAggregateInput = {
    user_id?: SortOrder
    event_id?: SortOrder
  }

  export type event_remindersMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
    remind_at?: SortOrder
    notifying?: SortOrder
  }

  export type event_remindersMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
    remind_at?: SortOrder
    notifying?: SortOrder
  }

  export type event_remindersSumOrderByAggregateInput = {
    user_id?: SortOrder
    event_id?: SortOrder
  }

  export type attendanceCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type attendanceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type attendanceMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type attendanceMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type attendanceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sponsorsCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    logo_path?: SortOrder
    type?: SortOrder
  }

  export type sponsorsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sponsorsMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    logo_path?: SortOrder
    type?: SortOrder
  }

  export type sponsorsMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    logo_path?: SortOrder
    type?: SortOrder
  }

  export type sponsorsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Venue_tagsListRelationFilter = {
    every?: venue_tagsWhereInput
    some?: venue_tagsWhereInput
    none?: venue_tagsWhereInput
  }

  export type venue_tagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tagsCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type tagsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tagsMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type tagsMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type tagsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type user_bansUser_idChapter_idCompoundUniqueInput = {
    user_id: number
    chapter_id: number
  }

  export type user_bansCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    chapter_id?: SortOrder
  }

  export type user_bansAvgOrderByAggregateInput = {
    user_id?: SortOrder
    chapter_id?: SortOrder
  }

  export type user_bansMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    chapter_id?: SortOrder
  }

  export type user_bansMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    chapter_id?: SortOrder
  }

  export type user_bansSumOrderByAggregateInput = {
    user_id?: SortOrder
    chapter_id?: SortOrder
  }

  export type Instance_role_permissionsListRelationFilter = {
    every?: instance_role_permissionsWhereInput
    some?: instance_role_permissionsWhereInput
    none?: instance_role_permissionsWhereInput
  }

  export type instance_role_permissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type instance_permissionsCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type instance_permissionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type instance_permissionsMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type instance_permissionsMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type instance_permissionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Instance_rolesRelationFilter = {
    is?: instance_rolesWhereInput
    isNot?: instance_rolesWhereInput
  }

  export type Instance_permissionsRelationFilter = {
    is?: instance_permissionsWhereInput
    isNot?: instance_permissionsWhereInput
  }

  export type instance_role_permissionsInstance_role_idInstance_permission_idCompoundUniqueInput = {
    instance_role_id: number
    instance_permission_id: number
  }

  export type instance_role_permissionsCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    instance_role_id?: SortOrder
    instance_permission_id?: SortOrder
  }

  export type instance_role_permissionsAvgOrderByAggregateInput = {
    instance_role_id?: SortOrder
    instance_permission_id?: SortOrder
  }

  export type instance_role_permissionsMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    instance_role_id?: SortOrder
    instance_permission_id?: SortOrder
  }

  export type instance_role_permissionsMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    instance_role_id?: SortOrder
    instance_permission_id?: SortOrder
  }

  export type instance_role_permissionsSumOrderByAggregateInput = {
    instance_role_id?: SortOrder
    instance_permission_id?: SortOrder
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type instance_rolesCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type instance_rolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type instance_rolesMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type instance_rolesMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
  }

  export type instance_rolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SessionsNullableRelationFilter = {
    is?: sessionsWhereInput | null
    isNot?: sessionsWhereInput | null
  }

  export type usersCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    image_url?: SortOrder
    email?: SortOrder
    auto_subscribe?: SortOrder
    instance_role_id?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
    instance_role_id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    image_url?: SortOrder
    email?: SortOrder
    auto_subscribe?: SortOrder
    instance_role_id?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    image_url?: SortOrder
    email?: SortOrder
    auto_subscribe?: SortOrder
    instance_role_id?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
    instance_role_id?: SortOrder
  }

  export type VenuesRelationFilter = {
    is?: venuesWhereInput
    isNot?: venuesWhereInput
  }

  export type venue_tagsVenue_idTag_idCompoundUniqueInput = {
    venue_id: number
    tag_id: number
  }

  export type venue_tagsCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    venue_id?: SortOrder
    tag_id?: SortOrder
  }

  export type venue_tagsAvgOrderByAggregateInput = {
    venue_id?: SortOrder
    tag_id?: SortOrder
  }

  export type venue_tagsMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    venue_id?: SortOrder
    tag_id?: SortOrder
  }

  export type venue_tagsMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    venue_id?: SortOrder
    tag_id?: SortOrder
  }

  export type venue_tagsSumOrderByAggregateInput = {
    venue_id?: SortOrder
    tag_id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type venuesCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    street_address?: SortOrder
    city?: SortOrder
    postal_code?: SortOrder
    region?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    chapter_id?: SortOrder
  }

  export type venuesAvgOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    chapter_id?: SortOrder
  }

  export type venuesMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    street_address?: SortOrder
    city?: SortOrder
    postal_code?: SortOrder
    region?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    chapter_id?: SortOrder
  }

  export type venuesMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    name?: SortOrder
    street_address?: SortOrder
    city?: SortOrder
    postal_code?: SortOrder
    region?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    chapter_id?: SortOrder
  }

  export type venuesSumOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    chapter_id?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type eventsCreateNestedManyWithoutChapterInput = {
    create?: XOR<eventsCreateWithoutChapterInput, eventsUncheckedCreateWithoutChapterInput> | eventsCreateWithoutChapterInput[] | eventsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: eventsCreateOrConnectWithoutChapterInput | eventsCreateOrConnectWithoutChapterInput[]
    createMany?: eventsCreateManyChapterInputEnvelope
    connect?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
  }

  export type user_bansCreateNestedManyWithoutChapterInput = {
    create?: XOR<user_bansCreateWithoutChapterInput, user_bansUncheckedCreateWithoutChapterInput> | user_bansCreateWithoutChapterInput[] | user_bansUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: user_bansCreateOrConnectWithoutChapterInput | user_bansCreateOrConnectWithoutChapterInput[]
    createMany?: user_bansCreateManyChapterInputEnvelope
    connect?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
  }

  export type chapter_usersCreateNestedManyWithoutChapterInput = {
    create?: XOR<chapter_usersCreateWithoutChapterInput, chapter_usersUncheckedCreateWithoutChapterInput> | chapter_usersCreateWithoutChapterInput[] | chapter_usersUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: chapter_usersCreateOrConnectWithoutChapterInput | chapter_usersCreateOrConnectWithoutChapterInput[]
    createMany?: chapter_usersCreateManyChapterInputEnvelope
    connect?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
  }

  export type chapter_tagsCreateNestedManyWithoutChapterInput = {
    create?: XOR<chapter_tagsCreateWithoutChapterInput, chapter_tagsUncheckedCreateWithoutChapterInput> | chapter_tagsCreateWithoutChapterInput[] | chapter_tagsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: chapter_tagsCreateOrConnectWithoutChapterInput | chapter_tagsCreateOrConnectWithoutChapterInput[]
    createMany?: chapter_tagsCreateManyChapterInputEnvelope
    connect?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
  }

  export type venuesCreateNestedManyWithoutChapterInput = {
    create?: XOR<venuesCreateWithoutChapterInput, venuesUncheckedCreateWithoutChapterInput> | venuesCreateWithoutChapterInput[] | venuesUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: venuesCreateOrConnectWithoutChapterInput | venuesCreateOrConnectWithoutChapterInput[]
    createMany?: venuesCreateManyChapterInputEnvelope
    connect?: venuesWhereUniqueInput | venuesWhereUniqueInput[]
  }

  export type eventsUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<eventsCreateWithoutChapterInput, eventsUncheckedCreateWithoutChapterInput> | eventsCreateWithoutChapterInput[] | eventsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: eventsCreateOrConnectWithoutChapterInput | eventsCreateOrConnectWithoutChapterInput[]
    createMany?: eventsCreateManyChapterInputEnvelope
    connect?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
  }

  export type user_bansUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<user_bansCreateWithoutChapterInput, user_bansUncheckedCreateWithoutChapterInput> | user_bansCreateWithoutChapterInput[] | user_bansUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: user_bansCreateOrConnectWithoutChapterInput | user_bansCreateOrConnectWithoutChapterInput[]
    createMany?: user_bansCreateManyChapterInputEnvelope
    connect?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
  }

  export type chapter_usersUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<chapter_usersCreateWithoutChapterInput, chapter_usersUncheckedCreateWithoutChapterInput> | chapter_usersCreateWithoutChapterInput[] | chapter_usersUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: chapter_usersCreateOrConnectWithoutChapterInput | chapter_usersCreateOrConnectWithoutChapterInput[]
    createMany?: chapter_usersCreateManyChapterInputEnvelope
    connect?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
  }

  export type chapter_tagsUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<chapter_tagsCreateWithoutChapterInput, chapter_tagsUncheckedCreateWithoutChapterInput> | chapter_tagsCreateWithoutChapterInput[] | chapter_tagsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: chapter_tagsCreateOrConnectWithoutChapterInput | chapter_tagsCreateOrConnectWithoutChapterInput[]
    createMany?: chapter_tagsCreateManyChapterInputEnvelope
    connect?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
  }

  export type venuesUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<venuesCreateWithoutChapterInput, venuesUncheckedCreateWithoutChapterInput> | venuesCreateWithoutChapterInput[] | venuesUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: venuesCreateOrConnectWithoutChapterInput | venuesCreateOrConnectWithoutChapterInput[]
    createMany?: venuesCreateManyChapterInputEnvelope
    connect?: venuesWhereUniqueInput | venuesWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type eventsUpdateManyWithoutChapterNestedInput = {
    create?: XOR<eventsCreateWithoutChapterInput, eventsUncheckedCreateWithoutChapterInput> | eventsCreateWithoutChapterInput[] | eventsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: eventsCreateOrConnectWithoutChapterInput | eventsCreateOrConnectWithoutChapterInput[]
    upsert?: eventsUpsertWithWhereUniqueWithoutChapterInput | eventsUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: eventsCreateManyChapterInputEnvelope
    set?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    disconnect?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    delete?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    connect?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    update?: eventsUpdateWithWhereUniqueWithoutChapterInput | eventsUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: eventsUpdateManyWithWhereWithoutChapterInput | eventsUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: eventsScalarWhereInput | eventsScalarWhereInput[]
  }

  export type user_bansUpdateManyWithoutChapterNestedInput = {
    create?: XOR<user_bansCreateWithoutChapterInput, user_bansUncheckedCreateWithoutChapterInput> | user_bansCreateWithoutChapterInput[] | user_bansUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: user_bansCreateOrConnectWithoutChapterInput | user_bansCreateOrConnectWithoutChapterInput[]
    upsert?: user_bansUpsertWithWhereUniqueWithoutChapterInput | user_bansUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: user_bansCreateManyChapterInputEnvelope
    set?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
    disconnect?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
    delete?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
    connect?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
    update?: user_bansUpdateWithWhereUniqueWithoutChapterInput | user_bansUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: user_bansUpdateManyWithWhereWithoutChapterInput | user_bansUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: user_bansScalarWhereInput | user_bansScalarWhereInput[]
  }

  export type chapter_usersUpdateManyWithoutChapterNestedInput = {
    create?: XOR<chapter_usersCreateWithoutChapterInput, chapter_usersUncheckedCreateWithoutChapterInput> | chapter_usersCreateWithoutChapterInput[] | chapter_usersUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: chapter_usersCreateOrConnectWithoutChapterInput | chapter_usersCreateOrConnectWithoutChapterInput[]
    upsert?: chapter_usersUpsertWithWhereUniqueWithoutChapterInput | chapter_usersUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: chapter_usersCreateManyChapterInputEnvelope
    set?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    disconnect?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    delete?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    connect?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    update?: chapter_usersUpdateWithWhereUniqueWithoutChapterInput | chapter_usersUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: chapter_usersUpdateManyWithWhereWithoutChapterInput | chapter_usersUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: chapter_usersScalarWhereInput | chapter_usersScalarWhereInput[]
  }

  export type chapter_tagsUpdateManyWithoutChapterNestedInput = {
    create?: XOR<chapter_tagsCreateWithoutChapterInput, chapter_tagsUncheckedCreateWithoutChapterInput> | chapter_tagsCreateWithoutChapterInput[] | chapter_tagsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: chapter_tagsCreateOrConnectWithoutChapterInput | chapter_tagsCreateOrConnectWithoutChapterInput[]
    upsert?: chapter_tagsUpsertWithWhereUniqueWithoutChapterInput | chapter_tagsUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: chapter_tagsCreateManyChapterInputEnvelope
    set?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
    disconnect?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
    delete?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
    connect?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
    update?: chapter_tagsUpdateWithWhereUniqueWithoutChapterInput | chapter_tagsUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: chapter_tagsUpdateManyWithWhereWithoutChapterInput | chapter_tagsUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: chapter_tagsScalarWhereInput | chapter_tagsScalarWhereInput[]
  }

  export type venuesUpdateManyWithoutChapterNestedInput = {
    create?: XOR<venuesCreateWithoutChapterInput, venuesUncheckedCreateWithoutChapterInput> | venuesCreateWithoutChapterInput[] | venuesUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: venuesCreateOrConnectWithoutChapterInput | venuesCreateOrConnectWithoutChapterInput[]
    upsert?: venuesUpsertWithWhereUniqueWithoutChapterInput | venuesUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: venuesCreateManyChapterInputEnvelope
    set?: venuesWhereUniqueInput | venuesWhereUniqueInput[]
    disconnect?: venuesWhereUniqueInput | venuesWhereUniqueInput[]
    delete?: venuesWhereUniqueInput | venuesWhereUniqueInput[]
    connect?: venuesWhereUniqueInput | venuesWhereUniqueInput[]
    update?: venuesUpdateWithWhereUniqueWithoutChapterInput | venuesUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: venuesUpdateManyWithWhereWithoutChapterInput | venuesUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: venuesScalarWhereInput | venuesScalarWhereInput[]
  }

  export type eventsUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<eventsCreateWithoutChapterInput, eventsUncheckedCreateWithoutChapterInput> | eventsCreateWithoutChapterInput[] | eventsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: eventsCreateOrConnectWithoutChapterInput | eventsCreateOrConnectWithoutChapterInput[]
    upsert?: eventsUpsertWithWhereUniqueWithoutChapterInput | eventsUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: eventsCreateManyChapterInputEnvelope
    set?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    disconnect?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    delete?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    connect?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    update?: eventsUpdateWithWhereUniqueWithoutChapterInput | eventsUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: eventsUpdateManyWithWhereWithoutChapterInput | eventsUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: eventsScalarWhereInput | eventsScalarWhereInput[]
  }

  export type user_bansUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<user_bansCreateWithoutChapterInput, user_bansUncheckedCreateWithoutChapterInput> | user_bansCreateWithoutChapterInput[] | user_bansUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: user_bansCreateOrConnectWithoutChapterInput | user_bansCreateOrConnectWithoutChapterInput[]
    upsert?: user_bansUpsertWithWhereUniqueWithoutChapterInput | user_bansUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: user_bansCreateManyChapterInputEnvelope
    set?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
    disconnect?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
    delete?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
    connect?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
    update?: user_bansUpdateWithWhereUniqueWithoutChapterInput | user_bansUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: user_bansUpdateManyWithWhereWithoutChapterInput | user_bansUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: user_bansScalarWhereInput | user_bansScalarWhereInput[]
  }

  export type chapter_usersUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<chapter_usersCreateWithoutChapterInput, chapter_usersUncheckedCreateWithoutChapterInput> | chapter_usersCreateWithoutChapterInput[] | chapter_usersUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: chapter_usersCreateOrConnectWithoutChapterInput | chapter_usersCreateOrConnectWithoutChapterInput[]
    upsert?: chapter_usersUpsertWithWhereUniqueWithoutChapterInput | chapter_usersUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: chapter_usersCreateManyChapterInputEnvelope
    set?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    disconnect?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    delete?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    connect?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    update?: chapter_usersUpdateWithWhereUniqueWithoutChapterInput | chapter_usersUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: chapter_usersUpdateManyWithWhereWithoutChapterInput | chapter_usersUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: chapter_usersScalarWhereInput | chapter_usersScalarWhereInput[]
  }

  export type chapter_tagsUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<chapter_tagsCreateWithoutChapterInput, chapter_tagsUncheckedCreateWithoutChapterInput> | chapter_tagsCreateWithoutChapterInput[] | chapter_tagsUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: chapter_tagsCreateOrConnectWithoutChapterInput | chapter_tagsCreateOrConnectWithoutChapterInput[]
    upsert?: chapter_tagsUpsertWithWhereUniqueWithoutChapterInput | chapter_tagsUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: chapter_tagsCreateManyChapterInputEnvelope
    set?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
    disconnect?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
    delete?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
    connect?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
    update?: chapter_tagsUpdateWithWhereUniqueWithoutChapterInput | chapter_tagsUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: chapter_tagsUpdateManyWithWhereWithoutChapterInput | chapter_tagsUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: chapter_tagsScalarWhereInput | chapter_tagsScalarWhereInput[]
  }

  export type venuesUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<venuesCreateWithoutChapterInput, venuesUncheckedCreateWithoutChapterInput> | venuesCreateWithoutChapterInput[] | venuesUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: venuesCreateOrConnectWithoutChapterInput | venuesCreateOrConnectWithoutChapterInput[]
    upsert?: venuesUpsertWithWhereUniqueWithoutChapterInput | venuesUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: venuesCreateManyChapterInputEnvelope
    set?: venuesWhereUniqueInput | venuesWhereUniqueInput[]
    disconnect?: venuesWhereUniqueInput | venuesWhereUniqueInput[]
    delete?: venuesWhereUniqueInput | venuesWhereUniqueInput[]
    connect?: venuesWhereUniqueInput | venuesWhereUniqueInput[]
    update?: venuesUpdateWithWhereUniqueWithoutChapterInput | venuesUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: venuesUpdateManyWithWhereWithoutChapterInput | venuesUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: venuesScalarWhereInput | venuesScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutSessionInput = {
    create?: XOR<usersCreateWithoutSessionInput, usersUncheckedCreateWithoutSessionInput>
    connectOrCreate?: usersCreateOrConnectWithoutSessionInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutSessionNestedInput = {
    create?: XOR<usersCreateWithoutSessionInput, usersUncheckedCreateWithoutSessionInput>
    connectOrCreate?: usersCreateOrConnectWithoutSessionInput
    upsert?: usersUpsertWithoutSessionInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSessionInput, usersUpdateWithoutSessionInput>, usersUncheckedUpdateWithoutSessionInput>
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type usersCreateNestedOneWithoutUser_chaptersInput = {
    create?: XOR<usersCreateWithoutUser_chaptersInput, usersUncheckedCreateWithoutUser_chaptersInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_chaptersInput
    connect?: usersWhereUniqueInput
  }

  export type chaptersCreateNestedOneWithoutChapter_usersInput = {
    create?: XOR<chaptersCreateWithoutChapter_usersInput, chaptersUncheckedCreateWithoutChapter_usersInput>
    connectOrCreate?: chaptersCreateOrConnectWithoutChapter_usersInput
    connect?: chaptersWhereUniqueInput
  }

  export type chapter_rolesCreateNestedOneWithoutChapter_usersInput = {
    create?: XOR<chapter_rolesCreateWithoutChapter_usersInput, chapter_rolesUncheckedCreateWithoutChapter_usersInput>
    connectOrCreate?: chapter_rolesCreateOrConnectWithoutChapter_usersInput
    connect?: chapter_rolesWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUser_chaptersNestedInput = {
    create?: XOR<usersCreateWithoutUser_chaptersInput, usersUncheckedCreateWithoutUser_chaptersInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_chaptersInput
    upsert?: usersUpsertWithoutUser_chaptersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_chaptersInput, usersUpdateWithoutUser_chaptersInput>, usersUncheckedUpdateWithoutUser_chaptersInput>
  }

  export type chaptersUpdateOneRequiredWithoutChapter_usersNestedInput = {
    create?: XOR<chaptersCreateWithoutChapter_usersInput, chaptersUncheckedCreateWithoutChapter_usersInput>
    connectOrCreate?: chaptersCreateOrConnectWithoutChapter_usersInput
    upsert?: chaptersUpsertWithoutChapter_usersInput
    connect?: chaptersWhereUniqueInput
    update?: XOR<XOR<chaptersUpdateToOneWithWhereWithoutChapter_usersInput, chaptersUpdateWithoutChapter_usersInput>, chaptersUncheckedUpdateWithoutChapter_usersInput>
  }

  export type chapter_rolesUpdateOneRequiredWithoutChapter_usersNestedInput = {
    create?: XOR<chapter_rolesCreateWithoutChapter_usersInput, chapter_rolesUncheckedCreateWithoutChapter_usersInput>
    connectOrCreate?: chapter_rolesCreateOrConnectWithoutChapter_usersInput
    upsert?: chapter_rolesUpsertWithoutChapter_usersInput
    connect?: chapter_rolesWhereUniqueInput
    update?: XOR<XOR<chapter_rolesUpdateToOneWithWhereWithoutChapter_usersInput, chapter_rolesUpdateWithoutChapter_usersInput>, chapter_rolesUncheckedUpdateWithoutChapter_usersInput>
  }

  export type chapter_usersCreateNestedManyWithoutChapter_roleInput = {
    create?: XOR<chapter_usersCreateWithoutChapter_roleInput, chapter_usersUncheckedCreateWithoutChapter_roleInput> | chapter_usersCreateWithoutChapter_roleInput[] | chapter_usersUncheckedCreateWithoutChapter_roleInput[]
    connectOrCreate?: chapter_usersCreateOrConnectWithoutChapter_roleInput | chapter_usersCreateOrConnectWithoutChapter_roleInput[]
    createMany?: chapter_usersCreateManyChapter_roleInputEnvelope
    connect?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
  }

  export type chapter_role_permissionsCreateNestedManyWithoutChapter_roleInput = {
    create?: XOR<chapter_role_permissionsCreateWithoutChapter_roleInput, chapter_role_permissionsUncheckedCreateWithoutChapter_roleInput> | chapter_role_permissionsCreateWithoutChapter_roleInput[] | chapter_role_permissionsUncheckedCreateWithoutChapter_roleInput[]
    connectOrCreate?: chapter_role_permissionsCreateOrConnectWithoutChapter_roleInput | chapter_role_permissionsCreateOrConnectWithoutChapter_roleInput[]
    createMany?: chapter_role_permissionsCreateManyChapter_roleInputEnvelope
    connect?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
  }

  export type chapter_usersUncheckedCreateNestedManyWithoutChapter_roleInput = {
    create?: XOR<chapter_usersCreateWithoutChapter_roleInput, chapter_usersUncheckedCreateWithoutChapter_roleInput> | chapter_usersCreateWithoutChapter_roleInput[] | chapter_usersUncheckedCreateWithoutChapter_roleInput[]
    connectOrCreate?: chapter_usersCreateOrConnectWithoutChapter_roleInput | chapter_usersCreateOrConnectWithoutChapter_roleInput[]
    createMany?: chapter_usersCreateManyChapter_roleInputEnvelope
    connect?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
  }

  export type chapter_role_permissionsUncheckedCreateNestedManyWithoutChapter_roleInput = {
    create?: XOR<chapter_role_permissionsCreateWithoutChapter_roleInput, chapter_role_permissionsUncheckedCreateWithoutChapter_roleInput> | chapter_role_permissionsCreateWithoutChapter_roleInput[] | chapter_role_permissionsUncheckedCreateWithoutChapter_roleInput[]
    connectOrCreate?: chapter_role_permissionsCreateOrConnectWithoutChapter_roleInput | chapter_role_permissionsCreateOrConnectWithoutChapter_roleInput[]
    createMany?: chapter_role_permissionsCreateManyChapter_roleInputEnvelope
    connect?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
  }

  export type chapter_usersUpdateManyWithoutChapter_roleNestedInput = {
    create?: XOR<chapter_usersCreateWithoutChapter_roleInput, chapter_usersUncheckedCreateWithoutChapter_roleInput> | chapter_usersCreateWithoutChapter_roleInput[] | chapter_usersUncheckedCreateWithoutChapter_roleInput[]
    connectOrCreate?: chapter_usersCreateOrConnectWithoutChapter_roleInput | chapter_usersCreateOrConnectWithoutChapter_roleInput[]
    upsert?: chapter_usersUpsertWithWhereUniqueWithoutChapter_roleInput | chapter_usersUpsertWithWhereUniqueWithoutChapter_roleInput[]
    createMany?: chapter_usersCreateManyChapter_roleInputEnvelope
    set?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    disconnect?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    delete?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    connect?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    update?: chapter_usersUpdateWithWhereUniqueWithoutChapter_roleInput | chapter_usersUpdateWithWhereUniqueWithoutChapter_roleInput[]
    updateMany?: chapter_usersUpdateManyWithWhereWithoutChapter_roleInput | chapter_usersUpdateManyWithWhereWithoutChapter_roleInput[]
    deleteMany?: chapter_usersScalarWhereInput | chapter_usersScalarWhereInput[]
  }

  export type chapter_role_permissionsUpdateManyWithoutChapter_roleNestedInput = {
    create?: XOR<chapter_role_permissionsCreateWithoutChapter_roleInput, chapter_role_permissionsUncheckedCreateWithoutChapter_roleInput> | chapter_role_permissionsCreateWithoutChapter_roleInput[] | chapter_role_permissionsUncheckedCreateWithoutChapter_roleInput[]
    connectOrCreate?: chapter_role_permissionsCreateOrConnectWithoutChapter_roleInput | chapter_role_permissionsCreateOrConnectWithoutChapter_roleInput[]
    upsert?: chapter_role_permissionsUpsertWithWhereUniqueWithoutChapter_roleInput | chapter_role_permissionsUpsertWithWhereUniqueWithoutChapter_roleInput[]
    createMany?: chapter_role_permissionsCreateManyChapter_roleInputEnvelope
    set?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
    disconnect?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
    delete?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
    connect?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
    update?: chapter_role_permissionsUpdateWithWhereUniqueWithoutChapter_roleInput | chapter_role_permissionsUpdateWithWhereUniqueWithoutChapter_roleInput[]
    updateMany?: chapter_role_permissionsUpdateManyWithWhereWithoutChapter_roleInput | chapter_role_permissionsUpdateManyWithWhereWithoutChapter_roleInput[]
    deleteMany?: chapter_role_permissionsScalarWhereInput | chapter_role_permissionsScalarWhereInput[]
  }

  export type chapter_usersUncheckedUpdateManyWithoutChapter_roleNestedInput = {
    create?: XOR<chapter_usersCreateWithoutChapter_roleInput, chapter_usersUncheckedCreateWithoutChapter_roleInput> | chapter_usersCreateWithoutChapter_roleInput[] | chapter_usersUncheckedCreateWithoutChapter_roleInput[]
    connectOrCreate?: chapter_usersCreateOrConnectWithoutChapter_roleInput | chapter_usersCreateOrConnectWithoutChapter_roleInput[]
    upsert?: chapter_usersUpsertWithWhereUniqueWithoutChapter_roleInput | chapter_usersUpsertWithWhereUniqueWithoutChapter_roleInput[]
    createMany?: chapter_usersCreateManyChapter_roleInputEnvelope
    set?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    disconnect?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    delete?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    connect?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    update?: chapter_usersUpdateWithWhereUniqueWithoutChapter_roleInput | chapter_usersUpdateWithWhereUniqueWithoutChapter_roleInput[]
    updateMany?: chapter_usersUpdateManyWithWhereWithoutChapter_roleInput | chapter_usersUpdateManyWithWhereWithoutChapter_roleInput[]
    deleteMany?: chapter_usersScalarWhereInput | chapter_usersScalarWhereInput[]
  }

  export type chapter_role_permissionsUncheckedUpdateManyWithoutChapter_roleNestedInput = {
    create?: XOR<chapter_role_permissionsCreateWithoutChapter_roleInput, chapter_role_permissionsUncheckedCreateWithoutChapter_roleInput> | chapter_role_permissionsCreateWithoutChapter_roleInput[] | chapter_role_permissionsUncheckedCreateWithoutChapter_roleInput[]
    connectOrCreate?: chapter_role_permissionsCreateOrConnectWithoutChapter_roleInput | chapter_role_permissionsCreateOrConnectWithoutChapter_roleInput[]
    upsert?: chapter_role_permissionsUpsertWithWhereUniqueWithoutChapter_roleInput | chapter_role_permissionsUpsertWithWhereUniqueWithoutChapter_roleInput[]
    createMany?: chapter_role_permissionsCreateManyChapter_roleInputEnvelope
    set?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
    disconnect?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
    delete?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
    connect?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
    update?: chapter_role_permissionsUpdateWithWhereUniqueWithoutChapter_roleInput | chapter_role_permissionsUpdateWithWhereUniqueWithoutChapter_roleInput[]
    updateMany?: chapter_role_permissionsUpdateManyWithWhereWithoutChapter_roleInput | chapter_role_permissionsUpdateManyWithWhereWithoutChapter_roleInput[]
    deleteMany?: chapter_role_permissionsScalarWhereInput | chapter_role_permissionsScalarWhereInput[]
  }

  export type chapter_rolesCreateNestedOneWithoutChapter_role_permissionsInput = {
    create?: XOR<chapter_rolesCreateWithoutChapter_role_permissionsInput, chapter_rolesUncheckedCreateWithoutChapter_role_permissionsInput>
    connectOrCreate?: chapter_rolesCreateOrConnectWithoutChapter_role_permissionsInput
    connect?: chapter_rolesWhereUniqueInput
  }

  export type chapter_permissionsCreateNestedOneWithoutChapter_role_permissionsInput = {
    create?: XOR<chapter_permissionsCreateWithoutChapter_role_permissionsInput, chapter_permissionsUncheckedCreateWithoutChapter_role_permissionsInput>
    connectOrCreate?: chapter_permissionsCreateOrConnectWithoutChapter_role_permissionsInput
    connect?: chapter_permissionsWhereUniqueInput
  }

  export type chapter_rolesUpdateOneRequiredWithoutChapter_role_permissionsNestedInput = {
    create?: XOR<chapter_rolesCreateWithoutChapter_role_permissionsInput, chapter_rolesUncheckedCreateWithoutChapter_role_permissionsInput>
    connectOrCreate?: chapter_rolesCreateOrConnectWithoutChapter_role_permissionsInput
    upsert?: chapter_rolesUpsertWithoutChapter_role_permissionsInput
    connect?: chapter_rolesWhereUniqueInput
    update?: XOR<XOR<chapter_rolesUpdateToOneWithWhereWithoutChapter_role_permissionsInput, chapter_rolesUpdateWithoutChapter_role_permissionsInput>, chapter_rolesUncheckedUpdateWithoutChapter_role_permissionsInput>
  }

  export type chapter_permissionsUpdateOneRequiredWithoutChapter_role_permissionsNestedInput = {
    create?: XOR<chapter_permissionsCreateWithoutChapter_role_permissionsInput, chapter_permissionsUncheckedCreateWithoutChapter_role_permissionsInput>
    connectOrCreate?: chapter_permissionsCreateOrConnectWithoutChapter_role_permissionsInput
    upsert?: chapter_permissionsUpsertWithoutChapter_role_permissionsInput
    connect?: chapter_permissionsWhereUniqueInput
    update?: XOR<XOR<chapter_permissionsUpdateToOneWithWhereWithoutChapter_role_permissionsInput, chapter_permissionsUpdateWithoutChapter_role_permissionsInput>, chapter_permissionsUncheckedUpdateWithoutChapter_role_permissionsInput>
  }

  export type chapter_role_permissionsCreateNestedManyWithoutChapter_permissionInput = {
    create?: XOR<chapter_role_permissionsCreateWithoutChapter_permissionInput, chapter_role_permissionsUncheckedCreateWithoutChapter_permissionInput> | chapter_role_permissionsCreateWithoutChapter_permissionInput[] | chapter_role_permissionsUncheckedCreateWithoutChapter_permissionInput[]
    connectOrCreate?: chapter_role_permissionsCreateOrConnectWithoutChapter_permissionInput | chapter_role_permissionsCreateOrConnectWithoutChapter_permissionInput[]
    createMany?: chapter_role_permissionsCreateManyChapter_permissionInputEnvelope
    connect?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
  }

  export type chapter_role_permissionsUncheckedCreateNestedManyWithoutChapter_permissionInput = {
    create?: XOR<chapter_role_permissionsCreateWithoutChapter_permissionInput, chapter_role_permissionsUncheckedCreateWithoutChapter_permissionInput> | chapter_role_permissionsCreateWithoutChapter_permissionInput[] | chapter_role_permissionsUncheckedCreateWithoutChapter_permissionInput[]
    connectOrCreate?: chapter_role_permissionsCreateOrConnectWithoutChapter_permissionInput | chapter_role_permissionsCreateOrConnectWithoutChapter_permissionInput[]
    createMany?: chapter_role_permissionsCreateManyChapter_permissionInputEnvelope
    connect?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
  }

  export type chapter_role_permissionsUpdateManyWithoutChapter_permissionNestedInput = {
    create?: XOR<chapter_role_permissionsCreateWithoutChapter_permissionInput, chapter_role_permissionsUncheckedCreateWithoutChapter_permissionInput> | chapter_role_permissionsCreateWithoutChapter_permissionInput[] | chapter_role_permissionsUncheckedCreateWithoutChapter_permissionInput[]
    connectOrCreate?: chapter_role_permissionsCreateOrConnectWithoutChapter_permissionInput | chapter_role_permissionsCreateOrConnectWithoutChapter_permissionInput[]
    upsert?: chapter_role_permissionsUpsertWithWhereUniqueWithoutChapter_permissionInput | chapter_role_permissionsUpsertWithWhereUniqueWithoutChapter_permissionInput[]
    createMany?: chapter_role_permissionsCreateManyChapter_permissionInputEnvelope
    set?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
    disconnect?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
    delete?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
    connect?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
    update?: chapter_role_permissionsUpdateWithWhereUniqueWithoutChapter_permissionInput | chapter_role_permissionsUpdateWithWhereUniqueWithoutChapter_permissionInput[]
    updateMany?: chapter_role_permissionsUpdateManyWithWhereWithoutChapter_permissionInput | chapter_role_permissionsUpdateManyWithWhereWithoutChapter_permissionInput[]
    deleteMany?: chapter_role_permissionsScalarWhereInput | chapter_role_permissionsScalarWhereInput[]
  }

  export type chapter_role_permissionsUncheckedUpdateManyWithoutChapter_permissionNestedInput = {
    create?: XOR<chapter_role_permissionsCreateWithoutChapter_permissionInput, chapter_role_permissionsUncheckedCreateWithoutChapter_permissionInput> | chapter_role_permissionsCreateWithoutChapter_permissionInput[] | chapter_role_permissionsUncheckedCreateWithoutChapter_permissionInput[]
    connectOrCreate?: chapter_role_permissionsCreateOrConnectWithoutChapter_permissionInput | chapter_role_permissionsCreateOrConnectWithoutChapter_permissionInput[]
    upsert?: chapter_role_permissionsUpsertWithWhereUniqueWithoutChapter_permissionInput | chapter_role_permissionsUpsertWithWhereUniqueWithoutChapter_permissionInput[]
    createMany?: chapter_role_permissionsCreateManyChapter_permissionInputEnvelope
    set?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
    disconnect?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
    delete?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
    connect?: chapter_role_permissionsWhereUniqueInput | chapter_role_permissionsWhereUniqueInput[]
    update?: chapter_role_permissionsUpdateWithWhereUniqueWithoutChapter_permissionInput | chapter_role_permissionsUpdateWithWhereUniqueWithoutChapter_permissionInput[]
    updateMany?: chapter_role_permissionsUpdateManyWithWhereWithoutChapter_permissionInput | chapter_role_permissionsUpdateManyWithWhereWithoutChapter_permissionInput[]
    deleteMany?: chapter_role_permissionsScalarWhereInput | chapter_role_permissionsScalarWhereInput[]
  }

  export type chaptersCreateNestedOneWithoutChapter_tagsInput = {
    create?: XOR<chaptersCreateWithoutChapter_tagsInput, chaptersUncheckedCreateWithoutChapter_tagsInput>
    connectOrCreate?: chaptersCreateOrConnectWithoutChapter_tagsInput
    connect?: chaptersWhereUniqueInput
  }

  export type tagsCreateNestedOneWithoutChapter_tagsInput = {
    create?: XOR<tagsCreateWithoutChapter_tagsInput, tagsUncheckedCreateWithoutChapter_tagsInput>
    connectOrCreate?: tagsCreateOrConnectWithoutChapter_tagsInput
    connect?: tagsWhereUniqueInput
  }

  export type chaptersUpdateOneRequiredWithoutChapter_tagsNestedInput = {
    create?: XOR<chaptersCreateWithoutChapter_tagsInput, chaptersUncheckedCreateWithoutChapter_tagsInput>
    connectOrCreate?: chaptersCreateOrConnectWithoutChapter_tagsInput
    upsert?: chaptersUpsertWithoutChapter_tagsInput
    connect?: chaptersWhereUniqueInput
    update?: XOR<XOR<chaptersUpdateToOneWithWhereWithoutChapter_tagsInput, chaptersUpdateWithoutChapter_tagsInput>, chaptersUncheckedUpdateWithoutChapter_tagsInput>
  }

  export type tagsUpdateOneRequiredWithoutChapter_tagsNestedInput = {
    create?: XOR<tagsCreateWithoutChapter_tagsInput, tagsUncheckedCreateWithoutChapter_tagsInput>
    connectOrCreate?: tagsCreateOrConnectWithoutChapter_tagsInput
    upsert?: tagsUpsertWithoutChapter_tagsInput
    connect?: tagsWhereUniqueInput
    update?: XOR<XOR<tagsUpdateToOneWithWhereWithoutChapter_tagsInput, tagsUpdateWithoutChapter_tagsInput>, tagsUncheckedUpdateWithoutChapter_tagsInput>
  }

  export type eventsCreateNestedOneWithoutSponsorsInput = {
    create?: XOR<eventsCreateWithoutSponsorsInput, eventsUncheckedCreateWithoutSponsorsInput>
    connectOrCreate?: eventsCreateOrConnectWithoutSponsorsInput
    connect?: eventsWhereUniqueInput
  }

  export type sponsorsCreateNestedOneWithoutEvent_sponsorsInput = {
    create?: XOR<sponsorsCreateWithoutEvent_sponsorsInput, sponsorsUncheckedCreateWithoutEvent_sponsorsInput>
    connectOrCreate?: sponsorsCreateOrConnectWithoutEvent_sponsorsInput
    connect?: sponsorsWhereUniqueInput
  }

  export type eventsUpdateOneRequiredWithoutSponsorsNestedInput = {
    create?: XOR<eventsCreateWithoutSponsorsInput, eventsUncheckedCreateWithoutSponsorsInput>
    connectOrCreate?: eventsCreateOrConnectWithoutSponsorsInput
    upsert?: eventsUpsertWithoutSponsorsInput
    connect?: eventsWhereUniqueInput
    update?: XOR<XOR<eventsUpdateToOneWithWhereWithoutSponsorsInput, eventsUpdateWithoutSponsorsInput>, eventsUncheckedUpdateWithoutSponsorsInput>
  }

  export type sponsorsUpdateOneRequiredWithoutEvent_sponsorsNestedInput = {
    create?: XOR<sponsorsCreateWithoutEvent_sponsorsInput, sponsorsUncheckedCreateWithoutEvent_sponsorsInput>
    connectOrCreate?: sponsorsCreateOrConnectWithoutEvent_sponsorsInput
    upsert?: sponsorsUpsertWithoutEvent_sponsorsInput
    connect?: sponsorsWhereUniqueInput
    update?: XOR<XOR<sponsorsUpdateToOneWithWhereWithoutEvent_sponsorsInput, sponsorsUpdateWithoutEvent_sponsorsInput>, sponsorsUncheckedUpdateWithoutEvent_sponsorsInput>
  }

  export type eventsCreateNestedOneWithoutEvent_tagsInput = {
    create?: XOR<eventsCreateWithoutEvent_tagsInput, eventsUncheckedCreateWithoutEvent_tagsInput>
    connectOrCreate?: eventsCreateOrConnectWithoutEvent_tagsInput
    connect?: eventsWhereUniqueInput
  }

  export type tagsCreateNestedOneWithoutEvent_tagsInput = {
    create?: XOR<tagsCreateWithoutEvent_tagsInput, tagsUncheckedCreateWithoutEvent_tagsInput>
    connectOrCreate?: tagsCreateOrConnectWithoutEvent_tagsInput
    connect?: tagsWhereUniqueInput
  }

  export type eventsUpdateOneRequiredWithoutEvent_tagsNestedInput = {
    create?: XOR<eventsCreateWithoutEvent_tagsInput, eventsUncheckedCreateWithoutEvent_tagsInput>
    connectOrCreate?: eventsCreateOrConnectWithoutEvent_tagsInput
    upsert?: eventsUpsertWithoutEvent_tagsInput
    connect?: eventsWhereUniqueInput
    update?: XOR<XOR<eventsUpdateToOneWithWhereWithoutEvent_tagsInput, eventsUpdateWithoutEvent_tagsInput>, eventsUncheckedUpdateWithoutEvent_tagsInput>
  }

  export type tagsUpdateOneRequiredWithoutEvent_tagsNestedInput = {
    create?: XOR<tagsCreateWithoutEvent_tagsInput, tagsUncheckedCreateWithoutEvent_tagsInput>
    connectOrCreate?: tagsCreateOrConnectWithoutEvent_tagsInput
    upsert?: tagsUpsertWithoutEvent_tagsInput
    connect?: tagsWhereUniqueInput
    update?: XOR<XOR<tagsUpdateToOneWithWhereWithoutEvent_tagsInput, tagsUpdateWithoutEvent_tagsInput>, tagsUncheckedUpdateWithoutEvent_tagsInput>
  }

  export type chaptersCreateNestedOneWithoutEventsInput = {
    create?: XOR<chaptersCreateWithoutEventsInput, chaptersUncheckedCreateWithoutEventsInput>
    connectOrCreate?: chaptersCreateOrConnectWithoutEventsInput
    connect?: chaptersWhereUniqueInput
  }

  export type venuesCreateNestedOneWithoutEventsInput = {
    create?: XOR<venuesCreateWithoutEventsInput, venuesUncheckedCreateWithoutEventsInput>
    connectOrCreate?: venuesCreateOrConnectWithoutEventsInput
    connect?: venuesWhereUniqueInput
  }

  export type event_sponsorsCreateNestedManyWithoutEventInput = {
    create?: XOR<event_sponsorsCreateWithoutEventInput, event_sponsorsUncheckedCreateWithoutEventInput> | event_sponsorsCreateWithoutEventInput[] | event_sponsorsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: event_sponsorsCreateOrConnectWithoutEventInput | event_sponsorsCreateOrConnectWithoutEventInput[]
    createMany?: event_sponsorsCreateManyEventInputEnvelope
    connect?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
  }

  export type event_tagsCreateNestedManyWithoutEventInput = {
    create?: XOR<event_tagsCreateWithoutEventInput, event_tagsUncheckedCreateWithoutEventInput> | event_tagsCreateWithoutEventInput[] | event_tagsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: event_tagsCreateOrConnectWithoutEventInput | event_tagsCreateOrConnectWithoutEventInput[]
    createMany?: event_tagsCreateManyEventInputEnvelope
    connect?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
  }

  export type event_usersCreateNestedManyWithoutEventInput = {
    create?: XOR<event_usersCreateWithoutEventInput, event_usersUncheckedCreateWithoutEventInput> | event_usersCreateWithoutEventInput[] | event_usersUncheckedCreateWithoutEventInput[]
    connectOrCreate?: event_usersCreateOrConnectWithoutEventInput | event_usersCreateOrConnectWithoutEventInput[]
    createMany?: event_usersCreateManyEventInputEnvelope
    connect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
  }

  export type event_sponsorsUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<event_sponsorsCreateWithoutEventInput, event_sponsorsUncheckedCreateWithoutEventInput> | event_sponsorsCreateWithoutEventInput[] | event_sponsorsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: event_sponsorsCreateOrConnectWithoutEventInput | event_sponsorsCreateOrConnectWithoutEventInput[]
    createMany?: event_sponsorsCreateManyEventInputEnvelope
    connect?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
  }

  export type event_tagsUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<event_tagsCreateWithoutEventInput, event_tagsUncheckedCreateWithoutEventInput> | event_tagsCreateWithoutEventInput[] | event_tagsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: event_tagsCreateOrConnectWithoutEventInput | event_tagsCreateOrConnectWithoutEventInput[]
    createMany?: event_tagsCreateManyEventInputEnvelope
    connect?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
  }

  export type event_usersUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<event_usersCreateWithoutEventInput, event_usersUncheckedCreateWithoutEventInput> | event_usersCreateWithoutEventInput[] | event_usersUncheckedCreateWithoutEventInput[]
    connectOrCreate?: event_usersCreateOrConnectWithoutEventInput | event_usersCreateOrConnectWithoutEventInput[]
    createMany?: event_usersCreateManyEventInputEnvelope
    connect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
  }

  export type Enumevents_venue_type_enumFieldUpdateOperationsInput = {
    set?: events_venue_type_enum
  }

  export type chaptersUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<chaptersCreateWithoutEventsInput, chaptersUncheckedCreateWithoutEventsInput>
    connectOrCreate?: chaptersCreateOrConnectWithoutEventsInput
    upsert?: chaptersUpsertWithoutEventsInput
    connect?: chaptersWhereUniqueInput
    update?: XOR<XOR<chaptersUpdateToOneWithWhereWithoutEventsInput, chaptersUpdateWithoutEventsInput>, chaptersUncheckedUpdateWithoutEventsInput>
  }

  export type venuesUpdateOneWithoutEventsNestedInput = {
    create?: XOR<venuesCreateWithoutEventsInput, venuesUncheckedCreateWithoutEventsInput>
    connectOrCreate?: venuesCreateOrConnectWithoutEventsInput
    upsert?: venuesUpsertWithoutEventsInput
    disconnect?: venuesWhereInput | boolean
    delete?: venuesWhereInput | boolean
    connect?: venuesWhereUniqueInput
    update?: XOR<XOR<venuesUpdateToOneWithWhereWithoutEventsInput, venuesUpdateWithoutEventsInput>, venuesUncheckedUpdateWithoutEventsInput>
  }

  export type event_sponsorsUpdateManyWithoutEventNestedInput = {
    create?: XOR<event_sponsorsCreateWithoutEventInput, event_sponsorsUncheckedCreateWithoutEventInput> | event_sponsorsCreateWithoutEventInput[] | event_sponsorsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: event_sponsorsCreateOrConnectWithoutEventInput | event_sponsorsCreateOrConnectWithoutEventInput[]
    upsert?: event_sponsorsUpsertWithWhereUniqueWithoutEventInput | event_sponsorsUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: event_sponsorsCreateManyEventInputEnvelope
    set?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
    disconnect?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
    delete?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
    connect?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
    update?: event_sponsorsUpdateWithWhereUniqueWithoutEventInput | event_sponsorsUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: event_sponsorsUpdateManyWithWhereWithoutEventInput | event_sponsorsUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: event_sponsorsScalarWhereInput | event_sponsorsScalarWhereInput[]
  }

  export type event_tagsUpdateManyWithoutEventNestedInput = {
    create?: XOR<event_tagsCreateWithoutEventInput, event_tagsUncheckedCreateWithoutEventInput> | event_tagsCreateWithoutEventInput[] | event_tagsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: event_tagsCreateOrConnectWithoutEventInput | event_tagsCreateOrConnectWithoutEventInput[]
    upsert?: event_tagsUpsertWithWhereUniqueWithoutEventInput | event_tagsUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: event_tagsCreateManyEventInputEnvelope
    set?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
    disconnect?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
    delete?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
    connect?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
    update?: event_tagsUpdateWithWhereUniqueWithoutEventInput | event_tagsUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: event_tagsUpdateManyWithWhereWithoutEventInput | event_tagsUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: event_tagsScalarWhereInput | event_tagsScalarWhereInput[]
  }

  export type event_usersUpdateManyWithoutEventNestedInput = {
    create?: XOR<event_usersCreateWithoutEventInput, event_usersUncheckedCreateWithoutEventInput> | event_usersCreateWithoutEventInput[] | event_usersUncheckedCreateWithoutEventInput[]
    connectOrCreate?: event_usersCreateOrConnectWithoutEventInput | event_usersCreateOrConnectWithoutEventInput[]
    upsert?: event_usersUpsertWithWhereUniqueWithoutEventInput | event_usersUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: event_usersCreateManyEventInputEnvelope
    set?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    disconnect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    delete?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    connect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    update?: event_usersUpdateWithWhereUniqueWithoutEventInput | event_usersUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: event_usersUpdateManyWithWhereWithoutEventInput | event_usersUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: event_usersScalarWhereInput | event_usersScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type event_sponsorsUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<event_sponsorsCreateWithoutEventInput, event_sponsorsUncheckedCreateWithoutEventInput> | event_sponsorsCreateWithoutEventInput[] | event_sponsorsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: event_sponsorsCreateOrConnectWithoutEventInput | event_sponsorsCreateOrConnectWithoutEventInput[]
    upsert?: event_sponsorsUpsertWithWhereUniqueWithoutEventInput | event_sponsorsUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: event_sponsorsCreateManyEventInputEnvelope
    set?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
    disconnect?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
    delete?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
    connect?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
    update?: event_sponsorsUpdateWithWhereUniqueWithoutEventInput | event_sponsorsUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: event_sponsorsUpdateManyWithWhereWithoutEventInput | event_sponsorsUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: event_sponsorsScalarWhereInput | event_sponsorsScalarWhereInput[]
  }

  export type event_tagsUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<event_tagsCreateWithoutEventInput, event_tagsUncheckedCreateWithoutEventInput> | event_tagsCreateWithoutEventInput[] | event_tagsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: event_tagsCreateOrConnectWithoutEventInput | event_tagsCreateOrConnectWithoutEventInput[]
    upsert?: event_tagsUpsertWithWhereUniqueWithoutEventInput | event_tagsUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: event_tagsCreateManyEventInputEnvelope
    set?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
    disconnect?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
    delete?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
    connect?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
    update?: event_tagsUpdateWithWhereUniqueWithoutEventInput | event_tagsUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: event_tagsUpdateManyWithWhereWithoutEventInput | event_tagsUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: event_tagsScalarWhereInput | event_tagsScalarWhereInput[]
  }

  export type event_usersUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<event_usersCreateWithoutEventInput, event_usersUncheckedCreateWithoutEventInput> | event_usersCreateWithoutEventInput[] | event_usersUncheckedCreateWithoutEventInput[]
    connectOrCreate?: event_usersCreateOrConnectWithoutEventInput | event_usersCreateOrConnectWithoutEventInput[]
    upsert?: event_usersUpsertWithWhereUniqueWithoutEventInput | event_usersUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: event_usersCreateManyEventInputEnvelope
    set?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    disconnect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    delete?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    connect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    update?: event_usersUpdateWithWhereUniqueWithoutEventInput | event_usersUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: event_usersUpdateManyWithWhereWithoutEventInput | event_usersUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: event_usersScalarWhereInput | event_usersScalarWhereInput[]
  }

  export type event_role_permissionsCreateNestedManyWithoutEvent_roleInput = {
    create?: XOR<event_role_permissionsCreateWithoutEvent_roleInput, event_role_permissionsUncheckedCreateWithoutEvent_roleInput> | event_role_permissionsCreateWithoutEvent_roleInput[] | event_role_permissionsUncheckedCreateWithoutEvent_roleInput[]
    connectOrCreate?: event_role_permissionsCreateOrConnectWithoutEvent_roleInput | event_role_permissionsCreateOrConnectWithoutEvent_roleInput[]
    createMany?: event_role_permissionsCreateManyEvent_roleInputEnvelope
    connect?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
  }

  export type event_usersCreateNestedManyWithoutEvent_roleInput = {
    create?: XOR<event_usersCreateWithoutEvent_roleInput, event_usersUncheckedCreateWithoutEvent_roleInput> | event_usersCreateWithoutEvent_roleInput[] | event_usersUncheckedCreateWithoutEvent_roleInput[]
    connectOrCreate?: event_usersCreateOrConnectWithoutEvent_roleInput | event_usersCreateOrConnectWithoutEvent_roleInput[]
    createMany?: event_usersCreateManyEvent_roleInputEnvelope
    connect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
  }

  export type event_role_permissionsUncheckedCreateNestedManyWithoutEvent_roleInput = {
    create?: XOR<event_role_permissionsCreateWithoutEvent_roleInput, event_role_permissionsUncheckedCreateWithoutEvent_roleInput> | event_role_permissionsCreateWithoutEvent_roleInput[] | event_role_permissionsUncheckedCreateWithoutEvent_roleInput[]
    connectOrCreate?: event_role_permissionsCreateOrConnectWithoutEvent_roleInput | event_role_permissionsCreateOrConnectWithoutEvent_roleInput[]
    createMany?: event_role_permissionsCreateManyEvent_roleInputEnvelope
    connect?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
  }

  export type event_usersUncheckedCreateNestedManyWithoutEvent_roleInput = {
    create?: XOR<event_usersCreateWithoutEvent_roleInput, event_usersUncheckedCreateWithoutEvent_roleInput> | event_usersCreateWithoutEvent_roleInput[] | event_usersUncheckedCreateWithoutEvent_roleInput[]
    connectOrCreate?: event_usersCreateOrConnectWithoutEvent_roleInput | event_usersCreateOrConnectWithoutEvent_roleInput[]
    createMany?: event_usersCreateManyEvent_roleInputEnvelope
    connect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
  }

  export type event_role_permissionsUpdateManyWithoutEvent_roleNestedInput = {
    create?: XOR<event_role_permissionsCreateWithoutEvent_roleInput, event_role_permissionsUncheckedCreateWithoutEvent_roleInput> | event_role_permissionsCreateWithoutEvent_roleInput[] | event_role_permissionsUncheckedCreateWithoutEvent_roleInput[]
    connectOrCreate?: event_role_permissionsCreateOrConnectWithoutEvent_roleInput | event_role_permissionsCreateOrConnectWithoutEvent_roleInput[]
    upsert?: event_role_permissionsUpsertWithWhereUniqueWithoutEvent_roleInput | event_role_permissionsUpsertWithWhereUniqueWithoutEvent_roleInput[]
    createMany?: event_role_permissionsCreateManyEvent_roleInputEnvelope
    set?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
    disconnect?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
    delete?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
    connect?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
    update?: event_role_permissionsUpdateWithWhereUniqueWithoutEvent_roleInput | event_role_permissionsUpdateWithWhereUniqueWithoutEvent_roleInput[]
    updateMany?: event_role_permissionsUpdateManyWithWhereWithoutEvent_roleInput | event_role_permissionsUpdateManyWithWhereWithoutEvent_roleInput[]
    deleteMany?: event_role_permissionsScalarWhereInput | event_role_permissionsScalarWhereInput[]
  }

  export type event_usersUpdateManyWithoutEvent_roleNestedInput = {
    create?: XOR<event_usersCreateWithoutEvent_roleInput, event_usersUncheckedCreateWithoutEvent_roleInput> | event_usersCreateWithoutEvent_roleInput[] | event_usersUncheckedCreateWithoutEvent_roleInput[]
    connectOrCreate?: event_usersCreateOrConnectWithoutEvent_roleInput | event_usersCreateOrConnectWithoutEvent_roleInput[]
    upsert?: event_usersUpsertWithWhereUniqueWithoutEvent_roleInput | event_usersUpsertWithWhereUniqueWithoutEvent_roleInput[]
    createMany?: event_usersCreateManyEvent_roleInputEnvelope
    set?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    disconnect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    delete?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    connect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    update?: event_usersUpdateWithWhereUniqueWithoutEvent_roleInput | event_usersUpdateWithWhereUniqueWithoutEvent_roleInput[]
    updateMany?: event_usersUpdateManyWithWhereWithoutEvent_roleInput | event_usersUpdateManyWithWhereWithoutEvent_roleInput[]
    deleteMany?: event_usersScalarWhereInput | event_usersScalarWhereInput[]
  }

  export type event_role_permissionsUncheckedUpdateManyWithoutEvent_roleNestedInput = {
    create?: XOR<event_role_permissionsCreateWithoutEvent_roleInput, event_role_permissionsUncheckedCreateWithoutEvent_roleInput> | event_role_permissionsCreateWithoutEvent_roleInput[] | event_role_permissionsUncheckedCreateWithoutEvent_roleInput[]
    connectOrCreate?: event_role_permissionsCreateOrConnectWithoutEvent_roleInput | event_role_permissionsCreateOrConnectWithoutEvent_roleInput[]
    upsert?: event_role_permissionsUpsertWithWhereUniqueWithoutEvent_roleInput | event_role_permissionsUpsertWithWhereUniqueWithoutEvent_roleInput[]
    createMany?: event_role_permissionsCreateManyEvent_roleInputEnvelope
    set?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
    disconnect?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
    delete?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
    connect?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
    update?: event_role_permissionsUpdateWithWhereUniqueWithoutEvent_roleInput | event_role_permissionsUpdateWithWhereUniqueWithoutEvent_roleInput[]
    updateMany?: event_role_permissionsUpdateManyWithWhereWithoutEvent_roleInput | event_role_permissionsUpdateManyWithWhereWithoutEvent_roleInput[]
    deleteMany?: event_role_permissionsScalarWhereInput | event_role_permissionsScalarWhereInput[]
  }

  export type event_usersUncheckedUpdateManyWithoutEvent_roleNestedInput = {
    create?: XOR<event_usersCreateWithoutEvent_roleInput, event_usersUncheckedCreateWithoutEvent_roleInput> | event_usersCreateWithoutEvent_roleInput[] | event_usersUncheckedCreateWithoutEvent_roleInput[]
    connectOrCreate?: event_usersCreateOrConnectWithoutEvent_roleInput | event_usersCreateOrConnectWithoutEvent_roleInput[]
    upsert?: event_usersUpsertWithWhereUniqueWithoutEvent_roleInput | event_usersUpsertWithWhereUniqueWithoutEvent_roleInput[]
    createMany?: event_usersCreateManyEvent_roleInputEnvelope
    set?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    disconnect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    delete?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    connect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    update?: event_usersUpdateWithWhereUniqueWithoutEvent_roleInput | event_usersUpdateWithWhereUniqueWithoutEvent_roleInput[]
    updateMany?: event_usersUpdateManyWithWhereWithoutEvent_roleInput | event_usersUpdateManyWithWhereWithoutEvent_roleInput[]
    deleteMany?: event_usersScalarWhereInput | event_usersScalarWhereInput[]
  }

  export type event_rolesCreateNestedOneWithoutEvent_role_permissionsInput = {
    create?: XOR<event_rolesCreateWithoutEvent_role_permissionsInput, event_rolesUncheckedCreateWithoutEvent_role_permissionsInput>
    connectOrCreate?: event_rolesCreateOrConnectWithoutEvent_role_permissionsInput
    connect?: event_rolesWhereUniqueInput
  }

  export type event_permissionsCreateNestedOneWithoutEvent_role_permissionsInput = {
    create?: XOR<event_permissionsCreateWithoutEvent_role_permissionsInput, event_permissionsUncheckedCreateWithoutEvent_role_permissionsInput>
    connectOrCreate?: event_permissionsCreateOrConnectWithoutEvent_role_permissionsInput
    connect?: event_permissionsWhereUniqueInput
  }

  export type event_rolesUpdateOneRequiredWithoutEvent_role_permissionsNestedInput = {
    create?: XOR<event_rolesCreateWithoutEvent_role_permissionsInput, event_rolesUncheckedCreateWithoutEvent_role_permissionsInput>
    connectOrCreate?: event_rolesCreateOrConnectWithoutEvent_role_permissionsInput
    upsert?: event_rolesUpsertWithoutEvent_role_permissionsInput
    connect?: event_rolesWhereUniqueInput
    update?: XOR<XOR<event_rolesUpdateToOneWithWhereWithoutEvent_role_permissionsInput, event_rolesUpdateWithoutEvent_role_permissionsInput>, event_rolesUncheckedUpdateWithoutEvent_role_permissionsInput>
  }

  export type event_permissionsUpdateOneRequiredWithoutEvent_role_permissionsNestedInput = {
    create?: XOR<event_permissionsCreateWithoutEvent_role_permissionsInput, event_permissionsUncheckedCreateWithoutEvent_role_permissionsInput>
    connectOrCreate?: event_permissionsCreateOrConnectWithoutEvent_role_permissionsInput
    upsert?: event_permissionsUpsertWithoutEvent_role_permissionsInput
    connect?: event_permissionsWhereUniqueInput
    update?: XOR<XOR<event_permissionsUpdateToOneWithWhereWithoutEvent_role_permissionsInput, event_permissionsUpdateWithoutEvent_role_permissionsInput>, event_permissionsUncheckedUpdateWithoutEvent_role_permissionsInput>
  }

  export type event_role_permissionsCreateNestedManyWithoutEvent_permissionInput = {
    create?: XOR<event_role_permissionsCreateWithoutEvent_permissionInput, event_role_permissionsUncheckedCreateWithoutEvent_permissionInput> | event_role_permissionsCreateWithoutEvent_permissionInput[] | event_role_permissionsUncheckedCreateWithoutEvent_permissionInput[]
    connectOrCreate?: event_role_permissionsCreateOrConnectWithoutEvent_permissionInput | event_role_permissionsCreateOrConnectWithoutEvent_permissionInput[]
    createMany?: event_role_permissionsCreateManyEvent_permissionInputEnvelope
    connect?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
  }

  export type event_role_permissionsUncheckedCreateNestedManyWithoutEvent_permissionInput = {
    create?: XOR<event_role_permissionsCreateWithoutEvent_permissionInput, event_role_permissionsUncheckedCreateWithoutEvent_permissionInput> | event_role_permissionsCreateWithoutEvent_permissionInput[] | event_role_permissionsUncheckedCreateWithoutEvent_permissionInput[]
    connectOrCreate?: event_role_permissionsCreateOrConnectWithoutEvent_permissionInput | event_role_permissionsCreateOrConnectWithoutEvent_permissionInput[]
    createMany?: event_role_permissionsCreateManyEvent_permissionInputEnvelope
    connect?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
  }

  export type event_role_permissionsUpdateManyWithoutEvent_permissionNestedInput = {
    create?: XOR<event_role_permissionsCreateWithoutEvent_permissionInput, event_role_permissionsUncheckedCreateWithoutEvent_permissionInput> | event_role_permissionsCreateWithoutEvent_permissionInput[] | event_role_permissionsUncheckedCreateWithoutEvent_permissionInput[]
    connectOrCreate?: event_role_permissionsCreateOrConnectWithoutEvent_permissionInput | event_role_permissionsCreateOrConnectWithoutEvent_permissionInput[]
    upsert?: event_role_permissionsUpsertWithWhereUniqueWithoutEvent_permissionInput | event_role_permissionsUpsertWithWhereUniqueWithoutEvent_permissionInput[]
    createMany?: event_role_permissionsCreateManyEvent_permissionInputEnvelope
    set?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
    disconnect?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
    delete?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
    connect?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
    update?: event_role_permissionsUpdateWithWhereUniqueWithoutEvent_permissionInput | event_role_permissionsUpdateWithWhereUniqueWithoutEvent_permissionInput[]
    updateMany?: event_role_permissionsUpdateManyWithWhereWithoutEvent_permissionInput | event_role_permissionsUpdateManyWithWhereWithoutEvent_permissionInput[]
    deleteMany?: event_role_permissionsScalarWhereInput | event_role_permissionsScalarWhereInput[]
  }

  export type event_role_permissionsUncheckedUpdateManyWithoutEvent_permissionNestedInput = {
    create?: XOR<event_role_permissionsCreateWithoutEvent_permissionInput, event_role_permissionsUncheckedCreateWithoutEvent_permissionInput> | event_role_permissionsCreateWithoutEvent_permissionInput[] | event_role_permissionsUncheckedCreateWithoutEvent_permissionInput[]
    connectOrCreate?: event_role_permissionsCreateOrConnectWithoutEvent_permissionInput | event_role_permissionsCreateOrConnectWithoutEvent_permissionInput[]
    upsert?: event_role_permissionsUpsertWithWhereUniqueWithoutEvent_permissionInput | event_role_permissionsUpsertWithWhereUniqueWithoutEvent_permissionInput[]
    createMany?: event_role_permissionsCreateManyEvent_permissionInputEnvelope
    set?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
    disconnect?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
    delete?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
    connect?: event_role_permissionsWhereUniqueInput | event_role_permissionsWhereUniqueInput[]
    update?: event_role_permissionsUpdateWithWhereUniqueWithoutEvent_permissionInput | event_role_permissionsUpdateWithWhereUniqueWithoutEvent_permissionInput[]
    updateMany?: event_role_permissionsUpdateManyWithWhereWithoutEvent_permissionInput | event_role_permissionsUpdateManyWithWhereWithoutEvent_permissionInput[]
    deleteMany?: event_role_permissionsScalarWhereInput | event_role_permissionsScalarWhereInput[]
  }

  export type event_usersCreatetitleInput = {
    set: string[]
  }

  export type usersCreateNestedOneWithoutUser_eventsInput = {
    create?: XOR<usersCreateWithoutUser_eventsInput, usersUncheckedCreateWithoutUser_eventsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_eventsInput
    connect?: usersWhereUniqueInput
  }

  export type eventsCreateNestedOneWithoutEvent_usersInput = {
    create?: XOR<eventsCreateWithoutEvent_usersInput, eventsUncheckedCreateWithoutEvent_usersInput>
    connectOrCreate?: eventsCreateOrConnectWithoutEvent_usersInput
    connect?: eventsWhereUniqueInput
  }

  export type event_rolesCreateNestedOneWithoutEvent_usersInput = {
    create?: XOR<event_rolesCreateWithoutEvent_usersInput, event_rolesUncheckedCreateWithoutEvent_usersInput>
    connectOrCreate?: event_rolesCreateOrConnectWithoutEvent_usersInput
    connect?: event_rolesWhereUniqueInput
  }

  export type attendanceCreateNestedOneWithoutEvent_usersInput = {
    create?: XOR<attendanceCreateWithoutEvent_usersInput, attendanceUncheckedCreateWithoutEvent_usersInput>
    connectOrCreate?: attendanceCreateOrConnectWithoutEvent_usersInput
    connect?: attendanceWhereUniqueInput
  }

  export type event_remindersCreateNestedOneWithoutEvent_userInput = {
    create?: XOR<event_remindersCreateWithoutEvent_userInput, event_remindersUncheckedCreateWithoutEvent_userInput>
    connectOrCreate?: event_remindersCreateOrConnectWithoutEvent_userInput
    connect?: event_remindersWhereUniqueInput
  }

  export type event_remindersUncheckedCreateNestedOneWithoutEvent_userInput = {
    create?: XOR<event_remindersCreateWithoutEvent_userInput, event_remindersUncheckedCreateWithoutEvent_userInput>
    connectOrCreate?: event_remindersCreateOrConnectWithoutEvent_userInput
    connect?: event_remindersWhereUniqueInput
  }

  export type event_usersUpdatetitleInput = {
    set?: string[]
    push?: string | string[]
  }

  export type usersUpdateOneRequiredWithoutUser_eventsNestedInput = {
    create?: XOR<usersCreateWithoutUser_eventsInput, usersUncheckedCreateWithoutUser_eventsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_eventsInput
    upsert?: usersUpsertWithoutUser_eventsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_eventsInput, usersUpdateWithoutUser_eventsInput>, usersUncheckedUpdateWithoutUser_eventsInput>
  }

  export type eventsUpdateOneRequiredWithoutEvent_usersNestedInput = {
    create?: XOR<eventsCreateWithoutEvent_usersInput, eventsUncheckedCreateWithoutEvent_usersInput>
    connectOrCreate?: eventsCreateOrConnectWithoutEvent_usersInput
    upsert?: eventsUpsertWithoutEvent_usersInput
    connect?: eventsWhereUniqueInput
    update?: XOR<XOR<eventsUpdateToOneWithWhereWithoutEvent_usersInput, eventsUpdateWithoutEvent_usersInput>, eventsUncheckedUpdateWithoutEvent_usersInput>
  }

  export type event_rolesUpdateOneRequiredWithoutEvent_usersNestedInput = {
    create?: XOR<event_rolesCreateWithoutEvent_usersInput, event_rolesUncheckedCreateWithoutEvent_usersInput>
    connectOrCreate?: event_rolesCreateOrConnectWithoutEvent_usersInput
    upsert?: event_rolesUpsertWithoutEvent_usersInput
    connect?: event_rolesWhereUniqueInput
    update?: XOR<XOR<event_rolesUpdateToOneWithWhereWithoutEvent_usersInput, event_rolesUpdateWithoutEvent_usersInput>, event_rolesUncheckedUpdateWithoutEvent_usersInput>
  }

  export type attendanceUpdateOneRequiredWithoutEvent_usersNestedInput = {
    create?: XOR<attendanceCreateWithoutEvent_usersInput, attendanceUncheckedCreateWithoutEvent_usersInput>
    connectOrCreate?: attendanceCreateOrConnectWithoutEvent_usersInput
    upsert?: attendanceUpsertWithoutEvent_usersInput
    connect?: attendanceWhereUniqueInput
    update?: XOR<XOR<attendanceUpdateToOneWithWhereWithoutEvent_usersInput, attendanceUpdateWithoutEvent_usersInput>, attendanceUncheckedUpdateWithoutEvent_usersInput>
  }

  export type event_remindersUpdateOneWithoutEvent_userNestedInput = {
    create?: XOR<event_remindersCreateWithoutEvent_userInput, event_remindersUncheckedCreateWithoutEvent_userInput>
    connectOrCreate?: event_remindersCreateOrConnectWithoutEvent_userInput
    upsert?: event_remindersUpsertWithoutEvent_userInput
    disconnect?: event_remindersWhereInput | boolean
    delete?: event_remindersWhereInput | boolean
    connect?: event_remindersWhereUniqueInput
    update?: XOR<XOR<event_remindersUpdateToOneWithWhereWithoutEvent_userInput, event_remindersUpdateWithoutEvent_userInput>, event_remindersUncheckedUpdateWithoutEvent_userInput>
  }

  export type event_remindersUncheckedUpdateOneWithoutEvent_userNestedInput = {
    create?: XOR<event_remindersCreateWithoutEvent_userInput, event_remindersUncheckedCreateWithoutEvent_userInput>
    connectOrCreate?: event_remindersCreateOrConnectWithoutEvent_userInput
    upsert?: event_remindersUpsertWithoutEvent_userInput
    disconnect?: event_remindersWhereInput | boolean
    delete?: event_remindersWhereInput | boolean
    connect?: event_remindersWhereUniqueInput
    update?: XOR<XOR<event_remindersUpdateToOneWithWhereWithoutEvent_userInput, event_remindersUpdateWithoutEvent_userInput>, event_remindersUncheckedUpdateWithoutEvent_userInput>
  }

  export type event_usersCreateNestedOneWithoutEvent_reminderInput = {
    create?: XOR<event_usersCreateWithoutEvent_reminderInput, event_usersUncheckedCreateWithoutEvent_reminderInput>
    connectOrCreate?: event_usersCreateOrConnectWithoutEvent_reminderInput
    connect?: event_usersWhereUniqueInput
  }

  export type event_usersUpdateOneRequiredWithoutEvent_reminderNestedInput = {
    create?: XOR<event_usersCreateWithoutEvent_reminderInput, event_usersUncheckedCreateWithoutEvent_reminderInput>
    connectOrCreate?: event_usersCreateOrConnectWithoutEvent_reminderInput
    upsert?: event_usersUpsertWithoutEvent_reminderInput
    connect?: event_usersWhereUniqueInput
    update?: XOR<XOR<event_usersUpdateToOneWithWhereWithoutEvent_reminderInput, event_usersUpdateWithoutEvent_reminderInput>, event_usersUncheckedUpdateWithoutEvent_reminderInput>
  }

  export type event_usersCreateNestedManyWithoutAttendanceInput = {
    create?: XOR<event_usersCreateWithoutAttendanceInput, event_usersUncheckedCreateWithoutAttendanceInput> | event_usersCreateWithoutAttendanceInput[] | event_usersUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: event_usersCreateOrConnectWithoutAttendanceInput | event_usersCreateOrConnectWithoutAttendanceInput[]
    createMany?: event_usersCreateManyAttendanceInputEnvelope
    connect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
  }

  export type event_usersUncheckedCreateNestedManyWithoutAttendanceInput = {
    create?: XOR<event_usersCreateWithoutAttendanceInput, event_usersUncheckedCreateWithoutAttendanceInput> | event_usersCreateWithoutAttendanceInput[] | event_usersUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: event_usersCreateOrConnectWithoutAttendanceInput | event_usersCreateOrConnectWithoutAttendanceInput[]
    createMany?: event_usersCreateManyAttendanceInputEnvelope
    connect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
  }

  export type event_usersUpdateManyWithoutAttendanceNestedInput = {
    create?: XOR<event_usersCreateWithoutAttendanceInput, event_usersUncheckedCreateWithoutAttendanceInput> | event_usersCreateWithoutAttendanceInput[] | event_usersUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: event_usersCreateOrConnectWithoutAttendanceInput | event_usersCreateOrConnectWithoutAttendanceInput[]
    upsert?: event_usersUpsertWithWhereUniqueWithoutAttendanceInput | event_usersUpsertWithWhereUniqueWithoutAttendanceInput[]
    createMany?: event_usersCreateManyAttendanceInputEnvelope
    set?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    disconnect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    delete?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    connect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    update?: event_usersUpdateWithWhereUniqueWithoutAttendanceInput | event_usersUpdateWithWhereUniqueWithoutAttendanceInput[]
    updateMany?: event_usersUpdateManyWithWhereWithoutAttendanceInput | event_usersUpdateManyWithWhereWithoutAttendanceInput[]
    deleteMany?: event_usersScalarWhereInput | event_usersScalarWhereInput[]
  }

  export type event_usersUncheckedUpdateManyWithoutAttendanceNestedInput = {
    create?: XOR<event_usersCreateWithoutAttendanceInput, event_usersUncheckedCreateWithoutAttendanceInput> | event_usersCreateWithoutAttendanceInput[] | event_usersUncheckedCreateWithoutAttendanceInput[]
    connectOrCreate?: event_usersCreateOrConnectWithoutAttendanceInput | event_usersCreateOrConnectWithoutAttendanceInput[]
    upsert?: event_usersUpsertWithWhereUniqueWithoutAttendanceInput | event_usersUpsertWithWhereUniqueWithoutAttendanceInput[]
    createMany?: event_usersCreateManyAttendanceInputEnvelope
    set?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    disconnect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    delete?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    connect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    update?: event_usersUpdateWithWhereUniqueWithoutAttendanceInput | event_usersUpdateWithWhereUniqueWithoutAttendanceInput[]
    updateMany?: event_usersUpdateManyWithWhereWithoutAttendanceInput | event_usersUpdateManyWithWhereWithoutAttendanceInput[]
    deleteMany?: event_usersScalarWhereInput | event_usersScalarWhereInput[]
  }

  export type event_sponsorsCreateNestedManyWithoutSponsorInput = {
    create?: XOR<event_sponsorsCreateWithoutSponsorInput, event_sponsorsUncheckedCreateWithoutSponsorInput> | event_sponsorsCreateWithoutSponsorInput[] | event_sponsorsUncheckedCreateWithoutSponsorInput[]
    connectOrCreate?: event_sponsorsCreateOrConnectWithoutSponsorInput | event_sponsorsCreateOrConnectWithoutSponsorInput[]
    createMany?: event_sponsorsCreateManySponsorInputEnvelope
    connect?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
  }

  export type event_sponsorsUncheckedCreateNestedManyWithoutSponsorInput = {
    create?: XOR<event_sponsorsCreateWithoutSponsorInput, event_sponsorsUncheckedCreateWithoutSponsorInput> | event_sponsorsCreateWithoutSponsorInput[] | event_sponsorsUncheckedCreateWithoutSponsorInput[]
    connectOrCreate?: event_sponsorsCreateOrConnectWithoutSponsorInput | event_sponsorsCreateOrConnectWithoutSponsorInput[]
    createMany?: event_sponsorsCreateManySponsorInputEnvelope
    connect?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
  }

  export type event_sponsorsUpdateManyWithoutSponsorNestedInput = {
    create?: XOR<event_sponsorsCreateWithoutSponsorInput, event_sponsorsUncheckedCreateWithoutSponsorInput> | event_sponsorsCreateWithoutSponsorInput[] | event_sponsorsUncheckedCreateWithoutSponsorInput[]
    connectOrCreate?: event_sponsorsCreateOrConnectWithoutSponsorInput | event_sponsorsCreateOrConnectWithoutSponsorInput[]
    upsert?: event_sponsorsUpsertWithWhereUniqueWithoutSponsorInput | event_sponsorsUpsertWithWhereUniqueWithoutSponsorInput[]
    createMany?: event_sponsorsCreateManySponsorInputEnvelope
    set?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
    disconnect?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
    delete?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
    connect?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
    update?: event_sponsorsUpdateWithWhereUniqueWithoutSponsorInput | event_sponsorsUpdateWithWhereUniqueWithoutSponsorInput[]
    updateMany?: event_sponsorsUpdateManyWithWhereWithoutSponsorInput | event_sponsorsUpdateManyWithWhereWithoutSponsorInput[]
    deleteMany?: event_sponsorsScalarWhereInput | event_sponsorsScalarWhereInput[]
  }

  export type event_sponsorsUncheckedUpdateManyWithoutSponsorNestedInput = {
    create?: XOR<event_sponsorsCreateWithoutSponsorInput, event_sponsorsUncheckedCreateWithoutSponsorInput> | event_sponsorsCreateWithoutSponsorInput[] | event_sponsorsUncheckedCreateWithoutSponsorInput[]
    connectOrCreate?: event_sponsorsCreateOrConnectWithoutSponsorInput | event_sponsorsCreateOrConnectWithoutSponsorInput[]
    upsert?: event_sponsorsUpsertWithWhereUniqueWithoutSponsorInput | event_sponsorsUpsertWithWhereUniqueWithoutSponsorInput[]
    createMany?: event_sponsorsCreateManySponsorInputEnvelope
    set?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
    disconnect?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
    delete?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
    connect?: event_sponsorsWhereUniqueInput | event_sponsorsWhereUniqueInput[]
    update?: event_sponsorsUpdateWithWhereUniqueWithoutSponsorInput | event_sponsorsUpdateWithWhereUniqueWithoutSponsorInput[]
    updateMany?: event_sponsorsUpdateManyWithWhereWithoutSponsorInput | event_sponsorsUpdateManyWithWhereWithoutSponsorInput[]
    deleteMany?: event_sponsorsScalarWhereInput | event_sponsorsScalarWhereInput[]
  }

  export type chapter_tagsCreateNestedManyWithoutTagInput = {
    create?: XOR<chapter_tagsCreateWithoutTagInput, chapter_tagsUncheckedCreateWithoutTagInput> | chapter_tagsCreateWithoutTagInput[] | chapter_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: chapter_tagsCreateOrConnectWithoutTagInput | chapter_tagsCreateOrConnectWithoutTagInput[]
    createMany?: chapter_tagsCreateManyTagInputEnvelope
    connect?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
  }

  export type event_tagsCreateNestedManyWithoutTagInput = {
    create?: XOR<event_tagsCreateWithoutTagInput, event_tagsUncheckedCreateWithoutTagInput> | event_tagsCreateWithoutTagInput[] | event_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: event_tagsCreateOrConnectWithoutTagInput | event_tagsCreateOrConnectWithoutTagInput[]
    createMany?: event_tagsCreateManyTagInputEnvelope
    connect?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
  }

  export type venue_tagsCreateNestedManyWithoutTagInput = {
    create?: XOR<venue_tagsCreateWithoutTagInput, venue_tagsUncheckedCreateWithoutTagInput> | venue_tagsCreateWithoutTagInput[] | venue_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: venue_tagsCreateOrConnectWithoutTagInput | venue_tagsCreateOrConnectWithoutTagInput[]
    createMany?: venue_tagsCreateManyTagInputEnvelope
    connect?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
  }

  export type chapter_tagsUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<chapter_tagsCreateWithoutTagInput, chapter_tagsUncheckedCreateWithoutTagInput> | chapter_tagsCreateWithoutTagInput[] | chapter_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: chapter_tagsCreateOrConnectWithoutTagInput | chapter_tagsCreateOrConnectWithoutTagInput[]
    createMany?: chapter_tagsCreateManyTagInputEnvelope
    connect?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
  }

  export type event_tagsUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<event_tagsCreateWithoutTagInput, event_tagsUncheckedCreateWithoutTagInput> | event_tagsCreateWithoutTagInput[] | event_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: event_tagsCreateOrConnectWithoutTagInput | event_tagsCreateOrConnectWithoutTagInput[]
    createMany?: event_tagsCreateManyTagInputEnvelope
    connect?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
  }

  export type venue_tagsUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<venue_tagsCreateWithoutTagInput, venue_tagsUncheckedCreateWithoutTagInput> | venue_tagsCreateWithoutTagInput[] | venue_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: venue_tagsCreateOrConnectWithoutTagInput | venue_tagsCreateOrConnectWithoutTagInput[]
    createMany?: venue_tagsCreateManyTagInputEnvelope
    connect?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
  }

  export type chapter_tagsUpdateManyWithoutTagNestedInput = {
    create?: XOR<chapter_tagsCreateWithoutTagInput, chapter_tagsUncheckedCreateWithoutTagInput> | chapter_tagsCreateWithoutTagInput[] | chapter_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: chapter_tagsCreateOrConnectWithoutTagInput | chapter_tagsCreateOrConnectWithoutTagInput[]
    upsert?: chapter_tagsUpsertWithWhereUniqueWithoutTagInput | chapter_tagsUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: chapter_tagsCreateManyTagInputEnvelope
    set?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
    disconnect?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
    delete?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
    connect?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
    update?: chapter_tagsUpdateWithWhereUniqueWithoutTagInput | chapter_tagsUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: chapter_tagsUpdateManyWithWhereWithoutTagInput | chapter_tagsUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: chapter_tagsScalarWhereInput | chapter_tagsScalarWhereInput[]
  }

  export type event_tagsUpdateManyWithoutTagNestedInput = {
    create?: XOR<event_tagsCreateWithoutTagInput, event_tagsUncheckedCreateWithoutTagInput> | event_tagsCreateWithoutTagInput[] | event_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: event_tagsCreateOrConnectWithoutTagInput | event_tagsCreateOrConnectWithoutTagInput[]
    upsert?: event_tagsUpsertWithWhereUniqueWithoutTagInput | event_tagsUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: event_tagsCreateManyTagInputEnvelope
    set?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
    disconnect?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
    delete?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
    connect?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
    update?: event_tagsUpdateWithWhereUniqueWithoutTagInput | event_tagsUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: event_tagsUpdateManyWithWhereWithoutTagInput | event_tagsUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: event_tagsScalarWhereInput | event_tagsScalarWhereInput[]
  }

  export type venue_tagsUpdateManyWithoutTagNestedInput = {
    create?: XOR<venue_tagsCreateWithoutTagInput, venue_tagsUncheckedCreateWithoutTagInput> | venue_tagsCreateWithoutTagInput[] | venue_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: venue_tagsCreateOrConnectWithoutTagInput | venue_tagsCreateOrConnectWithoutTagInput[]
    upsert?: venue_tagsUpsertWithWhereUniqueWithoutTagInput | venue_tagsUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: venue_tagsCreateManyTagInputEnvelope
    set?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
    disconnect?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
    delete?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
    connect?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
    update?: venue_tagsUpdateWithWhereUniqueWithoutTagInput | venue_tagsUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: venue_tagsUpdateManyWithWhereWithoutTagInput | venue_tagsUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: venue_tagsScalarWhereInput | venue_tagsScalarWhereInput[]
  }

  export type chapter_tagsUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<chapter_tagsCreateWithoutTagInput, chapter_tagsUncheckedCreateWithoutTagInput> | chapter_tagsCreateWithoutTagInput[] | chapter_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: chapter_tagsCreateOrConnectWithoutTagInput | chapter_tagsCreateOrConnectWithoutTagInput[]
    upsert?: chapter_tagsUpsertWithWhereUniqueWithoutTagInput | chapter_tagsUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: chapter_tagsCreateManyTagInputEnvelope
    set?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
    disconnect?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
    delete?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
    connect?: chapter_tagsWhereUniqueInput | chapter_tagsWhereUniqueInput[]
    update?: chapter_tagsUpdateWithWhereUniqueWithoutTagInput | chapter_tagsUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: chapter_tagsUpdateManyWithWhereWithoutTagInput | chapter_tagsUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: chapter_tagsScalarWhereInput | chapter_tagsScalarWhereInput[]
  }

  export type event_tagsUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<event_tagsCreateWithoutTagInput, event_tagsUncheckedCreateWithoutTagInput> | event_tagsCreateWithoutTagInput[] | event_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: event_tagsCreateOrConnectWithoutTagInput | event_tagsCreateOrConnectWithoutTagInput[]
    upsert?: event_tagsUpsertWithWhereUniqueWithoutTagInput | event_tagsUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: event_tagsCreateManyTagInputEnvelope
    set?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
    disconnect?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
    delete?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
    connect?: event_tagsWhereUniqueInput | event_tagsWhereUniqueInput[]
    update?: event_tagsUpdateWithWhereUniqueWithoutTagInput | event_tagsUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: event_tagsUpdateManyWithWhereWithoutTagInput | event_tagsUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: event_tagsScalarWhereInput | event_tagsScalarWhereInput[]
  }

  export type venue_tagsUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<venue_tagsCreateWithoutTagInput, venue_tagsUncheckedCreateWithoutTagInput> | venue_tagsCreateWithoutTagInput[] | venue_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: venue_tagsCreateOrConnectWithoutTagInput | venue_tagsCreateOrConnectWithoutTagInput[]
    upsert?: venue_tagsUpsertWithWhereUniqueWithoutTagInput | venue_tagsUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: venue_tagsCreateManyTagInputEnvelope
    set?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
    disconnect?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
    delete?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
    connect?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
    update?: venue_tagsUpdateWithWhereUniqueWithoutTagInput | venue_tagsUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: venue_tagsUpdateManyWithWhereWithoutTagInput | venue_tagsUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: venue_tagsScalarWhereInput | venue_tagsScalarWhereInput[]
  }

  export type chaptersCreateNestedOneWithoutUser_bansInput = {
    create?: XOR<chaptersCreateWithoutUser_bansInput, chaptersUncheckedCreateWithoutUser_bansInput>
    connectOrCreate?: chaptersCreateOrConnectWithoutUser_bansInput
    connect?: chaptersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutUser_bansInput = {
    create?: XOR<usersCreateWithoutUser_bansInput, usersUncheckedCreateWithoutUser_bansInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_bansInput
    connect?: usersWhereUniqueInput
  }

  export type chaptersUpdateOneRequiredWithoutUser_bansNestedInput = {
    create?: XOR<chaptersCreateWithoutUser_bansInput, chaptersUncheckedCreateWithoutUser_bansInput>
    connectOrCreate?: chaptersCreateOrConnectWithoutUser_bansInput
    upsert?: chaptersUpsertWithoutUser_bansInput
    connect?: chaptersWhereUniqueInput
    update?: XOR<XOR<chaptersUpdateToOneWithWhereWithoutUser_bansInput, chaptersUpdateWithoutUser_bansInput>, chaptersUncheckedUpdateWithoutUser_bansInput>
  }

  export type usersUpdateOneRequiredWithoutUser_bansNestedInput = {
    create?: XOR<usersCreateWithoutUser_bansInput, usersUncheckedCreateWithoutUser_bansInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_bansInput
    upsert?: usersUpsertWithoutUser_bansInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_bansInput, usersUpdateWithoutUser_bansInput>, usersUncheckedUpdateWithoutUser_bansInput>
  }

  export type instance_role_permissionsCreateNestedManyWithoutInstance_permissionInput = {
    create?: XOR<instance_role_permissionsCreateWithoutInstance_permissionInput, instance_role_permissionsUncheckedCreateWithoutInstance_permissionInput> | instance_role_permissionsCreateWithoutInstance_permissionInput[] | instance_role_permissionsUncheckedCreateWithoutInstance_permissionInput[]
    connectOrCreate?: instance_role_permissionsCreateOrConnectWithoutInstance_permissionInput | instance_role_permissionsCreateOrConnectWithoutInstance_permissionInput[]
    createMany?: instance_role_permissionsCreateManyInstance_permissionInputEnvelope
    connect?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
  }

  export type instance_role_permissionsUncheckedCreateNestedManyWithoutInstance_permissionInput = {
    create?: XOR<instance_role_permissionsCreateWithoutInstance_permissionInput, instance_role_permissionsUncheckedCreateWithoutInstance_permissionInput> | instance_role_permissionsCreateWithoutInstance_permissionInput[] | instance_role_permissionsUncheckedCreateWithoutInstance_permissionInput[]
    connectOrCreate?: instance_role_permissionsCreateOrConnectWithoutInstance_permissionInput | instance_role_permissionsCreateOrConnectWithoutInstance_permissionInput[]
    createMany?: instance_role_permissionsCreateManyInstance_permissionInputEnvelope
    connect?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
  }

  export type instance_role_permissionsUpdateManyWithoutInstance_permissionNestedInput = {
    create?: XOR<instance_role_permissionsCreateWithoutInstance_permissionInput, instance_role_permissionsUncheckedCreateWithoutInstance_permissionInput> | instance_role_permissionsCreateWithoutInstance_permissionInput[] | instance_role_permissionsUncheckedCreateWithoutInstance_permissionInput[]
    connectOrCreate?: instance_role_permissionsCreateOrConnectWithoutInstance_permissionInput | instance_role_permissionsCreateOrConnectWithoutInstance_permissionInput[]
    upsert?: instance_role_permissionsUpsertWithWhereUniqueWithoutInstance_permissionInput | instance_role_permissionsUpsertWithWhereUniqueWithoutInstance_permissionInput[]
    createMany?: instance_role_permissionsCreateManyInstance_permissionInputEnvelope
    set?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
    disconnect?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
    delete?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
    connect?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
    update?: instance_role_permissionsUpdateWithWhereUniqueWithoutInstance_permissionInput | instance_role_permissionsUpdateWithWhereUniqueWithoutInstance_permissionInput[]
    updateMany?: instance_role_permissionsUpdateManyWithWhereWithoutInstance_permissionInput | instance_role_permissionsUpdateManyWithWhereWithoutInstance_permissionInput[]
    deleteMany?: instance_role_permissionsScalarWhereInput | instance_role_permissionsScalarWhereInput[]
  }

  export type instance_role_permissionsUncheckedUpdateManyWithoutInstance_permissionNestedInput = {
    create?: XOR<instance_role_permissionsCreateWithoutInstance_permissionInput, instance_role_permissionsUncheckedCreateWithoutInstance_permissionInput> | instance_role_permissionsCreateWithoutInstance_permissionInput[] | instance_role_permissionsUncheckedCreateWithoutInstance_permissionInput[]
    connectOrCreate?: instance_role_permissionsCreateOrConnectWithoutInstance_permissionInput | instance_role_permissionsCreateOrConnectWithoutInstance_permissionInput[]
    upsert?: instance_role_permissionsUpsertWithWhereUniqueWithoutInstance_permissionInput | instance_role_permissionsUpsertWithWhereUniqueWithoutInstance_permissionInput[]
    createMany?: instance_role_permissionsCreateManyInstance_permissionInputEnvelope
    set?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
    disconnect?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
    delete?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
    connect?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
    update?: instance_role_permissionsUpdateWithWhereUniqueWithoutInstance_permissionInput | instance_role_permissionsUpdateWithWhereUniqueWithoutInstance_permissionInput[]
    updateMany?: instance_role_permissionsUpdateManyWithWhereWithoutInstance_permissionInput | instance_role_permissionsUpdateManyWithWhereWithoutInstance_permissionInput[]
    deleteMany?: instance_role_permissionsScalarWhereInput | instance_role_permissionsScalarWhereInput[]
  }

  export type instance_rolesCreateNestedOneWithoutInstance_role_permissionsInput = {
    create?: XOR<instance_rolesCreateWithoutInstance_role_permissionsInput, instance_rolesUncheckedCreateWithoutInstance_role_permissionsInput>
    connectOrCreate?: instance_rolesCreateOrConnectWithoutInstance_role_permissionsInput
    connect?: instance_rolesWhereUniqueInput
  }

  export type instance_permissionsCreateNestedOneWithoutInstance_role_permissionsInput = {
    create?: XOR<instance_permissionsCreateWithoutInstance_role_permissionsInput, instance_permissionsUncheckedCreateWithoutInstance_role_permissionsInput>
    connectOrCreate?: instance_permissionsCreateOrConnectWithoutInstance_role_permissionsInput
    connect?: instance_permissionsWhereUniqueInput
  }

  export type instance_rolesUpdateOneRequiredWithoutInstance_role_permissionsNestedInput = {
    create?: XOR<instance_rolesCreateWithoutInstance_role_permissionsInput, instance_rolesUncheckedCreateWithoutInstance_role_permissionsInput>
    connectOrCreate?: instance_rolesCreateOrConnectWithoutInstance_role_permissionsInput
    upsert?: instance_rolesUpsertWithoutInstance_role_permissionsInput
    connect?: instance_rolesWhereUniqueInput
    update?: XOR<XOR<instance_rolesUpdateToOneWithWhereWithoutInstance_role_permissionsInput, instance_rolesUpdateWithoutInstance_role_permissionsInput>, instance_rolesUncheckedUpdateWithoutInstance_role_permissionsInput>
  }

  export type instance_permissionsUpdateOneRequiredWithoutInstance_role_permissionsNestedInput = {
    create?: XOR<instance_permissionsCreateWithoutInstance_role_permissionsInput, instance_permissionsUncheckedCreateWithoutInstance_role_permissionsInput>
    connectOrCreate?: instance_permissionsCreateOrConnectWithoutInstance_role_permissionsInput
    upsert?: instance_permissionsUpsertWithoutInstance_role_permissionsInput
    connect?: instance_permissionsWhereUniqueInput
    update?: XOR<XOR<instance_permissionsUpdateToOneWithWhereWithoutInstance_role_permissionsInput, instance_permissionsUpdateWithoutInstance_role_permissionsInput>, instance_permissionsUncheckedUpdateWithoutInstance_role_permissionsInput>
  }

  export type instance_role_permissionsCreateNestedManyWithoutInstance_roleInput = {
    create?: XOR<instance_role_permissionsCreateWithoutInstance_roleInput, instance_role_permissionsUncheckedCreateWithoutInstance_roleInput> | instance_role_permissionsCreateWithoutInstance_roleInput[] | instance_role_permissionsUncheckedCreateWithoutInstance_roleInput[]
    connectOrCreate?: instance_role_permissionsCreateOrConnectWithoutInstance_roleInput | instance_role_permissionsCreateOrConnectWithoutInstance_roleInput[]
    createMany?: instance_role_permissionsCreateManyInstance_roleInputEnvelope
    connect?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutInstance_roleInput = {
    create?: XOR<usersCreateWithoutInstance_roleInput, usersUncheckedCreateWithoutInstance_roleInput> | usersCreateWithoutInstance_roleInput[] | usersUncheckedCreateWithoutInstance_roleInput[]
    connectOrCreate?: usersCreateOrConnectWithoutInstance_roleInput | usersCreateOrConnectWithoutInstance_roleInput[]
    createMany?: usersCreateManyInstance_roleInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type instance_role_permissionsUncheckedCreateNestedManyWithoutInstance_roleInput = {
    create?: XOR<instance_role_permissionsCreateWithoutInstance_roleInput, instance_role_permissionsUncheckedCreateWithoutInstance_roleInput> | instance_role_permissionsCreateWithoutInstance_roleInput[] | instance_role_permissionsUncheckedCreateWithoutInstance_roleInput[]
    connectOrCreate?: instance_role_permissionsCreateOrConnectWithoutInstance_roleInput | instance_role_permissionsCreateOrConnectWithoutInstance_roleInput[]
    createMany?: instance_role_permissionsCreateManyInstance_roleInputEnvelope
    connect?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutInstance_roleInput = {
    create?: XOR<usersCreateWithoutInstance_roleInput, usersUncheckedCreateWithoutInstance_roleInput> | usersCreateWithoutInstance_roleInput[] | usersUncheckedCreateWithoutInstance_roleInput[]
    connectOrCreate?: usersCreateOrConnectWithoutInstance_roleInput | usersCreateOrConnectWithoutInstance_roleInput[]
    createMany?: usersCreateManyInstance_roleInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type instance_role_permissionsUpdateManyWithoutInstance_roleNestedInput = {
    create?: XOR<instance_role_permissionsCreateWithoutInstance_roleInput, instance_role_permissionsUncheckedCreateWithoutInstance_roleInput> | instance_role_permissionsCreateWithoutInstance_roleInput[] | instance_role_permissionsUncheckedCreateWithoutInstance_roleInput[]
    connectOrCreate?: instance_role_permissionsCreateOrConnectWithoutInstance_roleInput | instance_role_permissionsCreateOrConnectWithoutInstance_roleInput[]
    upsert?: instance_role_permissionsUpsertWithWhereUniqueWithoutInstance_roleInput | instance_role_permissionsUpsertWithWhereUniqueWithoutInstance_roleInput[]
    createMany?: instance_role_permissionsCreateManyInstance_roleInputEnvelope
    set?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
    disconnect?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
    delete?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
    connect?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
    update?: instance_role_permissionsUpdateWithWhereUniqueWithoutInstance_roleInput | instance_role_permissionsUpdateWithWhereUniqueWithoutInstance_roleInput[]
    updateMany?: instance_role_permissionsUpdateManyWithWhereWithoutInstance_roleInput | instance_role_permissionsUpdateManyWithWhereWithoutInstance_roleInput[]
    deleteMany?: instance_role_permissionsScalarWhereInput | instance_role_permissionsScalarWhereInput[]
  }

  export type usersUpdateManyWithoutInstance_roleNestedInput = {
    create?: XOR<usersCreateWithoutInstance_roleInput, usersUncheckedCreateWithoutInstance_roleInput> | usersCreateWithoutInstance_roleInput[] | usersUncheckedCreateWithoutInstance_roleInput[]
    connectOrCreate?: usersCreateOrConnectWithoutInstance_roleInput | usersCreateOrConnectWithoutInstance_roleInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutInstance_roleInput | usersUpsertWithWhereUniqueWithoutInstance_roleInput[]
    createMany?: usersCreateManyInstance_roleInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutInstance_roleInput | usersUpdateWithWhereUniqueWithoutInstance_roleInput[]
    updateMany?: usersUpdateManyWithWhereWithoutInstance_roleInput | usersUpdateManyWithWhereWithoutInstance_roleInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type instance_role_permissionsUncheckedUpdateManyWithoutInstance_roleNestedInput = {
    create?: XOR<instance_role_permissionsCreateWithoutInstance_roleInput, instance_role_permissionsUncheckedCreateWithoutInstance_roleInput> | instance_role_permissionsCreateWithoutInstance_roleInput[] | instance_role_permissionsUncheckedCreateWithoutInstance_roleInput[]
    connectOrCreate?: instance_role_permissionsCreateOrConnectWithoutInstance_roleInput | instance_role_permissionsCreateOrConnectWithoutInstance_roleInput[]
    upsert?: instance_role_permissionsUpsertWithWhereUniqueWithoutInstance_roleInput | instance_role_permissionsUpsertWithWhereUniqueWithoutInstance_roleInput[]
    createMany?: instance_role_permissionsCreateManyInstance_roleInputEnvelope
    set?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
    disconnect?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
    delete?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
    connect?: instance_role_permissionsWhereUniqueInput | instance_role_permissionsWhereUniqueInput[]
    update?: instance_role_permissionsUpdateWithWhereUniqueWithoutInstance_roleInput | instance_role_permissionsUpdateWithWhereUniqueWithoutInstance_roleInput[]
    updateMany?: instance_role_permissionsUpdateManyWithWhereWithoutInstance_roleInput | instance_role_permissionsUpdateManyWithWhereWithoutInstance_roleInput[]
    deleteMany?: instance_role_permissionsScalarWhereInput | instance_role_permissionsScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutInstance_roleNestedInput = {
    create?: XOR<usersCreateWithoutInstance_roleInput, usersUncheckedCreateWithoutInstance_roleInput> | usersCreateWithoutInstance_roleInput[] | usersUncheckedCreateWithoutInstance_roleInput[]
    connectOrCreate?: usersCreateOrConnectWithoutInstance_roleInput | usersCreateOrConnectWithoutInstance_roleInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutInstance_roleInput | usersUpsertWithWhereUniqueWithoutInstance_roleInput[]
    createMany?: usersCreateManyInstance_roleInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutInstance_roleInput | usersUpdateWithWhereUniqueWithoutInstance_roleInput[]
    updateMany?: usersUpdateManyWithWhereWithoutInstance_roleInput | usersUpdateManyWithWhereWithoutInstance_roleInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type user_bansCreateNestedManyWithoutUserInput = {
    create?: XOR<user_bansCreateWithoutUserInput, user_bansUncheckedCreateWithoutUserInput> | user_bansCreateWithoutUserInput[] | user_bansUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_bansCreateOrConnectWithoutUserInput | user_bansCreateOrConnectWithoutUserInput[]
    createMany?: user_bansCreateManyUserInputEnvelope
    connect?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
  }

  export type chapter_usersCreateNestedManyWithoutUserInput = {
    create?: XOR<chapter_usersCreateWithoutUserInput, chapter_usersUncheckedCreateWithoutUserInput> | chapter_usersCreateWithoutUserInput[] | chapter_usersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chapter_usersCreateOrConnectWithoutUserInput | chapter_usersCreateOrConnectWithoutUserInput[]
    createMany?: chapter_usersCreateManyUserInputEnvelope
    connect?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
  }

  export type instance_rolesCreateNestedOneWithoutUsersInput = {
    create?: XOR<instance_rolesCreateWithoutUsersInput, instance_rolesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: instance_rolesCreateOrConnectWithoutUsersInput
    connect?: instance_rolesWhereUniqueInput
  }

  export type event_usersCreateNestedManyWithoutUserInput = {
    create?: XOR<event_usersCreateWithoutUserInput, event_usersUncheckedCreateWithoutUserInput> | event_usersCreateWithoutUserInput[] | event_usersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: event_usersCreateOrConnectWithoutUserInput | event_usersCreateOrConnectWithoutUserInput[]
    createMany?: event_usersCreateManyUserInputEnvelope
    connect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
  }

  export type sessionsCreateNestedOneWithoutUserInput = {
    create?: XOR<sessionsCreateWithoutUserInput, sessionsUncheckedCreateWithoutUserInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutUserInput
    connect?: sessionsWhereUniqueInput
  }

  export type user_bansUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<user_bansCreateWithoutUserInput, user_bansUncheckedCreateWithoutUserInput> | user_bansCreateWithoutUserInput[] | user_bansUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_bansCreateOrConnectWithoutUserInput | user_bansCreateOrConnectWithoutUserInput[]
    createMany?: user_bansCreateManyUserInputEnvelope
    connect?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
  }

  export type chapter_usersUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<chapter_usersCreateWithoutUserInput, chapter_usersUncheckedCreateWithoutUserInput> | chapter_usersCreateWithoutUserInput[] | chapter_usersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chapter_usersCreateOrConnectWithoutUserInput | chapter_usersCreateOrConnectWithoutUserInput[]
    createMany?: chapter_usersCreateManyUserInputEnvelope
    connect?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
  }

  export type event_usersUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<event_usersCreateWithoutUserInput, event_usersUncheckedCreateWithoutUserInput> | event_usersCreateWithoutUserInput[] | event_usersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: event_usersCreateOrConnectWithoutUserInput | event_usersCreateOrConnectWithoutUserInput[]
    createMany?: event_usersCreateManyUserInputEnvelope
    connect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
  }

  export type sessionsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<sessionsCreateWithoutUserInput, sessionsUncheckedCreateWithoutUserInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutUserInput
    connect?: sessionsWhereUniqueInput
  }

  export type user_bansUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_bansCreateWithoutUserInput, user_bansUncheckedCreateWithoutUserInput> | user_bansCreateWithoutUserInput[] | user_bansUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_bansCreateOrConnectWithoutUserInput | user_bansCreateOrConnectWithoutUserInput[]
    upsert?: user_bansUpsertWithWhereUniqueWithoutUserInput | user_bansUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_bansCreateManyUserInputEnvelope
    set?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
    disconnect?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
    delete?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
    connect?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
    update?: user_bansUpdateWithWhereUniqueWithoutUserInput | user_bansUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_bansUpdateManyWithWhereWithoutUserInput | user_bansUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_bansScalarWhereInput | user_bansScalarWhereInput[]
  }

  export type chapter_usersUpdateManyWithoutUserNestedInput = {
    create?: XOR<chapter_usersCreateWithoutUserInput, chapter_usersUncheckedCreateWithoutUserInput> | chapter_usersCreateWithoutUserInput[] | chapter_usersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chapter_usersCreateOrConnectWithoutUserInput | chapter_usersCreateOrConnectWithoutUserInput[]
    upsert?: chapter_usersUpsertWithWhereUniqueWithoutUserInput | chapter_usersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: chapter_usersCreateManyUserInputEnvelope
    set?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    disconnect?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    delete?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    connect?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    update?: chapter_usersUpdateWithWhereUniqueWithoutUserInput | chapter_usersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: chapter_usersUpdateManyWithWhereWithoutUserInput | chapter_usersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: chapter_usersScalarWhereInput | chapter_usersScalarWhereInput[]
  }

  export type instance_rolesUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<instance_rolesCreateWithoutUsersInput, instance_rolesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: instance_rolesCreateOrConnectWithoutUsersInput
    upsert?: instance_rolesUpsertWithoutUsersInput
    connect?: instance_rolesWhereUniqueInput
    update?: XOR<XOR<instance_rolesUpdateToOneWithWhereWithoutUsersInput, instance_rolesUpdateWithoutUsersInput>, instance_rolesUncheckedUpdateWithoutUsersInput>
  }

  export type event_usersUpdateManyWithoutUserNestedInput = {
    create?: XOR<event_usersCreateWithoutUserInput, event_usersUncheckedCreateWithoutUserInput> | event_usersCreateWithoutUserInput[] | event_usersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: event_usersCreateOrConnectWithoutUserInput | event_usersCreateOrConnectWithoutUserInput[]
    upsert?: event_usersUpsertWithWhereUniqueWithoutUserInput | event_usersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: event_usersCreateManyUserInputEnvelope
    set?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    disconnect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    delete?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    connect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    update?: event_usersUpdateWithWhereUniqueWithoutUserInput | event_usersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: event_usersUpdateManyWithWhereWithoutUserInput | event_usersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: event_usersScalarWhereInput | event_usersScalarWhereInput[]
  }

  export type sessionsUpdateOneWithoutUserNestedInput = {
    create?: XOR<sessionsCreateWithoutUserInput, sessionsUncheckedCreateWithoutUserInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutUserInput
    upsert?: sessionsUpsertWithoutUserInput
    disconnect?: sessionsWhereInput | boolean
    delete?: sessionsWhereInput | boolean
    connect?: sessionsWhereUniqueInput
    update?: XOR<XOR<sessionsUpdateToOneWithWhereWithoutUserInput, sessionsUpdateWithoutUserInput>, sessionsUncheckedUpdateWithoutUserInput>
  }

  export type user_bansUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_bansCreateWithoutUserInput, user_bansUncheckedCreateWithoutUserInput> | user_bansCreateWithoutUserInput[] | user_bansUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_bansCreateOrConnectWithoutUserInput | user_bansCreateOrConnectWithoutUserInput[]
    upsert?: user_bansUpsertWithWhereUniqueWithoutUserInput | user_bansUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_bansCreateManyUserInputEnvelope
    set?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
    disconnect?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
    delete?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
    connect?: user_bansWhereUniqueInput | user_bansWhereUniqueInput[]
    update?: user_bansUpdateWithWhereUniqueWithoutUserInput | user_bansUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_bansUpdateManyWithWhereWithoutUserInput | user_bansUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_bansScalarWhereInput | user_bansScalarWhereInput[]
  }

  export type chapter_usersUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<chapter_usersCreateWithoutUserInput, chapter_usersUncheckedCreateWithoutUserInput> | chapter_usersCreateWithoutUserInput[] | chapter_usersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chapter_usersCreateOrConnectWithoutUserInput | chapter_usersCreateOrConnectWithoutUserInput[]
    upsert?: chapter_usersUpsertWithWhereUniqueWithoutUserInput | chapter_usersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: chapter_usersCreateManyUserInputEnvelope
    set?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    disconnect?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    delete?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    connect?: chapter_usersWhereUniqueInput | chapter_usersWhereUniqueInput[]
    update?: chapter_usersUpdateWithWhereUniqueWithoutUserInput | chapter_usersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: chapter_usersUpdateManyWithWhereWithoutUserInput | chapter_usersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: chapter_usersScalarWhereInput | chapter_usersScalarWhereInput[]
  }

  export type event_usersUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<event_usersCreateWithoutUserInput, event_usersUncheckedCreateWithoutUserInput> | event_usersCreateWithoutUserInput[] | event_usersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: event_usersCreateOrConnectWithoutUserInput | event_usersCreateOrConnectWithoutUserInput[]
    upsert?: event_usersUpsertWithWhereUniqueWithoutUserInput | event_usersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: event_usersCreateManyUserInputEnvelope
    set?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    disconnect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    delete?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    connect?: event_usersWhereUniqueInput | event_usersWhereUniqueInput[]
    update?: event_usersUpdateWithWhereUniqueWithoutUserInput | event_usersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: event_usersUpdateManyWithWhereWithoutUserInput | event_usersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: event_usersScalarWhereInput | event_usersScalarWhereInput[]
  }

  export type sessionsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<sessionsCreateWithoutUserInput, sessionsUncheckedCreateWithoutUserInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutUserInput
    upsert?: sessionsUpsertWithoutUserInput
    disconnect?: sessionsWhereInput | boolean
    delete?: sessionsWhereInput | boolean
    connect?: sessionsWhereUniqueInput
    update?: XOR<XOR<sessionsUpdateToOneWithWhereWithoutUserInput, sessionsUpdateWithoutUserInput>, sessionsUncheckedUpdateWithoutUserInput>
  }

  export type venuesCreateNestedOneWithoutVenue_tagsInput = {
    create?: XOR<venuesCreateWithoutVenue_tagsInput, venuesUncheckedCreateWithoutVenue_tagsInput>
    connectOrCreate?: venuesCreateOrConnectWithoutVenue_tagsInput
    connect?: venuesWhereUniqueInput
  }

  export type tagsCreateNestedOneWithoutVenue_tagsInput = {
    create?: XOR<tagsCreateWithoutVenue_tagsInput, tagsUncheckedCreateWithoutVenue_tagsInput>
    connectOrCreate?: tagsCreateOrConnectWithoutVenue_tagsInput
    connect?: tagsWhereUniqueInput
  }

  export type venuesUpdateOneRequiredWithoutVenue_tagsNestedInput = {
    create?: XOR<venuesCreateWithoutVenue_tagsInput, venuesUncheckedCreateWithoutVenue_tagsInput>
    connectOrCreate?: venuesCreateOrConnectWithoutVenue_tagsInput
    upsert?: venuesUpsertWithoutVenue_tagsInput
    connect?: venuesWhereUniqueInput
    update?: XOR<XOR<venuesUpdateToOneWithWhereWithoutVenue_tagsInput, venuesUpdateWithoutVenue_tagsInput>, venuesUncheckedUpdateWithoutVenue_tagsInput>
  }

  export type tagsUpdateOneRequiredWithoutVenue_tagsNestedInput = {
    create?: XOR<tagsCreateWithoutVenue_tagsInput, tagsUncheckedCreateWithoutVenue_tagsInput>
    connectOrCreate?: tagsCreateOrConnectWithoutVenue_tagsInput
    upsert?: tagsUpsertWithoutVenue_tagsInput
    connect?: tagsWhereUniqueInput
    update?: XOR<XOR<tagsUpdateToOneWithWhereWithoutVenue_tagsInput, tagsUpdateWithoutVenue_tagsInput>, tagsUncheckedUpdateWithoutVenue_tagsInput>
  }

  export type eventsCreateNestedManyWithoutVenueInput = {
    create?: XOR<eventsCreateWithoutVenueInput, eventsUncheckedCreateWithoutVenueInput> | eventsCreateWithoutVenueInput[] | eventsUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: eventsCreateOrConnectWithoutVenueInput | eventsCreateOrConnectWithoutVenueInput[]
    createMany?: eventsCreateManyVenueInputEnvelope
    connect?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
  }

  export type venue_tagsCreateNestedManyWithoutVenueInput = {
    create?: XOR<venue_tagsCreateWithoutVenueInput, venue_tagsUncheckedCreateWithoutVenueInput> | venue_tagsCreateWithoutVenueInput[] | venue_tagsUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: venue_tagsCreateOrConnectWithoutVenueInput | venue_tagsCreateOrConnectWithoutVenueInput[]
    createMany?: venue_tagsCreateManyVenueInputEnvelope
    connect?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
  }

  export type chaptersCreateNestedOneWithoutVenuesInput = {
    create?: XOR<chaptersCreateWithoutVenuesInput, chaptersUncheckedCreateWithoutVenuesInput>
    connectOrCreate?: chaptersCreateOrConnectWithoutVenuesInput
    connect?: chaptersWhereUniqueInput
  }

  export type eventsUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<eventsCreateWithoutVenueInput, eventsUncheckedCreateWithoutVenueInput> | eventsCreateWithoutVenueInput[] | eventsUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: eventsCreateOrConnectWithoutVenueInput | eventsCreateOrConnectWithoutVenueInput[]
    createMany?: eventsCreateManyVenueInputEnvelope
    connect?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
  }

  export type venue_tagsUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<venue_tagsCreateWithoutVenueInput, venue_tagsUncheckedCreateWithoutVenueInput> | venue_tagsCreateWithoutVenueInput[] | venue_tagsUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: venue_tagsCreateOrConnectWithoutVenueInput | venue_tagsCreateOrConnectWithoutVenueInput[]
    createMany?: venue_tagsCreateManyVenueInputEnvelope
    connect?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type eventsUpdateManyWithoutVenueNestedInput = {
    create?: XOR<eventsCreateWithoutVenueInput, eventsUncheckedCreateWithoutVenueInput> | eventsCreateWithoutVenueInput[] | eventsUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: eventsCreateOrConnectWithoutVenueInput | eventsCreateOrConnectWithoutVenueInput[]
    upsert?: eventsUpsertWithWhereUniqueWithoutVenueInput | eventsUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: eventsCreateManyVenueInputEnvelope
    set?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    disconnect?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    delete?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    connect?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    update?: eventsUpdateWithWhereUniqueWithoutVenueInput | eventsUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: eventsUpdateManyWithWhereWithoutVenueInput | eventsUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: eventsScalarWhereInput | eventsScalarWhereInput[]
  }

  export type venue_tagsUpdateManyWithoutVenueNestedInput = {
    create?: XOR<venue_tagsCreateWithoutVenueInput, venue_tagsUncheckedCreateWithoutVenueInput> | venue_tagsCreateWithoutVenueInput[] | venue_tagsUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: venue_tagsCreateOrConnectWithoutVenueInput | venue_tagsCreateOrConnectWithoutVenueInput[]
    upsert?: venue_tagsUpsertWithWhereUniqueWithoutVenueInput | venue_tagsUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: venue_tagsCreateManyVenueInputEnvelope
    set?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
    disconnect?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
    delete?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
    connect?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
    update?: venue_tagsUpdateWithWhereUniqueWithoutVenueInput | venue_tagsUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: venue_tagsUpdateManyWithWhereWithoutVenueInput | venue_tagsUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: venue_tagsScalarWhereInput | venue_tagsScalarWhereInput[]
  }

  export type chaptersUpdateOneRequiredWithoutVenuesNestedInput = {
    create?: XOR<chaptersCreateWithoutVenuesInput, chaptersUncheckedCreateWithoutVenuesInput>
    connectOrCreate?: chaptersCreateOrConnectWithoutVenuesInput
    upsert?: chaptersUpsertWithoutVenuesInput
    connect?: chaptersWhereUniqueInput
    update?: XOR<XOR<chaptersUpdateToOneWithWhereWithoutVenuesInput, chaptersUpdateWithoutVenuesInput>, chaptersUncheckedUpdateWithoutVenuesInput>
  }

  export type eventsUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<eventsCreateWithoutVenueInput, eventsUncheckedCreateWithoutVenueInput> | eventsCreateWithoutVenueInput[] | eventsUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: eventsCreateOrConnectWithoutVenueInput | eventsCreateOrConnectWithoutVenueInput[]
    upsert?: eventsUpsertWithWhereUniqueWithoutVenueInput | eventsUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: eventsCreateManyVenueInputEnvelope
    set?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    disconnect?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    delete?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    connect?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    update?: eventsUpdateWithWhereUniqueWithoutVenueInput | eventsUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: eventsUpdateManyWithWhereWithoutVenueInput | eventsUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: eventsScalarWhereInput | eventsScalarWhereInput[]
  }

  export type venue_tagsUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<venue_tagsCreateWithoutVenueInput, venue_tagsUncheckedCreateWithoutVenueInput> | venue_tagsCreateWithoutVenueInput[] | venue_tagsUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: venue_tagsCreateOrConnectWithoutVenueInput | venue_tagsCreateOrConnectWithoutVenueInput[]
    upsert?: venue_tagsUpsertWithWhereUniqueWithoutVenueInput | venue_tagsUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: venue_tagsCreateManyVenueInputEnvelope
    set?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
    disconnect?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
    delete?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
    connect?: venue_tagsWhereUniqueInput | venue_tagsWhereUniqueInput[]
    update?: venue_tagsUpdateWithWhereUniqueWithoutVenueInput | venue_tagsUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: venue_tagsUpdateManyWithWhereWithoutVenueInput | venue_tagsUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: venue_tagsScalarWhereInput | venue_tagsScalarWhereInput[]
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumevents_venue_type_enumFilter<$PrismaModel = never> = {
    equals?: events_venue_type_enum | Enumevents_venue_type_enumFieldRefInput<$PrismaModel>
    in?: events_venue_type_enum[] | ListEnumevents_venue_type_enumFieldRefInput<$PrismaModel>
    notIn?: events_venue_type_enum[] | ListEnumevents_venue_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumevents_venue_type_enumFilter<$PrismaModel> | events_venue_type_enum
  }

  export type NestedEnumevents_venue_type_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: events_venue_type_enum | Enumevents_venue_type_enumFieldRefInput<$PrismaModel>
    in?: events_venue_type_enum[] | ListEnumevents_venue_type_enumFieldRefInput<$PrismaModel>
    notIn?: events_venue_type_enum[] | ListEnumevents_venue_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumevents_venue_type_enumWithAggregatesFilter<$PrismaModel> | events_venue_type_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumevents_venue_type_enumFilter<$PrismaModel>
    _max?: NestedEnumevents_venue_type_enumFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type eventsCreateWithoutChapterInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    description: string
    url?: string | null
    streaming_url?: string | null
    venue_type?: events_venue_type_enum
    start_at: Date | string
    ends_at: Date | string
    canceled?: boolean
    capacity: number
    invite_only?: boolean
    image_url: string
    calendar_event_id?: string | null
    venue?: venuesCreateNestedOneWithoutEventsInput
    sponsors?: event_sponsorsCreateNestedManyWithoutEventInput
    event_tags?: event_tagsCreateNestedManyWithoutEventInput
    event_users?: event_usersCreateNestedManyWithoutEventInput
  }

  export type eventsUncheckedCreateWithoutChapterInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    description: string
    url?: string | null
    streaming_url?: string | null
    venue_type?: events_venue_type_enum
    start_at: Date | string
    ends_at: Date | string
    canceled?: boolean
    capacity: number
    invite_only?: boolean
    image_url: string
    venue_id?: number | null
    calendar_event_id?: string | null
    sponsors?: event_sponsorsUncheckedCreateNestedManyWithoutEventInput
    event_tags?: event_tagsUncheckedCreateNestedManyWithoutEventInput
    event_users?: event_usersUncheckedCreateNestedManyWithoutEventInput
  }

  export type eventsCreateOrConnectWithoutChapterInput = {
    where: eventsWhereUniqueInput
    create: XOR<eventsCreateWithoutChapterInput, eventsUncheckedCreateWithoutChapterInput>
  }

  export type eventsCreateManyChapterInputEnvelope = {
    data: eventsCreateManyChapterInput | eventsCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type user_bansCreateWithoutChapterInput = {
    created_at?: Date | string
    updated_at?: Date | string
    user: usersCreateNestedOneWithoutUser_bansInput
  }

  export type user_bansUncheckedCreateWithoutChapterInput = {
    created_at?: Date | string
    updated_at?: Date | string
    user_id: number
  }

  export type user_bansCreateOrConnectWithoutChapterInput = {
    where: user_bansWhereUniqueInput
    create: XOR<user_bansCreateWithoutChapterInput, user_bansUncheckedCreateWithoutChapterInput>
  }

  export type user_bansCreateManyChapterInputEnvelope = {
    data: user_bansCreateManyChapterInput | user_bansCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type chapter_usersCreateWithoutChapterInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date: Date | string
    subscribed: boolean
    user: usersCreateNestedOneWithoutUser_chaptersInput
    chapter_role: chapter_rolesCreateNestedOneWithoutChapter_usersInput
  }

  export type chapter_usersUncheckedCreateWithoutChapterInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date: Date | string
    user_id: number
    chapter_role_id: number
    subscribed: boolean
  }

  export type chapter_usersCreateOrConnectWithoutChapterInput = {
    where: chapter_usersWhereUniqueInput
    create: XOR<chapter_usersCreateWithoutChapterInput, chapter_usersUncheckedCreateWithoutChapterInput>
  }

  export type chapter_usersCreateManyChapterInputEnvelope = {
    data: chapter_usersCreateManyChapterInput | chapter_usersCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type chapter_tagsCreateWithoutChapterInput = {
    created_at?: Date | string
    updated_at?: Date | string
    tag: tagsCreateNestedOneWithoutChapter_tagsInput
  }

  export type chapter_tagsUncheckedCreateWithoutChapterInput = {
    created_at?: Date | string
    updated_at?: Date | string
    tag_id: number
  }

  export type chapter_tagsCreateOrConnectWithoutChapterInput = {
    where: chapter_tagsWhereUniqueInput
    create: XOR<chapter_tagsCreateWithoutChapterInput, chapter_tagsUncheckedCreateWithoutChapterInput>
  }

  export type chapter_tagsCreateManyChapterInputEnvelope = {
    data: chapter_tagsCreateManyChapterInput | chapter_tagsCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type venuesCreateWithoutChapterInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    street_address?: string | null
    city: string
    postal_code: string
    region: string
    country: string
    latitude?: number | null
    longitude?: number | null
    events?: eventsCreateNestedManyWithoutVenueInput
    venue_tags?: venue_tagsCreateNestedManyWithoutVenueInput
  }

  export type venuesUncheckedCreateWithoutChapterInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    street_address?: string | null
    city: string
    postal_code: string
    region: string
    country: string
    latitude?: number | null
    longitude?: number | null
    events?: eventsUncheckedCreateNestedManyWithoutVenueInput
    venue_tags?: venue_tagsUncheckedCreateNestedManyWithoutVenueInput
  }

  export type venuesCreateOrConnectWithoutChapterInput = {
    where: venuesWhereUniqueInput
    create: XOR<venuesCreateWithoutChapterInput, venuesUncheckedCreateWithoutChapterInput>
  }

  export type venuesCreateManyChapterInputEnvelope = {
    data: venuesCreateManyChapterInput | venuesCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type eventsUpsertWithWhereUniqueWithoutChapterInput = {
    where: eventsWhereUniqueInput
    update: XOR<eventsUpdateWithoutChapterInput, eventsUncheckedUpdateWithoutChapterInput>
    create: XOR<eventsCreateWithoutChapterInput, eventsUncheckedCreateWithoutChapterInput>
  }

  export type eventsUpdateWithWhereUniqueWithoutChapterInput = {
    where: eventsWhereUniqueInput
    data: XOR<eventsUpdateWithoutChapterInput, eventsUncheckedUpdateWithoutChapterInput>
  }

  export type eventsUpdateManyWithWhereWithoutChapterInput = {
    where: eventsScalarWhereInput
    data: XOR<eventsUpdateManyMutationInput, eventsUncheckedUpdateManyWithoutChapterInput>
  }

  export type eventsScalarWhereInput = {
    AND?: eventsScalarWhereInput | eventsScalarWhereInput[]
    OR?: eventsScalarWhereInput[]
    NOT?: eventsScalarWhereInput | eventsScalarWhereInput[]
    created_at?: DateTimeFilter<"events"> | Date | string
    updated_at?: DateTimeFilter<"events"> | Date | string
    id?: IntFilter<"events"> | number
    name?: StringFilter<"events"> | string
    description?: StringFilter<"events"> | string
    url?: StringNullableFilter<"events"> | string | null
    streaming_url?: StringNullableFilter<"events"> | string | null
    venue_type?: Enumevents_venue_type_enumFilter<"events"> | events_venue_type_enum
    start_at?: DateTimeFilter<"events"> | Date | string
    ends_at?: DateTimeFilter<"events"> | Date | string
    canceled?: BoolFilter<"events"> | boolean
    capacity?: IntFilter<"events"> | number
    invite_only?: BoolFilter<"events"> | boolean
    image_url?: StringFilter<"events"> | string
    venue_id?: IntNullableFilter<"events"> | number | null
    chapter_id?: IntFilter<"events"> | number
    calendar_event_id?: StringNullableFilter<"events"> | string | null
  }

  export type user_bansUpsertWithWhereUniqueWithoutChapterInput = {
    where: user_bansWhereUniqueInput
    update: XOR<user_bansUpdateWithoutChapterInput, user_bansUncheckedUpdateWithoutChapterInput>
    create: XOR<user_bansCreateWithoutChapterInput, user_bansUncheckedCreateWithoutChapterInput>
  }

  export type user_bansUpdateWithWhereUniqueWithoutChapterInput = {
    where: user_bansWhereUniqueInput
    data: XOR<user_bansUpdateWithoutChapterInput, user_bansUncheckedUpdateWithoutChapterInput>
  }

  export type user_bansUpdateManyWithWhereWithoutChapterInput = {
    where: user_bansScalarWhereInput
    data: XOR<user_bansUpdateManyMutationInput, user_bansUncheckedUpdateManyWithoutChapterInput>
  }

  export type user_bansScalarWhereInput = {
    AND?: user_bansScalarWhereInput | user_bansScalarWhereInput[]
    OR?: user_bansScalarWhereInput[]
    NOT?: user_bansScalarWhereInput | user_bansScalarWhereInput[]
    created_at?: DateTimeFilter<"user_bans"> | Date | string
    updated_at?: DateTimeFilter<"user_bans"> | Date | string
    user_id?: IntFilter<"user_bans"> | number
    chapter_id?: IntFilter<"user_bans"> | number
  }

  export type chapter_usersUpsertWithWhereUniqueWithoutChapterInput = {
    where: chapter_usersWhereUniqueInput
    update: XOR<chapter_usersUpdateWithoutChapterInput, chapter_usersUncheckedUpdateWithoutChapterInput>
    create: XOR<chapter_usersCreateWithoutChapterInput, chapter_usersUncheckedCreateWithoutChapterInput>
  }

  export type chapter_usersUpdateWithWhereUniqueWithoutChapterInput = {
    where: chapter_usersWhereUniqueInput
    data: XOR<chapter_usersUpdateWithoutChapterInput, chapter_usersUncheckedUpdateWithoutChapterInput>
  }

  export type chapter_usersUpdateManyWithWhereWithoutChapterInput = {
    where: chapter_usersScalarWhereInput
    data: XOR<chapter_usersUpdateManyMutationInput, chapter_usersUncheckedUpdateManyWithoutChapterInput>
  }

  export type chapter_usersScalarWhereInput = {
    AND?: chapter_usersScalarWhereInput | chapter_usersScalarWhereInput[]
    OR?: chapter_usersScalarWhereInput[]
    NOT?: chapter_usersScalarWhereInput | chapter_usersScalarWhereInput[]
    created_at?: DateTimeFilter<"chapter_users"> | Date | string
    updated_at?: DateTimeFilter<"chapter_users"> | Date | string
    joined_date?: DateTimeFilter<"chapter_users"> | Date | string
    user_id?: IntFilter<"chapter_users"> | number
    chapter_id?: IntFilter<"chapter_users"> | number
    chapter_role_id?: IntFilter<"chapter_users"> | number
    subscribed?: BoolFilter<"chapter_users"> | boolean
  }

  export type chapter_tagsUpsertWithWhereUniqueWithoutChapterInput = {
    where: chapter_tagsWhereUniqueInput
    update: XOR<chapter_tagsUpdateWithoutChapterInput, chapter_tagsUncheckedUpdateWithoutChapterInput>
    create: XOR<chapter_tagsCreateWithoutChapterInput, chapter_tagsUncheckedCreateWithoutChapterInput>
  }

  export type chapter_tagsUpdateWithWhereUniqueWithoutChapterInput = {
    where: chapter_tagsWhereUniqueInput
    data: XOR<chapter_tagsUpdateWithoutChapterInput, chapter_tagsUncheckedUpdateWithoutChapterInput>
  }

  export type chapter_tagsUpdateManyWithWhereWithoutChapterInput = {
    where: chapter_tagsScalarWhereInput
    data: XOR<chapter_tagsUpdateManyMutationInput, chapter_tagsUncheckedUpdateManyWithoutChapterInput>
  }

  export type chapter_tagsScalarWhereInput = {
    AND?: chapter_tagsScalarWhereInput | chapter_tagsScalarWhereInput[]
    OR?: chapter_tagsScalarWhereInput[]
    NOT?: chapter_tagsScalarWhereInput | chapter_tagsScalarWhereInput[]
    created_at?: DateTimeFilter<"chapter_tags"> | Date | string
    updated_at?: DateTimeFilter<"chapter_tags"> | Date | string
    chapter_id?: IntFilter<"chapter_tags"> | number
    tag_id?: IntFilter<"chapter_tags"> | number
  }

  export type venuesUpsertWithWhereUniqueWithoutChapterInput = {
    where: venuesWhereUniqueInput
    update: XOR<venuesUpdateWithoutChapterInput, venuesUncheckedUpdateWithoutChapterInput>
    create: XOR<venuesCreateWithoutChapterInput, venuesUncheckedCreateWithoutChapterInput>
  }

  export type venuesUpdateWithWhereUniqueWithoutChapterInput = {
    where: venuesWhereUniqueInput
    data: XOR<venuesUpdateWithoutChapterInput, venuesUncheckedUpdateWithoutChapterInput>
  }

  export type venuesUpdateManyWithWhereWithoutChapterInput = {
    where: venuesScalarWhereInput
    data: XOR<venuesUpdateManyMutationInput, venuesUncheckedUpdateManyWithoutChapterInput>
  }

  export type venuesScalarWhereInput = {
    AND?: venuesScalarWhereInput | venuesScalarWhereInput[]
    OR?: venuesScalarWhereInput[]
    NOT?: venuesScalarWhereInput | venuesScalarWhereInput[]
    created_at?: DateTimeFilter<"venues"> | Date | string
    updated_at?: DateTimeFilter<"venues"> | Date | string
    id?: IntFilter<"venues"> | number
    name?: StringFilter<"venues"> | string
    street_address?: StringNullableFilter<"venues"> | string | null
    city?: StringFilter<"venues"> | string
    postal_code?: StringFilter<"venues"> | string
    region?: StringFilter<"venues"> | string
    country?: StringFilter<"venues"> | string
    latitude?: FloatNullableFilter<"venues"> | number | null
    longitude?: FloatNullableFilter<"venues"> | number | null
    chapter_id?: IntFilter<"venues"> | number
  }

  export type usersCreateWithoutSessionInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    image_url?: string | null
    email: string
    auto_subscribe?: boolean
    user_bans?: user_bansCreateNestedManyWithoutUserInput
    user_chapters?: chapter_usersCreateNestedManyWithoutUserInput
    instance_role: instance_rolesCreateNestedOneWithoutUsersInput
    user_events?: event_usersCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutSessionInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    image_url?: string | null
    email: string
    auto_subscribe?: boolean
    instance_role_id: number
    user_bans?: user_bansUncheckedCreateNestedManyWithoutUserInput
    user_chapters?: chapter_usersUncheckedCreateNestedManyWithoutUserInput
    user_events?: event_usersUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutSessionInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSessionInput, usersUncheckedCreateWithoutSessionInput>
  }

  export type usersUpsertWithoutSessionInput = {
    update: XOR<usersUpdateWithoutSessionInput, usersUncheckedUpdateWithoutSessionInput>
    create: XOR<usersCreateWithoutSessionInput, usersUncheckedCreateWithoutSessionInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSessionInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSessionInput, usersUncheckedUpdateWithoutSessionInput>
  }

  export type usersUpdateWithoutSessionInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    auto_subscribe?: BoolFieldUpdateOperationsInput | boolean
    user_bans?: user_bansUpdateManyWithoutUserNestedInput
    user_chapters?: chapter_usersUpdateManyWithoutUserNestedInput
    instance_role?: instance_rolesUpdateOneRequiredWithoutUsersNestedInput
    user_events?: event_usersUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutSessionInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    auto_subscribe?: BoolFieldUpdateOperationsInput | boolean
    instance_role_id?: IntFieldUpdateOperationsInput | number
    user_bans?: user_bansUncheckedUpdateManyWithoutUserNestedInput
    user_chapters?: chapter_usersUncheckedUpdateManyWithoutUserNestedInput
    user_events?: event_usersUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutUser_chaptersInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    image_url?: string | null
    email: string
    auto_subscribe?: boolean
    user_bans?: user_bansCreateNestedManyWithoutUserInput
    instance_role: instance_rolesCreateNestedOneWithoutUsersInput
    user_events?: event_usersCreateNestedManyWithoutUserInput
    session?: sessionsCreateNestedOneWithoutUserInput
  }

  export type usersUncheckedCreateWithoutUser_chaptersInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    image_url?: string | null
    email: string
    auto_subscribe?: boolean
    instance_role_id: number
    user_bans?: user_bansUncheckedCreateNestedManyWithoutUserInput
    user_events?: event_usersUncheckedCreateNestedManyWithoutUserInput
    session?: sessionsUncheckedCreateNestedOneWithoutUserInput
  }

  export type usersCreateOrConnectWithoutUser_chaptersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_chaptersInput, usersUncheckedCreateWithoutUser_chaptersInput>
  }

  export type chaptersCreateWithoutChapter_usersInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    description: string
    category: string
    city: string
    region: string
    country: string
    logo_url?: string | null
    banner_url?: string | null
    calendar_id?: string | null
    chat_url?: string | null
    creator_id: number
    events?: eventsCreateNestedManyWithoutChapterInput
    user_bans?: user_bansCreateNestedManyWithoutChapterInput
    chapter_tags?: chapter_tagsCreateNestedManyWithoutChapterInput
    venues?: venuesCreateNestedManyWithoutChapterInput
  }

  export type chaptersUncheckedCreateWithoutChapter_usersInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    description: string
    category: string
    city: string
    region: string
    country: string
    logo_url?: string | null
    banner_url?: string | null
    calendar_id?: string | null
    chat_url?: string | null
    creator_id: number
    events?: eventsUncheckedCreateNestedManyWithoutChapterInput
    user_bans?: user_bansUncheckedCreateNestedManyWithoutChapterInput
    chapter_tags?: chapter_tagsUncheckedCreateNestedManyWithoutChapterInput
    venues?: venuesUncheckedCreateNestedManyWithoutChapterInput
  }

  export type chaptersCreateOrConnectWithoutChapter_usersInput = {
    where: chaptersWhereUniqueInput
    create: XOR<chaptersCreateWithoutChapter_usersInput, chaptersUncheckedCreateWithoutChapter_usersInput>
  }

  export type chapter_rolesCreateWithoutChapter_usersInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    chapter_role_permissions?: chapter_role_permissionsCreateNestedManyWithoutChapter_roleInput
  }

  export type chapter_rolesUncheckedCreateWithoutChapter_usersInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    chapter_role_permissions?: chapter_role_permissionsUncheckedCreateNestedManyWithoutChapter_roleInput
  }

  export type chapter_rolesCreateOrConnectWithoutChapter_usersInput = {
    where: chapter_rolesWhereUniqueInput
    create: XOR<chapter_rolesCreateWithoutChapter_usersInput, chapter_rolesUncheckedCreateWithoutChapter_usersInput>
  }

  export type usersUpsertWithoutUser_chaptersInput = {
    update: XOR<usersUpdateWithoutUser_chaptersInput, usersUncheckedUpdateWithoutUser_chaptersInput>
    create: XOR<usersCreateWithoutUser_chaptersInput, usersUncheckedCreateWithoutUser_chaptersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_chaptersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_chaptersInput, usersUncheckedUpdateWithoutUser_chaptersInput>
  }

  export type usersUpdateWithoutUser_chaptersInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    auto_subscribe?: BoolFieldUpdateOperationsInput | boolean
    user_bans?: user_bansUpdateManyWithoutUserNestedInput
    instance_role?: instance_rolesUpdateOneRequiredWithoutUsersNestedInput
    user_events?: event_usersUpdateManyWithoutUserNestedInput
    session?: sessionsUpdateOneWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_chaptersInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    auto_subscribe?: BoolFieldUpdateOperationsInput | boolean
    instance_role_id?: IntFieldUpdateOperationsInput | number
    user_bans?: user_bansUncheckedUpdateManyWithoutUserNestedInput
    user_events?: event_usersUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type chaptersUpsertWithoutChapter_usersInput = {
    update: XOR<chaptersUpdateWithoutChapter_usersInput, chaptersUncheckedUpdateWithoutChapter_usersInput>
    create: XOR<chaptersCreateWithoutChapter_usersInput, chaptersUncheckedCreateWithoutChapter_usersInput>
    where?: chaptersWhereInput
  }

  export type chaptersUpdateToOneWithWhereWithoutChapter_usersInput = {
    where?: chaptersWhereInput
    data: XOR<chaptersUpdateWithoutChapter_usersInput, chaptersUncheckedUpdateWithoutChapter_usersInput>
  }

  export type chaptersUpdateWithoutChapter_usersInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    calendar_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_url?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    events?: eventsUpdateManyWithoutChapterNestedInput
    user_bans?: user_bansUpdateManyWithoutChapterNestedInput
    chapter_tags?: chapter_tagsUpdateManyWithoutChapterNestedInput
    venues?: venuesUpdateManyWithoutChapterNestedInput
  }

  export type chaptersUncheckedUpdateWithoutChapter_usersInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    calendar_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_url?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    events?: eventsUncheckedUpdateManyWithoutChapterNestedInput
    user_bans?: user_bansUncheckedUpdateManyWithoutChapterNestedInput
    chapter_tags?: chapter_tagsUncheckedUpdateManyWithoutChapterNestedInput
    venues?: venuesUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type chapter_rolesUpsertWithoutChapter_usersInput = {
    update: XOR<chapter_rolesUpdateWithoutChapter_usersInput, chapter_rolesUncheckedUpdateWithoutChapter_usersInput>
    create: XOR<chapter_rolesCreateWithoutChapter_usersInput, chapter_rolesUncheckedCreateWithoutChapter_usersInput>
    where?: chapter_rolesWhereInput
  }

  export type chapter_rolesUpdateToOneWithWhereWithoutChapter_usersInput = {
    where?: chapter_rolesWhereInput
    data: XOR<chapter_rolesUpdateWithoutChapter_usersInput, chapter_rolesUncheckedUpdateWithoutChapter_usersInput>
  }

  export type chapter_rolesUpdateWithoutChapter_usersInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    chapter_role_permissions?: chapter_role_permissionsUpdateManyWithoutChapter_roleNestedInput
  }

  export type chapter_rolesUncheckedUpdateWithoutChapter_usersInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    chapter_role_permissions?: chapter_role_permissionsUncheckedUpdateManyWithoutChapter_roleNestedInput
  }

  export type chapter_usersCreateWithoutChapter_roleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date: Date | string
    subscribed: boolean
    user: usersCreateNestedOneWithoutUser_chaptersInput
    chapter: chaptersCreateNestedOneWithoutChapter_usersInput
  }

  export type chapter_usersUncheckedCreateWithoutChapter_roleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date: Date | string
    user_id: number
    chapter_id: number
    subscribed: boolean
  }

  export type chapter_usersCreateOrConnectWithoutChapter_roleInput = {
    where: chapter_usersWhereUniqueInput
    create: XOR<chapter_usersCreateWithoutChapter_roleInput, chapter_usersUncheckedCreateWithoutChapter_roleInput>
  }

  export type chapter_usersCreateManyChapter_roleInputEnvelope = {
    data: chapter_usersCreateManyChapter_roleInput | chapter_usersCreateManyChapter_roleInput[]
    skipDuplicates?: boolean
  }

  export type chapter_role_permissionsCreateWithoutChapter_roleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter_permission: chapter_permissionsCreateNestedOneWithoutChapter_role_permissionsInput
  }

  export type chapter_role_permissionsUncheckedCreateWithoutChapter_roleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter_permissions_id: number
  }

  export type chapter_role_permissionsCreateOrConnectWithoutChapter_roleInput = {
    where: chapter_role_permissionsWhereUniqueInput
    create: XOR<chapter_role_permissionsCreateWithoutChapter_roleInput, chapter_role_permissionsUncheckedCreateWithoutChapter_roleInput>
  }

  export type chapter_role_permissionsCreateManyChapter_roleInputEnvelope = {
    data: chapter_role_permissionsCreateManyChapter_roleInput | chapter_role_permissionsCreateManyChapter_roleInput[]
    skipDuplicates?: boolean
  }

  export type chapter_usersUpsertWithWhereUniqueWithoutChapter_roleInput = {
    where: chapter_usersWhereUniqueInput
    update: XOR<chapter_usersUpdateWithoutChapter_roleInput, chapter_usersUncheckedUpdateWithoutChapter_roleInput>
    create: XOR<chapter_usersCreateWithoutChapter_roleInput, chapter_usersUncheckedCreateWithoutChapter_roleInput>
  }

  export type chapter_usersUpdateWithWhereUniqueWithoutChapter_roleInput = {
    where: chapter_usersWhereUniqueInput
    data: XOR<chapter_usersUpdateWithoutChapter_roleInput, chapter_usersUncheckedUpdateWithoutChapter_roleInput>
  }

  export type chapter_usersUpdateManyWithWhereWithoutChapter_roleInput = {
    where: chapter_usersScalarWhereInput
    data: XOR<chapter_usersUpdateManyMutationInput, chapter_usersUncheckedUpdateManyWithoutChapter_roleInput>
  }

  export type chapter_role_permissionsUpsertWithWhereUniqueWithoutChapter_roleInput = {
    where: chapter_role_permissionsWhereUniqueInput
    update: XOR<chapter_role_permissionsUpdateWithoutChapter_roleInput, chapter_role_permissionsUncheckedUpdateWithoutChapter_roleInput>
    create: XOR<chapter_role_permissionsCreateWithoutChapter_roleInput, chapter_role_permissionsUncheckedCreateWithoutChapter_roleInput>
  }

  export type chapter_role_permissionsUpdateWithWhereUniqueWithoutChapter_roleInput = {
    where: chapter_role_permissionsWhereUniqueInput
    data: XOR<chapter_role_permissionsUpdateWithoutChapter_roleInput, chapter_role_permissionsUncheckedUpdateWithoutChapter_roleInput>
  }

  export type chapter_role_permissionsUpdateManyWithWhereWithoutChapter_roleInput = {
    where: chapter_role_permissionsScalarWhereInput
    data: XOR<chapter_role_permissionsUpdateManyMutationInput, chapter_role_permissionsUncheckedUpdateManyWithoutChapter_roleInput>
  }

  export type chapter_role_permissionsScalarWhereInput = {
    AND?: chapter_role_permissionsScalarWhereInput | chapter_role_permissionsScalarWhereInput[]
    OR?: chapter_role_permissionsScalarWhereInput[]
    NOT?: chapter_role_permissionsScalarWhereInput | chapter_role_permissionsScalarWhereInput[]
    created_at?: DateTimeFilter<"chapter_role_permissions"> | Date | string
    updated_at?: DateTimeFilter<"chapter_role_permissions"> | Date | string
    chapter_role_id?: IntFilter<"chapter_role_permissions"> | number
    chapter_permissions_id?: IntFilter<"chapter_role_permissions"> | number
  }

  export type chapter_rolesCreateWithoutChapter_role_permissionsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    chapter_users?: chapter_usersCreateNestedManyWithoutChapter_roleInput
  }

  export type chapter_rolesUncheckedCreateWithoutChapter_role_permissionsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    chapter_users?: chapter_usersUncheckedCreateNestedManyWithoutChapter_roleInput
  }

  export type chapter_rolesCreateOrConnectWithoutChapter_role_permissionsInput = {
    where: chapter_rolesWhereUniqueInput
    create: XOR<chapter_rolesCreateWithoutChapter_role_permissionsInput, chapter_rolesUncheckedCreateWithoutChapter_role_permissionsInput>
  }

  export type chapter_permissionsCreateWithoutChapter_role_permissionsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
  }

  export type chapter_permissionsUncheckedCreateWithoutChapter_role_permissionsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
  }

  export type chapter_permissionsCreateOrConnectWithoutChapter_role_permissionsInput = {
    where: chapter_permissionsWhereUniqueInput
    create: XOR<chapter_permissionsCreateWithoutChapter_role_permissionsInput, chapter_permissionsUncheckedCreateWithoutChapter_role_permissionsInput>
  }

  export type chapter_rolesUpsertWithoutChapter_role_permissionsInput = {
    update: XOR<chapter_rolesUpdateWithoutChapter_role_permissionsInput, chapter_rolesUncheckedUpdateWithoutChapter_role_permissionsInput>
    create: XOR<chapter_rolesCreateWithoutChapter_role_permissionsInput, chapter_rolesUncheckedCreateWithoutChapter_role_permissionsInput>
    where?: chapter_rolesWhereInput
  }

  export type chapter_rolesUpdateToOneWithWhereWithoutChapter_role_permissionsInput = {
    where?: chapter_rolesWhereInput
    data: XOR<chapter_rolesUpdateWithoutChapter_role_permissionsInput, chapter_rolesUncheckedUpdateWithoutChapter_role_permissionsInput>
  }

  export type chapter_rolesUpdateWithoutChapter_role_permissionsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    chapter_users?: chapter_usersUpdateManyWithoutChapter_roleNestedInput
  }

  export type chapter_rolesUncheckedUpdateWithoutChapter_role_permissionsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    chapter_users?: chapter_usersUncheckedUpdateManyWithoutChapter_roleNestedInput
  }

  export type chapter_permissionsUpsertWithoutChapter_role_permissionsInput = {
    update: XOR<chapter_permissionsUpdateWithoutChapter_role_permissionsInput, chapter_permissionsUncheckedUpdateWithoutChapter_role_permissionsInput>
    create: XOR<chapter_permissionsCreateWithoutChapter_role_permissionsInput, chapter_permissionsUncheckedCreateWithoutChapter_role_permissionsInput>
    where?: chapter_permissionsWhereInput
  }

  export type chapter_permissionsUpdateToOneWithWhereWithoutChapter_role_permissionsInput = {
    where?: chapter_permissionsWhereInput
    data: XOR<chapter_permissionsUpdateWithoutChapter_role_permissionsInput, chapter_permissionsUncheckedUpdateWithoutChapter_role_permissionsInput>
  }

  export type chapter_permissionsUpdateWithoutChapter_role_permissionsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type chapter_permissionsUncheckedUpdateWithoutChapter_role_permissionsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type chapter_role_permissionsCreateWithoutChapter_permissionInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter_role: chapter_rolesCreateNestedOneWithoutChapter_role_permissionsInput
  }

  export type chapter_role_permissionsUncheckedCreateWithoutChapter_permissionInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter_role_id: number
  }

  export type chapter_role_permissionsCreateOrConnectWithoutChapter_permissionInput = {
    where: chapter_role_permissionsWhereUniqueInput
    create: XOR<chapter_role_permissionsCreateWithoutChapter_permissionInput, chapter_role_permissionsUncheckedCreateWithoutChapter_permissionInput>
  }

  export type chapter_role_permissionsCreateManyChapter_permissionInputEnvelope = {
    data: chapter_role_permissionsCreateManyChapter_permissionInput | chapter_role_permissionsCreateManyChapter_permissionInput[]
    skipDuplicates?: boolean
  }

  export type chapter_role_permissionsUpsertWithWhereUniqueWithoutChapter_permissionInput = {
    where: chapter_role_permissionsWhereUniqueInput
    update: XOR<chapter_role_permissionsUpdateWithoutChapter_permissionInput, chapter_role_permissionsUncheckedUpdateWithoutChapter_permissionInput>
    create: XOR<chapter_role_permissionsCreateWithoutChapter_permissionInput, chapter_role_permissionsUncheckedCreateWithoutChapter_permissionInput>
  }

  export type chapter_role_permissionsUpdateWithWhereUniqueWithoutChapter_permissionInput = {
    where: chapter_role_permissionsWhereUniqueInput
    data: XOR<chapter_role_permissionsUpdateWithoutChapter_permissionInput, chapter_role_permissionsUncheckedUpdateWithoutChapter_permissionInput>
  }

  export type chapter_role_permissionsUpdateManyWithWhereWithoutChapter_permissionInput = {
    where: chapter_role_permissionsScalarWhereInput
    data: XOR<chapter_role_permissionsUpdateManyMutationInput, chapter_role_permissionsUncheckedUpdateManyWithoutChapter_permissionInput>
  }

  export type chaptersCreateWithoutChapter_tagsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    description: string
    category: string
    city: string
    region: string
    country: string
    logo_url?: string | null
    banner_url?: string | null
    calendar_id?: string | null
    chat_url?: string | null
    creator_id: number
    events?: eventsCreateNestedManyWithoutChapterInput
    user_bans?: user_bansCreateNestedManyWithoutChapterInput
    chapter_users?: chapter_usersCreateNestedManyWithoutChapterInput
    venues?: venuesCreateNestedManyWithoutChapterInput
  }

  export type chaptersUncheckedCreateWithoutChapter_tagsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    description: string
    category: string
    city: string
    region: string
    country: string
    logo_url?: string | null
    banner_url?: string | null
    calendar_id?: string | null
    chat_url?: string | null
    creator_id: number
    events?: eventsUncheckedCreateNestedManyWithoutChapterInput
    user_bans?: user_bansUncheckedCreateNestedManyWithoutChapterInput
    chapter_users?: chapter_usersUncheckedCreateNestedManyWithoutChapterInput
    venues?: venuesUncheckedCreateNestedManyWithoutChapterInput
  }

  export type chaptersCreateOrConnectWithoutChapter_tagsInput = {
    where: chaptersWhereUniqueInput
    create: XOR<chaptersCreateWithoutChapter_tagsInput, chaptersUncheckedCreateWithoutChapter_tagsInput>
  }

  export type tagsCreateWithoutChapter_tagsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    event_tags?: event_tagsCreateNestedManyWithoutTagInput
    venue_tags?: venue_tagsCreateNestedManyWithoutTagInput
  }

  export type tagsUncheckedCreateWithoutChapter_tagsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    event_tags?: event_tagsUncheckedCreateNestedManyWithoutTagInput
    venue_tags?: venue_tagsUncheckedCreateNestedManyWithoutTagInput
  }

  export type tagsCreateOrConnectWithoutChapter_tagsInput = {
    where: tagsWhereUniqueInput
    create: XOR<tagsCreateWithoutChapter_tagsInput, tagsUncheckedCreateWithoutChapter_tagsInput>
  }

  export type chaptersUpsertWithoutChapter_tagsInput = {
    update: XOR<chaptersUpdateWithoutChapter_tagsInput, chaptersUncheckedUpdateWithoutChapter_tagsInput>
    create: XOR<chaptersCreateWithoutChapter_tagsInput, chaptersUncheckedCreateWithoutChapter_tagsInput>
    where?: chaptersWhereInput
  }

  export type chaptersUpdateToOneWithWhereWithoutChapter_tagsInput = {
    where?: chaptersWhereInput
    data: XOR<chaptersUpdateWithoutChapter_tagsInput, chaptersUncheckedUpdateWithoutChapter_tagsInput>
  }

  export type chaptersUpdateWithoutChapter_tagsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    calendar_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_url?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    events?: eventsUpdateManyWithoutChapterNestedInput
    user_bans?: user_bansUpdateManyWithoutChapterNestedInput
    chapter_users?: chapter_usersUpdateManyWithoutChapterNestedInput
    venues?: venuesUpdateManyWithoutChapterNestedInput
  }

  export type chaptersUncheckedUpdateWithoutChapter_tagsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    calendar_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_url?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    events?: eventsUncheckedUpdateManyWithoutChapterNestedInput
    user_bans?: user_bansUncheckedUpdateManyWithoutChapterNestedInput
    chapter_users?: chapter_usersUncheckedUpdateManyWithoutChapterNestedInput
    venues?: venuesUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type tagsUpsertWithoutChapter_tagsInput = {
    update: XOR<tagsUpdateWithoutChapter_tagsInput, tagsUncheckedUpdateWithoutChapter_tagsInput>
    create: XOR<tagsCreateWithoutChapter_tagsInput, tagsUncheckedCreateWithoutChapter_tagsInput>
    where?: tagsWhereInput
  }

  export type tagsUpdateToOneWithWhereWithoutChapter_tagsInput = {
    where?: tagsWhereInput
    data: XOR<tagsUpdateWithoutChapter_tagsInput, tagsUncheckedUpdateWithoutChapter_tagsInput>
  }

  export type tagsUpdateWithoutChapter_tagsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    event_tags?: event_tagsUpdateManyWithoutTagNestedInput
    venue_tags?: venue_tagsUpdateManyWithoutTagNestedInput
  }

  export type tagsUncheckedUpdateWithoutChapter_tagsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    event_tags?: event_tagsUncheckedUpdateManyWithoutTagNestedInput
    venue_tags?: venue_tagsUncheckedUpdateManyWithoutTagNestedInput
  }

  export type eventsCreateWithoutSponsorsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    description: string
    url?: string | null
    streaming_url?: string | null
    venue_type?: events_venue_type_enum
    start_at: Date | string
    ends_at: Date | string
    canceled?: boolean
    capacity: number
    invite_only?: boolean
    image_url: string
    calendar_event_id?: string | null
    chapter: chaptersCreateNestedOneWithoutEventsInput
    venue?: venuesCreateNestedOneWithoutEventsInput
    event_tags?: event_tagsCreateNestedManyWithoutEventInput
    event_users?: event_usersCreateNestedManyWithoutEventInput
  }

  export type eventsUncheckedCreateWithoutSponsorsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    description: string
    url?: string | null
    streaming_url?: string | null
    venue_type?: events_venue_type_enum
    start_at: Date | string
    ends_at: Date | string
    canceled?: boolean
    capacity: number
    invite_only?: boolean
    image_url: string
    venue_id?: number | null
    chapter_id: number
    calendar_event_id?: string | null
    event_tags?: event_tagsUncheckedCreateNestedManyWithoutEventInput
    event_users?: event_usersUncheckedCreateNestedManyWithoutEventInput
  }

  export type eventsCreateOrConnectWithoutSponsorsInput = {
    where: eventsWhereUniqueInput
    create: XOR<eventsCreateWithoutSponsorsInput, eventsUncheckedCreateWithoutSponsorsInput>
  }

  export type sponsorsCreateWithoutEvent_sponsorsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    website: string
    logo_path: string
    type: string
  }

  export type sponsorsUncheckedCreateWithoutEvent_sponsorsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    website: string
    logo_path: string
    type: string
  }

  export type sponsorsCreateOrConnectWithoutEvent_sponsorsInput = {
    where: sponsorsWhereUniqueInput
    create: XOR<sponsorsCreateWithoutEvent_sponsorsInput, sponsorsUncheckedCreateWithoutEvent_sponsorsInput>
  }

  export type eventsUpsertWithoutSponsorsInput = {
    update: XOR<eventsUpdateWithoutSponsorsInput, eventsUncheckedUpdateWithoutSponsorsInput>
    create: XOR<eventsCreateWithoutSponsorsInput, eventsUncheckedCreateWithoutSponsorsInput>
    where?: eventsWhereInput
  }

  export type eventsUpdateToOneWithWhereWithoutSponsorsInput = {
    where?: eventsWhereInput
    data: XOR<eventsUpdateWithoutSponsorsInput, eventsUncheckedUpdateWithoutSponsorsInput>
  }

  export type eventsUpdateWithoutSponsorsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    venue_type?: Enumevents_venue_type_enumFieldUpdateOperationsInput | events_venue_type_enum
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    canceled?: BoolFieldUpdateOperationsInput | boolean
    capacity?: IntFieldUpdateOperationsInput | number
    invite_only?: BoolFieldUpdateOperationsInput | boolean
    image_url?: StringFieldUpdateOperationsInput | string
    calendar_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: chaptersUpdateOneRequiredWithoutEventsNestedInput
    venue?: venuesUpdateOneWithoutEventsNestedInput
    event_tags?: event_tagsUpdateManyWithoutEventNestedInput
    event_users?: event_usersUpdateManyWithoutEventNestedInput
  }

  export type eventsUncheckedUpdateWithoutSponsorsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    venue_type?: Enumevents_venue_type_enumFieldUpdateOperationsInput | events_venue_type_enum
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    canceled?: BoolFieldUpdateOperationsInput | boolean
    capacity?: IntFieldUpdateOperationsInput | number
    invite_only?: BoolFieldUpdateOperationsInput | boolean
    image_url?: StringFieldUpdateOperationsInput | string
    venue_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_id?: IntFieldUpdateOperationsInput | number
    calendar_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    event_tags?: event_tagsUncheckedUpdateManyWithoutEventNestedInput
    event_users?: event_usersUncheckedUpdateManyWithoutEventNestedInput
  }

  export type sponsorsUpsertWithoutEvent_sponsorsInput = {
    update: XOR<sponsorsUpdateWithoutEvent_sponsorsInput, sponsorsUncheckedUpdateWithoutEvent_sponsorsInput>
    create: XOR<sponsorsCreateWithoutEvent_sponsorsInput, sponsorsUncheckedCreateWithoutEvent_sponsorsInput>
    where?: sponsorsWhereInput
  }

  export type sponsorsUpdateToOneWithWhereWithoutEvent_sponsorsInput = {
    where?: sponsorsWhereInput
    data: XOR<sponsorsUpdateWithoutEvent_sponsorsInput, sponsorsUncheckedUpdateWithoutEvent_sponsorsInput>
  }

  export type sponsorsUpdateWithoutEvent_sponsorsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    logo_path?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type sponsorsUncheckedUpdateWithoutEvent_sponsorsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    logo_path?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type eventsCreateWithoutEvent_tagsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    description: string
    url?: string | null
    streaming_url?: string | null
    venue_type?: events_venue_type_enum
    start_at: Date | string
    ends_at: Date | string
    canceled?: boolean
    capacity: number
    invite_only?: boolean
    image_url: string
    calendar_event_id?: string | null
    chapter: chaptersCreateNestedOneWithoutEventsInput
    venue?: venuesCreateNestedOneWithoutEventsInput
    sponsors?: event_sponsorsCreateNestedManyWithoutEventInput
    event_users?: event_usersCreateNestedManyWithoutEventInput
  }

  export type eventsUncheckedCreateWithoutEvent_tagsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    description: string
    url?: string | null
    streaming_url?: string | null
    venue_type?: events_venue_type_enum
    start_at: Date | string
    ends_at: Date | string
    canceled?: boolean
    capacity: number
    invite_only?: boolean
    image_url: string
    venue_id?: number | null
    chapter_id: number
    calendar_event_id?: string | null
    sponsors?: event_sponsorsUncheckedCreateNestedManyWithoutEventInput
    event_users?: event_usersUncheckedCreateNestedManyWithoutEventInput
  }

  export type eventsCreateOrConnectWithoutEvent_tagsInput = {
    where: eventsWhereUniqueInput
    create: XOR<eventsCreateWithoutEvent_tagsInput, eventsUncheckedCreateWithoutEvent_tagsInput>
  }

  export type tagsCreateWithoutEvent_tagsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    chapter_tags?: chapter_tagsCreateNestedManyWithoutTagInput
    venue_tags?: venue_tagsCreateNestedManyWithoutTagInput
  }

  export type tagsUncheckedCreateWithoutEvent_tagsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    chapter_tags?: chapter_tagsUncheckedCreateNestedManyWithoutTagInput
    venue_tags?: venue_tagsUncheckedCreateNestedManyWithoutTagInput
  }

  export type tagsCreateOrConnectWithoutEvent_tagsInput = {
    where: tagsWhereUniqueInput
    create: XOR<tagsCreateWithoutEvent_tagsInput, tagsUncheckedCreateWithoutEvent_tagsInput>
  }

  export type eventsUpsertWithoutEvent_tagsInput = {
    update: XOR<eventsUpdateWithoutEvent_tagsInput, eventsUncheckedUpdateWithoutEvent_tagsInput>
    create: XOR<eventsCreateWithoutEvent_tagsInput, eventsUncheckedCreateWithoutEvent_tagsInput>
    where?: eventsWhereInput
  }

  export type eventsUpdateToOneWithWhereWithoutEvent_tagsInput = {
    where?: eventsWhereInput
    data: XOR<eventsUpdateWithoutEvent_tagsInput, eventsUncheckedUpdateWithoutEvent_tagsInput>
  }

  export type eventsUpdateWithoutEvent_tagsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    venue_type?: Enumevents_venue_type_enumFieldUpdateOperationsInput | events_venue_type_enum
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    canceled?: BoolFieldUpdateOperationsInput | boolean
    capacity?: IntFieldUpdateOperationsInput | number
    invite_only?: BoolFieldUpdateOperationsInput | boolean
    image_url?: StringFieldUpdateOperationsInput | string
    calendar_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: chaptersUpdateOneRequiredWithoutEventsNestedInput
    venue?: venuesUpdateOneWithoutEventsNestedInput
    sponsors?: event_sponsorsUpdateManyWithoutEventNestedInput
    event_users?: event_usersUpdateManyWithoutEventNestedInput
  }

  export type eventsUncheckedUpdateWithoutEvent_tagsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    venue_type?: Enumevents_venue_type_enumFieldUpdateOperationsInput | events_venue_type_enum
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    canceled?: BoolFieldUpdateOperationsInput | boolean
    capacity?: IntFieldUpdateOperationsInput | number
    invite_only?: BoolFieldUpdateOperationsInput | boolean
    image_url?: StringFieldUpdateOperationsInput | string
    venue_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_id?: IntFieldUpdateOperationsInput | number
    calendar_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    sponsors?: event_sponsorsUncheckedUpdateManyWithoutEventNestedInput
    event_users?: event_usersUncheckedUpdateManyWithoutEventNestedInput
  }

  export type tagsUpsertWithoutEvent_tagsInput = {
    update: XOR<tagsUpdateWithoutEvent_tagsInput, tagsUncheckedUpdateWithoutEvent_tagsInput>
    create: XOR<tagsCreateWithoutEvent_tagsInput, tagsUncheckedCreateWithoutEvent_tagsInput>
    where?: tagsWhereInput
  }

  export type tagsUpdateToOneWithWhereWithoutEvent_tagsInput = {
    where?: tagsWhereInput
    data: XOR<tagsUpdateWithoutEvent_tagsInput, tagsUncheckedUpdateWithoutEvent_tagsInput>
  }

  export type tagsUpdateWithoutEvent_tagsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    chapter_tags?: chapter_tagsUpdateManyWithoutTagNestedInput
    venue_tags?: venue_tagsUpdateManyWithoutTagNestedInput
  }

  export type tagsUncheckedUpdateWithoutEvent_tagsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    chapter_tags?: chapter_tagsUncheckedUpdateManyWithoutTagNestedInput
    venue_tags?: venue_tagsUncheckedUpdateManyWithoutTagNestedInput
  }

  export type chaptersCreateWithoutEventsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    description: string
    category: string
    city: string
    region: string
    country: string
    logo_url?: string | null
    banner_url?: string | null
    calendar_id?: string | null
    chat_url?: string | null
    creator_id: number
    user_bans?: user_bansCreateNestedManyWithoutChapterInput
    chapter_users?: chapter_usersCreateNestedManyWithoutChapterInput
    chapter_tags?: chapter_tagsCreateNestedManyWithoutChapterInput
    venues?: venuesCreateNestedManyWithoutChapterInput
  }

  export type chaptersUncheckedCreateWithoutEventsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    description: string
    category: string
    city: string
    region: string
    country: string
    logo_url?: string | null
    banner_url?: string | null
    calendar_id?: string | null
    chat_url?: string | null
    creator_id: number
    user_bans?: user_bansUncheckedCreateNestedManyWithoutChapterInput
    chapter_users?: chapter_usersUncheckedCreateNestedManyWithoutChapterInput
    chapter_tags?: chapter_tagsUncheckedCreateNestedManyWithoutChapterInput
    venues?: venuesUncheckedCreateNestedManyWithoutChapterInput
  }

  export type chaptersCreateOrConnectWithoutEventsInput = {
    where: chaptersWhereUniqueInput
    create: XOR<chaptersCreateWithoutEventsInput, chaptersUncheckedCreateWithoutEventsInput>
  }

  export type venuesCreateWithoutEventsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    street_address?: string | null
    city: string
    postal_code: string
    region: string
    country: string
    latitude?: number | null
    longitude?: number | null
    venue_tags?: venue_tagsCreateNestedManyWithoutVenueInput
    chapter: chaptersCreateNestedOneWithoutVenuesInput
  }

  export type venuesUncheckedCreateWithoutEventsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    street_address?: string | null
    city: string
    postal_code: string
    region: string
    country: string
    latitude?: number | null
    longitude?: number | null
    chapter_id: number
    venue_tags?: venue_tagsUncheckedCreateNestedManyWithoutVenueInput
  }

  export type venuesCreateOrConnectWithoutEventsInput = {
    where: venuesWhereUniqueInput
    create: XOR<venuesCreateWithoutEventsInput, venuesUncheckedCreateWithoutEventsInput>
  }

  export type event_sponsorsCreateWithoutEventInput = {
    created_at?: Date | string
    updated_at?: Date | string
    sponsor: sponsorsCreateNestedOneWithoutEvent_sponsorsInput
  }

  export type event_sponsorsUncheckedCreateWithoutEventInput = {
    created_at?: Date | string
    updated_at?: Date | string
    sponsor_id: number
  }

  export type event_sponsorsCreateOrConnectWithoutEventInput = {
    where: event_sponsorsWhereUniqueInput
    create: XOR<event_sponsorsCreateWithoutEventInput, event_sponsorsUncheckedCreateWithoutEventInput>
  }

  export type event_sponsorsCreateManyEventInputEnvelope = {
    data: event_sponsorsCreateManyEventInput | event_sponsorsCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type event_tagsCreateWithoutEventInput = {
    created_at?: Date | string
    updated_at?: Date | string
    tag: tagsCreateNestedOneWithoutEvent_tagsInput
  }

  export type event_tagsUncheckedCreateWithoutEventInput = {
    created_at?: Date | string
    updated_at?: Date | string
    tag_id: number
  }

  export type event_tagsCreateOrConnectWithoutEventInput = {
    where: event_tagsWhereUniqueInput
    create: XOR<event_tagsCreateWithoutEventInput, event_tagsUncheckedCreateWithoutEventInput>
  }

  export type event_tagsCreateManyEventInputEnvelope = {
    data: event_tagsCreateManyEventInput | event_tagsCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type event_usersCreateWithoutEventInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date?: Date | string
    subscribed: boolean
    title?: event_usersCreatetitleInput | string[]
    user: usersCreateNestedOneWithoutUser_eventsInput
    event_role: event_rolesCreateNestedOneWithoutEvent_usersInput
    attendance: attendanceCreateNestedOneWithoutEvent_usersInput
    event_reminder?: event_remindersCreateNestedOneWithoutEvent_userInput
  }

  export type event_usersUncheckedCreateWithoutEventInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date?: Date | string
    user_id: number
    event_role_id: number
    attendance_id: number
    subscribed: boolean
    title?: event_usersCreatetitleInput | string[]
    event_reminder?: event_remindersUncheckedCreateNestedOneWithoutEvent_userInput
  }

  export type event_usersCreateOrConnectWithoutEventInput = {
    where: event_usersWhereUniqueInput
    create: XOR<event_usersCreateWithoutEventInput, event_usersUncheckedCreateWithoutEventInput>
  }

  export type event_usersCreateManyEventInputEnvelope = {
    data: event_usersCreateManyEventInput | event_usersCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type chaptersUpsertWithoutEventsInput = {
    update: XOR<chaptersUpdateWithoutEventsInput, chaptersUncheckedUpdateWithoutEventsInput>
    create: XOR<chaptersCreateWithoutEventsInput, chaptersUncheckedCreateWithoutEventsInput>
    where?: chaptersWhereInput
  }

  export type chaptersUpdateToOneWithWhereWithoutEventsInput = {
    where?: chaptersWhereInput
    data: XOR<chaptersUpdateWithoutEventsInput, chaptersUncheckedUpdateWithoutEventsInput>
  }

  export type chaptersUpdateWithoutEventsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    calendar_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_url?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    user_bans?: user_bansUpdateManyWithoutChapterNestedInput
    chapter_users?: chapter_usersUpdateManyWithoutChapterNestedInput
    chapter_tags?: chapter_tagsUpdateManyWithoutChapterNestedInput
    venues?: venuesUpdateManyWithoutChapterNestedInput
  }

  export type chaptersUncheckedUpdateWithoutEventsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    calendar_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_url?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    user_bans?: user_bansUncheckedUpdateManyWithoutChapterNestedInput
    chapter_users?: chapter_usersUncheckedUpdateManyWithoutChapterNestedInput
    chapter_tags?: chapter_tagsUncheckedUpdateManyWithoutChapterNestedInput
    venues?: venuesUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type venuesUpsertWithoutEventsInput = {
    update: XOR<venuesUpdateWithoutEventsInput, venuesUncheckedUpdateWithoutEventsInput>
    create: XOR<venuesCreateWithoutEventsInput, venuesUncheckedCreateWithoutEventsInput>
    where?: venuesWhereInput
  }

  export type venuesUpdateToOneWithWhereWithoutEventsInput = {
    where?: venuesWhereInput
    data: XOR<venuesUpdateWithoutEventsInput, venuesUncheckedUpdateWithoutEventsInput>
  }

  export type venuesUpdateWithoutEventsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    venue_tags?: venue_tagsUpdateManyWithoutVenueNestedInput
    chapter?: chaptersUpdateOneRequiredWithoutVenuesNestedInput
  }

  export type venuesUncheckedUpdateWithoutEventsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    chapter_id?: IntFieldUpdateOperationsInput | number
    venue_tags?: venue_tagsUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type event_sponsorsUpsertWithWhereUniqueWithoutEventInput = {
    where: event_sponsorsWhereUniqueInput
    update: XOR<event_sponsorsUpdateWithoutEventInput, event_sponsorsUncheckedUpdateWithoutEventInput>
    create: XOR<event_sponsorsCreateWithoutEventInput, event_sponsorsUncheckedCreateWithoutEventInput>
  }

  export type event_sponsorsUpdateWithWhereUniqueWithoutEventInput = {
    where: event_sponsorsWhereUniqueInput
    data: XOR<event_sponsorsUpdateWithoutEventInput, event_sponsorsUncheckedUpdateWithoutEventInput>
  }

  export type event_sponsorsUpdateManyWithWhereWithoutEventInput = {
    where: event_sponsorsScalarWhereInput
    data: XOR<event_sponsorsUpdateManyMutationInput, event_sponsorsUncheckedUpdateManyWithoutEventInput>
  }

  export type event_sponsorsScalarWhereInput = {
    AND?: event_sponsorsScalarWhereInput | event_sponsorsScalarWhereInput[]
    OR?: event_sponsorsScalarWhereInput[]
    NOT?: event_sponsorsScalarWhereInput | event_sponsorsScalarWhereInput[]
    created_at?: DateTimeFilter<"event_sponsors"> | Date | string
    updated_at?: DateTimeFilter<"event_sponsors"> | Date | string
    sponsor_id?: IntFilter<"event_sponsors"> | number
    event_id?: IntFilter<"event_sponsors"> | number
  }

  export type event_tagsUpsertWithWhereUniqueWithoutEventInput = {
    where: event_tagsWhereUniqueInput
    update: XOR<event_tagsUpdateWithoutEventInput, event_tagsUncheckedUpdateWithoutEventInput>
    create: XOR<event_tagsCreateWithoutEventInput, event_tagsUncheckedCreateWithoutEventInput>
  }

  export type event_tagsUpdateWithWhereUniqueWithoutEventInput = {
    where: event_tagsWhereUniqueInput
    data: XOR<event_tagsUpdateWithoutEventInput, event_tagsUncheckedUpdateWithoutEventInput>
  }

  export type event_tagsUpdateManyWithWhereWithoutEventInput = {
    where: event_tagsScalarWhereInput
    data: XOR<event_tagsUpdateManyMutationInput, event_tagsUncheckedUpdateManyWithoutEventInput>
  }

  export type event_tagsScalarWhereInput = {
    AND?: event_tagsScalarWhereInput | event_tagsScalarWhereInput[]
    OR?: event_tagsScalarWhereInput[]
    NOT?: event_tagsScalarWhereInput | event_tagsScalarWhereInput[]
    created_at?: DateTimeFilter<"event_tags"> | Date | string
    updated_at?: DateTimeFilter<"event_tags"> | Date | string
    event_id?: IntFilter<"event_tags"> | number
    tag_id?: IntFilter<"event_tags"> | number
  }

  export type event_usersUpsertWithWhereUniqueWithoutEventInput = {
    where: event_usersWhereUniqueInput
    update: XOR<event_usersUpdateWithoutEventInput, event_usersUncheckedUpdateWithoutEventInput>
    create: XOR<event_usersCreateWithoutEventInput, event_usersUncheckedCreateWithoutEventInput>
  }

  export type event_usersUpdateWithWhereUniqueWithoutEventInput = {
    where: event_usersWhereUniqueInput
    data: XOR<event_usersUpdateWithoutEventInput, event_usersUncheckedUpdateWithoutEventInput>
  }

  export type event_usersUpdateManyWithWhereWithoutEventInput = {
    where: event_usersScalarWhereInput
    data: XOR<event_usersUpdateManyMutationInput, event_usersUncheckedUpdateManyWithoutEventInput>
  }

  export type event_usersScalarWhereInput = {
    AND?: event_usersScalarWhereInput | event_usersScalarWhereInput[]
    OR?: event_usersScalarWhereInput[]
    NOT?: event_usersScalarWhereInput | event_usersScalarWhereInput[]
    created_at?: DateTimeFilter<"event_users"> | Date | string
    updated_at?: DateTimeFilter<"event_users"> | Date | string
    joined_date?: DateTimeFilter<"event_users"> | Date | string
    user_id?: IntFilter<"event_users"> | number
    event_id?: IntFilter<"event_users"> | number
    event_role_id?: IntFilter<"event_users"> | number
    attendance_id?: IntFilter<"event_users"> | number
    subscribed?: BoolFilter<"event_users"> | boolean
    title?: StringNullableListFilter<"event_users">
  }

  export type event_role_permissionsCreateWithoutEvent_roleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event_permission: event_permissionsCreateNestedOneWithoutEvent_role_permissionsInput
  }

  export type event_role_permissionsUncheckedCreateWithoutEvent_roleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event_permission_id: number
  }

  export type event_role_permissionsCreateOrConnectWithoutEvent_roleInput = {
    where: event_role_permissionsWhereUniqueInput
    create: XOR<event_role_permissionsCreateWithoutEvent_roleInput, event_role_permissionsUncheckedCreateWithoutEvent_roleInput>
  }

  export type event_role_permissionsCreateManyEvent_roleInputEnvelope = {
    data: event_role_permissionsCreateManyEvent_roleInput | event_role_permissionsCreateManyEvent_roleInput[]
    skipDuplicates?: boolean
  }

  export type event_usersCreateWithoutEvent_roleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date?: Date | string
    subscribed: boolean
    title?: event_usersCreatetitleInput | string[]
    user: usersCreateNestedOneWithoutUser_eventsInput
    event: eventsCreateNestedOneWithoutEvent_usersInput
    attendance: attendanceCreateNestedOneWithoutEvent_usersInput
    event_reminder?: event_remindersCreateNestedOneWithoutEvent_userInput
  }

  export type event_usersUncheckedCreateWithoutEvent_roleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date?: Date | string
    user_id: number
    event_id: number
    attendance_id: number
    subscribed: boolean
    title?: event_usersCreatetitleInput | string[]
    event_reminder?: event_remindersUncheckedCreateNestedOneWithoutEvent_userInput
  }

  export type event_usersCreateOrConnectWithoutEvent_roleInput = {
    where: event_usersWhereUniqueInput
    create: XOR<event_usersCreateWithoutEvent_roleInput, event_usersUncheckedCreateWithoutEvent_roleInput>
  }

  export type event_usersCreateManyEvent_roleInputEnvelope = {
    data: event_usersCreateManyEvent_roleInput | event_usersCreateManyEvent_roleInput[]
    skipDuplicates?: boolean
  }

  export type event_role_permissionsUpsertWithWhereUniqueWithoutEvent_roleInput = {
    where: event_role_permissionsWhereUniqueInput
    update: XOR<event_role_permissionsUpdateWithoutEvent_roleInput, event_role_permissionsUncheckedUpdateWithoutEvent_roleInput>
    create: XOR<event_role_permissionsCreateWithoutEvent_roleInput, event_role_permissionsUncheckedCreateWithoutEvent_roleInput>
  }

  export type event_role_permissionsUpdateWithWhereUniqueWithoutEvent_roleInput = {
    where: event_role_permissionsWhereUniqueInput
    data: XOR<event_role_permissionsUpdateWithoutEvent_roleInput, event_role_permissionsUncheckedUpdateWithoutEvent_roleInput>
  }

  export type event_role_permissionsUpdateManyWithWhereWithoutEvent_roleInput = {
    where: event_role_permissionsScalarWhereInput
    data: XOR<event_role_permissionsUpdateManyMutationInput, event_role_permissionsUncheckedUpdateManyWithoutEvent_roleInput>
  }

  export type event_role_permissionsScalarWhereInput = {
    AND?: event_role_permissionsScalarWhereInput | event_role_permissionsScalarWhereInput[]
    OR?: event_role_permissionsScalarWhereInput[]
    NOT?: event_role_permissionsScalarWhereInput | event_role_permissionsScalarWhereInput[]
    created_at?: DateTimeFilter<"event_role_permissions"> | Date | string
    updated_at?: DateTimeFilter<"event_role_permissions"> | Date | string
    event_role_id?: IntFilter<"event_role_permissions"> | number
    event_permission_id?: IntFilter<"event_role_permissions"> | number
  }

  export type event_usersUpsertWithWhereUniqueWithoutEvent_roleInput = {
    where: event_usersWhereUniqueInput
    update: XOR<event_usersUpdateWithoutEvent_roleInput, event_usersUncheckedUpdateWithoutEvent_roleInput>
    create: XOR<event_usersCreateWithoutEvent_roleInput, event_usersUncheckedCreateWithoutEvent_roleInput>
  }

  export type event_usersUpdateWithWhereUniqueWithoutEvent_roleInput = {
    where: event_usersWhereUniqueInput
    data: XOR<event_usersUpdateWithoutEvent_roleInput, event_usersUncheckedUpdateWithoutEvent_roleInput>
  }

  export type event_usersUpdateManyWithWhereWithoutEvent_roleInput = {
    where: event_usersScalarWhereInput
    data: XOR<event_usersUpdateManyMutationInput, event_usersUncheckedUpdateManyWithoutEvent_roleInput>
  }

  export type event_rolesCreateWithoutEvent_role_permissionsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    event_users?: event_usersCreateNestedManyWithoutEvent_roleInput
  }

  export type event_rolesUncheckedCreateWithoutEvent_role_permissionsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    event_users?: event_usersUncheckedCreateNestedManyWithoutEvent_roleInput
  }

  export type event_rolesCreateOrConnectWithoutEvent_role_permissionsInput = {
    where: event_rolesWhereUniqueInput
    create: XOR<event_rolesCreateWithoutEvent_role_permissionsInput, event_rolesUncheckedCreateWithoutEvent_role_permissionsInput>
  }

  export type event_permissionsCreateWithoutEvent_role_permissionsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
  }

  export type event_permissionsUncheckedCreateWithoutEvent_role_permissionsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
  }

  export type event_permissionsCreateOrConnectWithoutEvent_role_permissionsInput = {
    where: event_permissionsWhereUniqueInput
    create: XOR<event_permissionsCreateWithoutEvent_role_permissionsInput, event_permissionsUncheckedCreateWithoutEvent_role_permissionsInput>
  }

  export type event_rolesUpsertWithoutEvent_role_permissionsInput = {
    update: XOR<event_rolesUpdateWithoutEvent_role_permissionsInput, event_rolesUncheckedUpdateWithoutEvent_role_permissionsInput>
    create: XOR<event_rolesCreateWithoutEvent_role_permissionsInput, event_rolesUncheckedCreateWithoutEvent_role_permissionsInput>
    where?: event_rolesWhereInput
  }

  export type event_rolesUpdateToOneWithWhereWithoutEvent_role_permissionsInput = {
    where?: event_rolesWhereInput
    data: XOR<event_rolesUpdateWithoutEvent_role_permissionsInput, event_rolesUncheckedUpdateWithoutEvent_role_permissionsInput>
  }

  export type event_rolesUpdateWithoutEvent_role_permissionsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    event_users?: event_usersUpdateManyWithoutEvent_roleNestedInput
  }

  export type event_rolesUncheckedUpdateWithoutEvent_role_permissionsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    event_users?: event_usersUncheckedUpdateManyWithoutEvent_roleNestedInput
  }

  export type event_permissionsUpsertWithoutEvent_role_permissionsInput = {
    update: XOR<event_permissionsUpdateWithoutEvent_role_permissionsInput, event_permissionsUncheckedUpdateWithoutEvent_role_permissionsInput>
    create: XOR<event_permissionsCreateWithoutEvent_role_permissionsInput, event_permissionsUncheckedCreateWithoutEvent_role_permissionsInput>
    where?: event_permissionsWhereInput
  }

  export type event_permissionsUpdateToOneWithWhereWithoutEvent_role_permissionsInput = {
    where?: event_permissionsWhereInput
    data: XOR<event_permissionsUpdateWithoutEvent_role_permissionsInput, event_permissionsUncheckedUpdateWithoutEvent_role_permissionsInput>
  }

  export type event_permissionsUpdateWithoutEvent_role_permissionsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type event_permissionsUncheckedUpdateWithoutEvent_role_permissionsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type event_role_permissionsCreateWithoutEvent_permissionInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event_role: event_rolesCreateNestedOneWithoutEvent_role_permissionsInput
  }

  export type event_role_permissionsUncheckedCreateWithoutEvent_permissionInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event_role_id: number
  }

  export type event_role_permissionsCreateOrConnectWithoutEvent_permissionInput = {
    where: event_role_permissionsWhereUniqueInput
    create: XOR<event_role_permissionsCreateWithoutEvent_permissionInput, event_role_permissionsUncheckedCreateWithoutEvent_permissionInput>
  }

  export type event_role_permissionsCreateManyEvent_permissionInputEnvelope = {
    data: event_role_permissionsCreateManyEvent_permissionInput | event_role_permissionsCreateManyEvent_permissionInput[]
    skipDuplicates?: boolean
  }

  export type event_role_permissionsUpsertWithWhereUniqueWithoutEvent_permissionInput = {
    where: event_role_permissionsWhereUniqueInput
    update: XOR<event_role_permissionsUpdateWithoutEvent_permissionInput, event_role_permissionsUncheckedUpdateWithoutEvent_permissionInput>
    create: XOR<event_role_permissionsCreateWithoutEvent_permissionInput, event_role_permissionsUncheckedCreateWithoutEvent_permissionInput>
  }

  export type event_role_permissionsUpdateWithWhereUniqueWithoutEvent_permissionInput = {
    where: event_role_permissionsWhereUniqueInput
    data: XOR<event_role_permissionsUpdateWithoutEvent_permissionInput, event_role_permissionsUncheckedUpdateWithoutEvent_permissionInput>
  }

  export type event_role_permissionsUpdateManyWithWhereWithoutEvent_permissionInput = {
    where: event_role_permissionsScalarWhereInput
    data: XOR<event_role_permissionsUpdateManyMutationInput, event_role_permissionsUncheckedUpdateManyWithoutEvent_permissionInput>
  }

  export type usersCreateWithoutUser_eventsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    image_url?: string | null
    email: string
    auto_subscribe?: boolean
    user_bans?: user_bansCreateNestedManyWithoutUserInput
    user_chapters?: chapter_usersCreateNestedManyWithoutUserInput
    instance_role: instance_rolesCreateNestedOneWithoutUsersInput
    session?: sessionsCreateNestedOneWithoutUserInput
  }

  export type usersUncheckedCreateWithoutUser_eventsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    image_url?: string | null
    email: string
    auto_subscribe?: boolean
    instance_role_id: number
    user_bans?: user_bansUncheckedCreateNestedManyWithoutUserInput
    user_chapters?: chapter_usersUncheckedCreateNestedManyWithoutUserInput
    session?: sessionsUncheckedCreateNestedOneWithoutUserInput
  }

  export type usersCreateOrConnectWithoutUser_eventsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_eventsInput, usersUncheckedCreateWithoutUser_eventsInput>
  }

  export type eventsCreateWithoutEvent_usersInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    description: string
    url?: string | null
    streaming_url?: string | null
    venue_type?: events_venue_type_enum
    start_at: Date | string
    ends_at: Date | string
    canceled?: boolean
    capacity: number
    invite_only?: boolean
    image_url: string
    calendar_event_id?: string | null
    chapter: chaptersCreateNestedOneWithoutEventsInput
    venue?: venuesCreateNestedOneWithoutEventsInput
    sponsors?: event_sponsorsCreateNestedManyWithoutEventInput
    event_tags?: event_tagsCreateNestedManyWithoutEventInput
  }

  export type eventsUncheckedCreateWithoutEvent_usersInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    description: string
    url?: string | null
    streaming_url?: string | null
    venue_type?: events_venue_type_enum
    start_at: Date | string
    ends_at: Date | string
    canceled?: boolean
    capacity: number
    invite_only?: boolean
    image_url: string
    venue_id?: number | null
    chapter_id: number
    calendar_event_id?: string | null
    sponsors?: event_sponsorsUncheckedCreateNestedManyWithoutEventInput
    event_tags?: event_tagsUncheckedCreateNestedManyWithoutEventInput
  }

  export type eventsCreateOrConnectWithoutEvent_usersInput = {
    where: eventsWhereUniqueInput
    create: XOR<eventsCreateWithoutEvent_usersInput, eventsUncheckedCreateWithoutEvent_usersInput>
  }

  export type event_rolesCreateWithoutEvent_usersInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    event_role_permissions?: event_role_permissionsCreateNestedManyWithoutEvent_roleInput
  }

  export type event_rolesUncheckedCreateWithoutEvent_usersInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    event_role_permissions?: event_role_permissionsUncheckedCreateNestedManyWithoutEvent_roleInput
  }

  export type event_rolesCreateOrConnectWithoutEvent_usersInput = {
    where: event_rolesWhereUniqueInput
    create: XOR<event_rolesCreateWithoutEvent_usersInput, event_rolesUncheckedCreateWithoutEvent_usersInput>
  }

  export type attendanceCreateWithoutEvent_usersInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
  }

  export type attendanceUncheckedCreateWithoutEvent_usersInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
  }

  export type attendanceCreateOrConnectWithoutEvent_usersInput = {
    where: attendanceWhereUniqueInput
    create: XOR<attendanceCreateWithoutEvent_usersInput, attendanceUncheckedCreateWithoutEvent_usersInput>
  }

  export type event_remindersCreateWithoutEvent_userInput = {
    created_at?: Date | string
    updated_at?: Date | string
    remind_at: Date | string
    notifying?: boolean
  }

  export type event_remindersUncheckedCreateWithoutEvent_userInput = {
    created_at?: Date | string
    updated_at?: Date | string
    remind_at: Date | string
    notifying?: boolean
  }

  export type event_remindersCreateOrConnectWithoutEvent_userInput = {
    where: event_remindersWhereUniqueInput
    create: XOR<event_remindersCreateWithoutEvent_userInput, event_remindersUncheckedCreateWithoutEvent_userInput>
  }

  export type usersUpsertWithoutUser_eventsInput = {
    update: XOR<usersUpdateWithoutUser_eventsInput, usersUncheckedUpdateWithoutUser_eventsInput>
    create: XOR<usersCreateWithoutUser_eventsInput, usersUncheckedCreateWithoutUser_eventsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_eventsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_eventsInput, usersUncheckedUpdateWithoutUser_eventsInput>
  }

  export type usersUpdateWithoutUser_eventsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    auto_subscribe?: BoolFieldUpdateOperationsInput | boolean
    user_bans?: user_bansUpdateManyWithoutUserNestedInput
    user_chapters?: chapter_usersUpdateManyWithoutUserNestedInput
    instance_role?: instance_rolesUpdateOneRequiredWithoutUsersNestedInput
    session?: sessionsUpdateOneWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_eventsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    auto_subscribe?: BoolFieldUpdateOperationsInput | boolean
    instance_role_id?: IntFieldUpdateOperationsInput | number
    user_bans?: user_bansUncheckedUpdateManyWithoutUserNestedInput
    user_chapters?: chapter_usersUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type eventsUpsertWithoutEvent_usersInput = {
    update: XOR<eventsUpdateWithoutEvent_usersInput, eventsUncheckedUpdateWithoutEvent_usersInput>
    create: XOR<eventsCreateWithoutEvent_usersInput, eventsUncheckedCreateWithoutEvent_usersInput>
    where?: eventsWhereInput
  }

  export type eventsUpdateToOneWithWhereWithoutEvent_usersInput = {
    where?: eventsWhereInput
    data: XOR<eventsUpdateWithoutEvent_usersInput, eventsUncheckedUpdateWithoutEvent_usersInput>
  }

  export type eventsUpdateWithoutEvent_usersInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    venue_type?: Enumevents_venue_type_enumFieldUpdateOperationsInput | events_venue_type_enum
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    canceled?: BoolFieldUpdateOperationsInput | boolean
    capacity?: IntFieldUpdateOperationsInput | number
    invite_only?: BoolFieldUpdateOperationsInput | boolean
    image_url?: StringFieldUpdateOperationsInput | string
    calendar_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: chaptersUpdateOneRequiredWithoutEventsNestedInput
    venue?: venuesUpdateOneWithoutEventsNestedInput
    sponsors?: event_sponsorsUpdateManyWithoutEventNestedInput
    event_tags?: event_tagsUpdateManyWithoutEventNestedInput
  }

  export type eventsUncheckedUpdateWithoutEvent_usersInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    venue_type?: Enumevents_venue_type_enumFieldUpdateOperationsInput | events_venue_type_enum
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    canceled?: BoolFieldUpdateOperationsInput | boolean
    capacity?: IntFieldUpdateOperationsInput | number
    invite_only?: BoolFieldUpdateOperationsInput | boolean
    image_url?: StringFieldUpdateOperationsInput | string
    venue_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_id?: IntFieldUpdateOperationsInput | number
    calendar_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    sponsors?: event_sponsorsUncheckedUpdateManyWithoutEventNestedInput
    event_tags?: event_tagsUncheckedUpdateManyWithoutEventNestedInput
  }

  export type event_rolesUpsertWithoutEvent_usersInput = {
    update: XOR<event_rolesUpdateWithoutEvent_usersInput, event_rolesUncheckedUpdateWithoutEvent_usersInput>
    create: XOR<event_rolesCreateWithoutEvent_usersInput, event_rolesUncheckedCreateWithoutEvent_usersInput>
    where?: event_rolesWhereInput
  }

  export type event_rolesUpdateToOneWithWhereWithoutEvent_usersInput = {
    where?: event_rolesWhereInput
    data: XOR<event_rolesUpdateWithoutEvent_usersInput, event_rolesUncheckedUpdateWithoutEvent_usersInput>
  }

  export type event_rolesUpdateWithoutEvent_usersInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    event_role_permissions?: event_role_permissionsUpdateManyWithoutEvent_roleNestedInput
  }

  export type event_rolesUncheckedUpdateWithoutEvent_usersInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    event_role_permissions?: event_role_permissionsUncheckedUpdateManyWithoutEvent_roleNestedInput
  }

  export type attendanceUpsertWithoutEvent_usersInput = {
    update: XOR<attendanceUpdateWithoutEvent_usersInput, attendanceUncheckedUpdateWithoutEvent_usersInput>
    create: XOR<attendanceCreateWithoutEvent_usersInput, attendanceUncheckedCreateWithoutEvent_usersInput>
    where?: attendanceWhereInput
  }

  export type attendanceUpdateToOneWithWhereWithoutEvent_usersInput = {
    where?: attendanceWhereInput
    data: XOR<attendanceUpdateWithoutEvent_usersInput, attendanceUncheckedUpdateWithoutEvent_usersInput>
  }

  export type attendanceUpdateWithoutEvent_usersInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type attendanceUncheckedUpdateWithoutEvent_usersInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type event_remindersUpsertWithoutEvent_userInput = {
    update: XOR<event_remindersUpdateWithoutEvent_userInput, event_remindersUncheckedUpdateWithoutEvent_userInput>
    create: XOR<event_remindersCreateWithoutEvent_userInput, event_remindersUncheckedCreateWithoutEvent_userInput>
    where?: event_remindersWhereInput
  }

  export type event_remindersUpdateToOneWithWhereWithoutEvent_userInput = {
    where?: event_remindersWhereInput
    data: XOR<event_remindersUpdateWithoutEvent_userInput, event_remindersUncheckedUpdateWithoutEvent_userInput>
  }

  export type event_remindersUpdateWithoutEvent_userInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    remind_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notifying?: BoolFieldUpdateOperationsInput | boolean
  }

  export type event_remindersUncheckedUpdateWithoutEvent_userInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    remind_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notifying?: BoolFieldUpdateOperationsInput | boolean
  }

  export type event_usersCreateWithoutEvent_reminderInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date?: Date | string
    subscribed: boolean
    title?: event_usersCreatetitleInput | string[]
    user: usersCreateNestedOneWithoutUser_eventsInput
    event: eventsCreateNestedOneWithoutEvent_usersInput
    event_role: event_rolesCreateNestedOneWithoutEvent_usersInput
    attendance: attendanceCreateNestedOneWithoutEvent_usersInput
  }

  export type event_usersUncheckedCreateWithoutEvent_reminderInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date?: Date | string
    user_id: number
    event_id: number
    event_role_id: number
    attendance_id: number
    subscribed: boolean
    title?: event_usersCreatetitleInput | string[]
  }

  export type event_usersCreateOrConnectWithoutEvent_reminderInput = {
    where: event_usersWhereUniqueInput
    create: XOR<event_usersCreateWithoutEvent_reminderInput, event_usersUncheckedCreateWithoutEvent_reminderInput>
  }

  export type event_usersUpsertWithoutEvent_reminderInput = {
    update: XOR<event_usersUpdateWithoutEvent_reminderInput, event_usersUncheckedUpdateWithoutEvent_reminderInput>
    create: XOR<event_usersCreateWithoutEvent_reminderInput, event_usersUncheckedCreateWithoutEvent_reminderInput>
    where?: event_usersWhereInput
  }

  export type event_usersUpdateToOneWithWhereWithoutEvent_reminderInput = {
    where?: event_usersWhereInput
    data: XOR<event_usersUpdateWithoutEvent_reminderInput, event_usersUncheckedUpdateWithoutEvent_reminderInput>
  }

  export type event_usersUpdateWithoutEvent_reminderInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    title?: event_usersUpdatetitleInput | string[]
    user?: usersUpdateOneRequiredWithoutUser_eventsNestedInput
    event?: eventsUpdateOneRequiredWithoutEvent_usersNestedInput
    event_role?: event_rolesUpdateOneRequiredWithoutEvent_usersNestedInput
    attendance?: attendanceUpdateOneRequiredWithoutEvent_usersNestedInput
  }

  export type event_usersUncheckedUpdateWithoutEvent_reminderInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    event_role_id?: IntFieldUpdateOperationsInput | number
    attendance_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    title?: event_usersUpdatetitleInput | string[]
  }

  export type event_usersCreateWithoutAttendanceInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date?: Date | string
    subscribed: boolean
    title?: event_usersCreatetitleInput | string[]
    user: usersCreateNestedOneWithoutUser_eventsInput
    event: eventsCreateNestedOneWithoutEvent_usersInput
    event_role: event_rolesCreateNestedOneWithoutEvent_usersInput
    event_reminder?: event_remindersCreateNestedOneWithoutEvent_userInput
  }

  export type event_usersUncheckedCreateWithoutAttendanceInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date?: Date | string
    user_id: number
    event_id: number
    event_role_id: number
    subscribed: boolean
    title?: event_usersCreatetitleInput | string[]
    event_reminder?: event_remindersUncheckedCreateNestedOneWithoutEvent_userInput
  }

  export type event_usersCreateOrConnectWithoutAttendanceInput = {
    where: event_usersWhereUniqueInput
    create: XOR<event_usersCreateWithoutAttendanceInput, event_usersUncheckedCreateWithoutAttendanceInput>
  }

  export type event_usersCreateManyAttendanceInputEnvelope = {
    data: event_usersCreateManyAttendanceInput | event_usersCreateManyAttendanceInput[]
    skipDuplicates?: boolean
  }

  export type event_usersUpsertWithWhereUniqueWithoutAttendanceInput = {
    where: event_usersWhereUniqueInput
    update: XOR<event_usersUpdateWithoutAttendanceInput, event_usersUncheckedUpdateWithoutAttendanceInput>
    create: XOR<event_usersCreateWithoutAttendanceInput, event_usersUncheckedCreateWithoutAttendanceInput>
  }

  export type event_usersUpdateWithWhereUniqueWithoutAttendanceInput = {
    where: event_usersWhereUniqueInput
    data: XOR<event_usersUpdateWithoutAttendanceInput, event_usersUncheckedUpdateWithoutAttendanceInput>
  }

  export type event_usersUpdateManyWithWhereWithoutAttendanceInput = {
    where: event_usersScalarWhereInput
    data: XOR<event_usersUpdateManyMutationInput, event_usersUncheckedUpdateManyWithoutAttendanceInput>
  }

  export type event_sponsorsCreateWithoutSponsorInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event: eventsCreateNestedOneWithoutSponsorsInput
  }

  export type event_sponsorsUncheckedCreateWithoutSponsorInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event_id: number
  }

  export type event_sponsorsCreateOrConnectWithoutSponsorInput = {
    where: event_sponsorsWhereUniqueInput
    create: XOR<event_sponsorsCreateWithoutSponsorInput, event_sponsorsUncheckedCreateWithoutSponsorInput>
  }

  export type event_sponsorsCreateManySponsorInputEnvelope = {
    data: event_sponsorsCreateManySponsorInput | event_sponsorsCreateManySponsorInput[]
    skipDuplicates?: boolean
  }

  export type event_sponsorsUpsertWithWhereUniqueWithoutSponsorInput = {
    where: event_sponsorsWhereUniqueInput
    update: XOR<event_sponsorsUpdateWithoutSponsorInput, event_sponsorsUncheckedUpdateWithoutSponsorInput>
    create: XOR<event_sponsorsCreateWithoutSponsorInput, event_sponsorsUncheckedCreateWithoutSponsorInput>
  }

  export type event_sponsorsUpdateWithWhereUniqueWithoutSponsorInput = {
    where: event_sponsorsWhereUniqueInput
    data: XOR<event_sponsorsUpdateWithoutSponsorInput, event_sponsorsUncheckedUpdateWithoutSponsorInput>
  }

  export type event_sponsorsUpdateManyWithWhereWithoutSponsorInput = {
    where: event_sponsorsScalarWhereInput
    data: XOR<event_sponsorsUpdateManyMutationInput, event_sponsorsUncheckedUpdateManyWithoutSponsorInput>
  }

  export type chapter_tagsCreateWithoutTagInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter: chaptersCreateNestedOneWithoutChapter_tagsInput
  }

  export type chapter_tagsUncheckedCreateWithoutTagInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter_id: number
  }

  export type chapter_tagsCreateOrConnectWithoutTagInput = {
    where: chapter_tagsWhereUniqueInput
    create: XOR<chapter_tagsCreateWithoutTagInput, chapter_tagsUncheckedCreateWithoutTagInput>
  }

  export type chapter_tagsCreateManyTagInputEnvelope = {
    data: chapter_tagsCreateManyTagInput | chapter_tagsCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type event_tagsCreateWithoutTagInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event: eventsCreateNestedOneWithoutEvent_tagsInput
  }

  export type event_tagsUncheckedCreateWithoutTagInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event_id: number
  }

  export type event_tagsCreateOrConnectWithoutTagInput = {
    where: event_tagsWhereUniqueInput
    create: XOR<event_tagsCreateWithoutTagInput, event_tagsUncheckedCreateWithoutTagInput>
  }

  export type event_tagsCreateManyTagInputEnvelope = {
    data: event_tagsCreateManyTagInput | event_tagsCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type venue_tagsCreateWithoutTagInput = {
    created_at?: Date | string
    updated_at?: Date | string
    venue: venuesCreateNestedOneWithoutVenue_tagsInput
  }

  export type venue_tagsUncheckedCreateWithoutTagInput = {
    created_at?: Date | string
    updated_at?: Date | string
    venue_id: number
  }

  export type venue_tagsCreateOrConnectWithoutTagInput = {
    where: venue_tagsWhereUniqueInput
    create: XOR<venue_tagsCreateWithoutTagInput, venue_tagsUncheckedCreateWithoutTagInput>
  }

  export type venue_tagsCreateManyTagInputEnvelope = {
    data: venue_tagsCreateManyTagInput | venue_tagsCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type chapter_tagsUpsertWithWhereUniqueWithoutTagInput = {
    where: chapter_tagsWhereUniqueInput
    update: XOR<chapter_tagsUpdateWithoutTagInput, chapter_tagsUncheckedUpdateWithoutTagInput>
    create: XOR<chapter_tagsCreateWithoutTagInput, chapter_tagsUncheckedCreateWithoutTagInput>
  }

  export type chapter_tagsUpdateWithWhereUniqueWithoutTagInput = {
    where: chapter_tagsWhereUniqueInput
    data: XOR<chapter_tagsUpdateWithoutTagInput, chapter_tagsUncheckedUpdateWithoutTagInput>
  }

  export type chapter_tagsUpdateManyWithWhereWithoutTagInput = {
    where: chapter_tagsScalarWhereInput
    data: XOR<chapter_tagsUpdateManyMutationInput, chapter_tagsUncheckedUpdateManyWithoutTagInput>
  }

  export type event_tagsUpsertWithWhereUniqueWithoutTagInput = {
    where: event_tagsWhereUniqueInput
    update: XOR<event_tagsUpdateWithoutTagInput, event_tagsUncheckedUpdateWithoutTagInput>
    create: XOR<event_tagsCreateWithoutTagInput, event_tagsUncheckedCreateWithoutTagInput>
  }

  export type event_tagsUpdateWithWhereUniqueWithoutTagInput = {
    where: event_tagsWhereUniqueInput
    data: XOR<event_tagsUpdateWithoutTagInput, event_tagsUncheckedUpdateWithoutTagInput>
  }

  export type event_tagsUpdateManyWithWhereWithoutTagInput = {
    where: event_tagsScalarWhereInput
    data: XOR<event_tagsUpdateManyMutationInput, event_tagsUncheckedUpdateManyWithoutTagInput>
  }

  export type venue_tagsUpsertWithWhereUniqueWithoutTagInput = {
    where: venue_tagsWhereUniqueInput
    update: XOR<venue_tagsUpdateWithoutTagInput, venue_tagsUncheckedUpdateWithoutTagInput>
    create: XOR<venue_tagsCreateWithoutTagInput, venue_tagsUncheckedCreateWithoutTagInput>
  }

  export type venue_tagsUpdateWithWhereUniqueWithoutTagInput = {
    where: venue_tagsWhereUniqueInput
    data: XOR<venue_tagsUpdateWithoutTagInput, venue_tagsUncheckedUpdateWithoutTagInput>
  }

  export type venue_tagsUpdateManyWithWhereWithoutTagInput = {
    where: venue_tagsScalarWhereInput
    data: XOR<venue_tagsUpdateManyMutationInput, venue_tagsUncheckedUpdateManyWithoutTagInput>
  }

  export type venue_tagsScalarWhereInput = {
    AND?: venue_tagsScalarWhereInput | venue_tagsScalarWhereInput[]
    OR?: venue_tagsScalarWhereInput[]
    NOT?: venue_tagsScalarWhereInput | venue_tagsScalarWhereInput[]
    created_at?: DateTimeFilter<"venue_tags"> | Date | string
    updated_at?: DateTimeFilter<"venue_tags"> | Date | string
    venue_id?: IntFilter<"venue_tags"> | number
    tag_id?: IntFilter<"venue_tags"> | number
  }

  export type chaptersCreateWithoutUser_bansInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    description: string
    category: string
    city: string
    region: string
    country: string
    logo_url?: string | null
    banner_url?: string | null
    calendar_id?: string | null
    chat_url?: string | null
    creator_id: number
    events?: eventsCreateNestedManyWithoutChapterInput
    chapter_users?: chapter_usersCreateNestedManyWithoutChapterInput
    chapter_tags?: chapter_tagsCreateNestedManyWithoutChapterInput
    venues?: venuesCreateNestedManyWithoutChapterInput
  }

  export type chaptersUncheckedCreateWithoutUser_bansInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    description: string
    category: string
    city: string
    region: string
    country: string
    logo_url?: string | null
    banner_url?: string | null
    calendar_id?: string | null
    chat_url?: string | null
    creator_id: number
    events?: eventsUncheckedCreateNestedManyWithoutChapterInput
    chapter_users?: chapter_usersUncheckedCreateNestedManyWithoutChapterInput
    chapter_tags?: chapter_tagsUncheckedCreateNestedManyWithoutChapterInput
    venues?: venuesUncheckedCreateNestedManyWithoutChapterInput
  }

  export type chaptersCreateOrConnectWithoutUser_bansInput = {
    where: chaptersWhereUniqueInput
    create: XOR<chaptersCreateWithoutUser_bansInput, chaptersUncheckedCreateWithoutUser_bansInput>
  }

  export type usersCreateWithoutUser_bansInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    image_url?: string | null
    email: string
    auto_subscribe?: boolean
    user_chapters?: chapter_usersCreateNestedManyWithoutUserInput
    instance_role: instance_rolesCreateNestedOneWithoutUsersInput
    user_events?: event_usersCreateNestedManyWithoutUserInput
    session?: sessionsCreateNestedOneWithoutUserInput
  }

  export type usersUncheckedCreateWithoutUser_bansInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    image_url?: string | null
    email: string
    auto_subscribe?: boolean
    instance_role_id: number
    user_chapters?: chapter_usersUncheckedCreateNestedManyWithoutUserInput
    user_events?: event_usersUncheckedCreateNestedManyWithoutUserInput
    session?: sessionsUncheckedCreateNestedOneWithoutUserInput
  }

  export type usersCreateOrConnectWithoutUser_bansInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_bansInput, usersUncheckedCreateWithoutUser_bansInput>
  }

  export type chaptersUpsertWithoutUser_bansInput = {
    update: XOR<chaptersUpdateWithoutUser_bansInput, chaptersUncheckedUpdateWithoutUser_bansInput>
    create: XOR<chaptersCreateWithoutUser_bansInput, chaptersUncheckedCreateWithoutUser_bansInput>
    where?: chaptersWhereInput
  }

  export type chaptersUpdateToOneWithWhereWithoutUser_bansInput = {
    where?: chaptersWhereInput
    data: XOR<chaptersUpdateWithoutUser_bansInput, chaptersUncheckedUpdateWithoutUser_bansInput>
  }

  export type chaptersUpdateWithoutUser_bansInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    calendar_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_url?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    events?: eventsUpdateManyWithoutChapterNestedInput
    chapter_users?: chapter_usersUpdateManyWithoutChapterNestedInput
    chapter_tags?: chapter_tagsUpdateManyWithoutChapterNestedInput
    venues?: venuesUpdateManyWithoutChapterNestedInput
  }

  export type chaptersUncheckedUpdateWithoutUser_bansInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    calendar_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_url?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    events?: eventsUncheckedUpdateManyWithoutChapterNestedInput
    chapter_users?: chapter_usersUncheckedUpdateManyWithoutChapterNestedInput
    chapter_tags?: chapter_tagsUncheckedUpdateManyWithoutChapterNestedInput
    venues?: venuesUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type usersUpsertWithoutUser_bansInput = {
    update: XOR<usersUpdateWithoutUser_bansInput, usersUncheckedUpdateWithoutUser_bansInput>
    create: XOR<usersCreateWithoutUser_bansInput, usersUncheckedCreateWithoutUser_bansInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_bansInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_bansInput, usersUncheckedUpdateWithoutUser_bansInput>
  }

  export type usersUpdateWithoutUser_bansInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    auto_subscribe?: BoolFieldUpdateOperationsInput | boolean
    user_chapters?: chapter_usersUpdateManyWithoutUserNestedInput
    instance_role?: instance_rolesUpdateOneRequiredWithoutUsersNestedInput
    user_events?: event_usersUpdateManyWithoutUserNestedInput
    session?: sessionsUpdateOneWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_bansInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    auto_subscribe?: BoolFieldUpdateOperationsInput | boolean
    instance_role_id?: IntFieldUpdateOperationsInput | number
    user_chapters?: chapter_usersUncheckedUpdateManyWithoutUserNestedInput
    user_events?: event_usersUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type instance_role_permissionsCreateWithoutInstance_permissionInput = {
    created_at?: Date | string
    updated_at?: Date | string
    instance_role: instance_rolesCreateNestedOneWithoutInstance_role_permissionsInput
  }

  export type instance_role_permissionsUncheckedCreateWithoutInstance_permissionInput = {
    created_at?: Date | string
    updated_at?: Date | string
    instance_role_id: number
  }

  export type instance_role_permissionsCreateOrConnectWithoutInstance_permissionInput = {
    where: instance_role_permissionsWhereUniqueInput
    create: XOR<instance_role_permissionsCreateWithoutInstance_permissionInput, instance_role_permissionsUncheckedCreateWithoutInstance_permissionInput>
  }

  export type instance_role_permissionsCreateManyInstance_permissionInputEnvelope = {
    data: instance_role_permissionsCreateManyInstance_permissionInput | instance_role_permissionsCreateManyInstance_permissionInput[]
    skipDuplicates?: boolean
  }

  export type instance_role_permissionsUpsertWithWhereUniqueWithoutInstance_permissionInput = {
    where: instance_role_permissionsWhereUniqueInput
    update: XOR<instance_role_permissionsUpdateWithoutInstance_permissionInput, instance_role_permissionsUncheckedUpdateWithoutInstance_permissionInput>
    create: XOR<instance_role_permissionsCreateWithoutInstance_permissionInput, instance_role_permissionsUncheckedCreateWithoutInstance_permissionInput>
  }

  export type instance_role_permissionsUpdateWithWhereUniqueWithoutInstance_permissionInput = {
    where: instance_role_permissionsWhereUniqueInput
    data: XOR<instance_role_permissionsUpdateWithoutInstance_permissionInput, instance_role_permissionsUncheckedUpdateWithoutInstance_permissionInput>
  }

  export type instance_role_permissionsUpdateManyWithWhereWithoutInstance_permissionInput = {
    where: instance_role_permissionsScalarWhereInput
    data: XOR<instance_role_permissionsUpdateManyMutationInput, instance_role_permissionsUncheckedUpdateManyWithoutInstance_permissionInput>
  }

  export type instance_role_permissionsScalarWhereInput = {
    AND?: instance_role_permissionsScalarWhereInput | instance_role_permissionsScalarWhereInput[]
    OR?: instance_role_permissionsScalarWhereInput[]
    NOT?: instance_role_permissionsScalarWhereInput | instance_role_permissionsScalarWhereInput[]
    created_at?: DateTimeFilter<"instance_role_permissions"> | Date | string
    updated_at?: DateTimeFilter<"instance_role_permissions"> | Date | string
    instance_role_id?: IntFilter<"instance_role_permissions"> | number
    instance_permission_id?: IntFilter<"instance_role_permissions"> | number
  }

  export type instance_rolesCreateWithoutInstance_role_permissionsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    users?: usersCreateNestedManyWithoutInstance_roleInput
  }

  export type instance_rolesUncheckedCreateWithoutInstance_role_permissionsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    users?: usersUncheckedCreateNestedManyWithoutInstance_roleInput
  }

  export type instance_rolesCreateOrConnectWithoutInstance_role_permissionsInput = {
    where: instance_rolesWhereUniqueInput
    create: XOR<instance_rolesCreateWithoutInstance_role_permissionsInput, instance_rolesUncheckedCreateWithoutInstance_role_permissionsInput>
  }

  export type instance_permissionsCreateWithoutInstance_role_permissionsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
  }

  export type instance_permissionsUncheckedCreateWithoutInstance_role_permissionsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
  }

  export type instance_permissionsCreateOrConnectWithoutInstance_role_permissionsInput = {
    where: instance_permissionsWhereUniqueInput
    create: XOR<instance_permissionsCreateWithoutInstance_role_permissionsInput, instance_permissionsUncheckedCreateWithoutInstance_role_permissionsInput>
  }

  export type instance_rolesUpsertWithoutInstance_role_permissionsInput = {
    update: XOR<instance_rolesUpdateWithoutInstance_role_permissionsInput, instance_rolesUncheckedUpdateWithoutInstance_role_permissionsInput>
    create: XOR<instance_rolesCreateWithoutInstance_role_permissionsInput, instance_rolesUncheckedCreateWithoutInstance_role_permissionsInput>
    where?: instance_rolesWhereInput
  }

  export type instance_rolesUpdateToOneWithWhereWithoutInstance_role_permissionsInput = {
    where?: instance_rolesWhereInput
    data: XOR<instance_rolesUpdateWithoutInstance_role_permissionsInput, instance_rolesUncheckedUpdateWithoutInstance_role_permissionsInput>
  }

  export type instance_rolesUpdateWithoutInstance_role_permissionsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateManyWithoutInstance_roleNestedInput
  }

  export type instance_rolesUncheckedUpdateWithoutInstance_role_permissionsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    users?: usersUncheckedUpdateManyWithoutInstance_roleNestedInput
  }

  export type instance_permissionsUpsertWithoutInstance_role_permissionsInput = {
    update: XOR<instance_permissionsUpdateWithoutInstance_role_permissionsInput, instance_permissionsUncheckedUpdateWithoutInstance_role_permissionsInput>
    create: XOR<instance_permissionsCreateWithoutInstance_role_permissionsInput, instance_permissionsUncheckedCreateWithoutInstance_role_permissionsInput>
    where?: instance_permissionsWhereInput
  }

  export type instance_permissionsUpdateToOneWithWhereWithoutInstance_role_permissionsInput = {
    where?: instance_permissionsWhereInput
    data: XOR<instance_permissionsUpdateWithoutInstance_role_permissionsInput, instance_permissionsUncheckedUpdateWithoutInstance_role_permissionsInput>
  }

  export type instance_permissionsUpdateWithoutInstance_role_permissionsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type instance_permissionsUncheckedUpdateWithoutInstance_role_permissionsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type instance_role_permissionsCreateWithoutInstance_roleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    instance_permission: instance_permissionsCreateNestedOneWithoutInstance_role_permissionsInput
  }

  export type instance_role_permissionsUncheckedCreateWithoutInstance_roleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    instance_permission_id: number
  }

  export type instance_role_permissionsCreateOrConnectWithoutInstance_roleInput = {
    where: instance_role_permissionsWhereUniqueInput
    create: XOR<instance_role_permissionsCreateWithoutInstance_roleInput, instance_role_permissionsUncheckedCreateWithoutInstance_roleInput>
  }

  export type instance_role_permissionsCreateManyInstance_roleInputEnvelope = {
    data: instance_role_permissionsCreateManyInstance_roleInput | instance_role_permissionsCreateManyInstance_roleInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutInstance_roleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    image_url?: string | null
    email: string
    auto_subscribe?: boolean
    user_bans?: user_bansCreateNestedManyWithoutUserInput
    user_chapters?: chapter_usersCreateNestedManyWithoutUserInput
    user_events?: event_usersCreateNestedManyWithoutUserInput
    session?: sessionsCreateNestedOneWithoutUserInput
  }

  export type usersUncheckedCreateWithoutInstance_roleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    image_url?: string | null
    email: string
    auto_subscribe?: boolean
    user_bans?: user_bansUncheckedCreateNestedManyWithoutUserInput
    user_chapters?: chapter_usersUncheckedCreateNestedManyWithoutUserInput
    user_events?: event_usersUncheckedCreateNestedManyWithoutUserInput
    session?: sessionsUncheckedCreateNestedOneWithoutUserInput
  }

  export type usersCreateOrConnectWithoutInstance_roleInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutInstance_roleInput, usersUncheckedCreateWithoutInstance_roleInput>
  }

  export type usersCreateManyInstance_roleInputEnvelope = {
    data: usersCreateManyInstance_roleInput | usersCreateManyInstance_roleInput[]
    skipDuplicates?: boolean
  }

  export type instance_role_permissionsUpsertWithWhereUniqueWithoutInstance_roleInput = {
    where: instance_role_permissionsWhereUniqueInput
    update: XOR<instance_role_permissionsUpdateWithoutInstance_roleInput, instance_role_permissionsUncheckedUpdateWithoutInstance_roleInput>
    create: XOR<instance_role_permissionsCreateWithoutInstance_roleInput, instance_role_permissionsUncheckedCreateWithoutInstance_roleInput>
  }

  export type instance_role_permissionsUpdateWithWhereUniqueWithoutInstance_roleInput = {
    where: instance_role_permissionsWhereUniqueInput
    data: XOR<instance_role_permissionsUpdateWithoutInstance_roleInput, instance_role_permissionsUncheckedUpdateWithoutInstance_roleInput>
  }

  export type instance_role_permissionsUpdateManyWithWhereWithoutInstance_roleInput = {
    where: instance_role_permissionsScalarWhereInput
    data: XOR<instance_role_permissionsUpdateManyMutationInput, instance_role_permissionsUncheckedUpdateManyWithoutInstance_roleInput>
  }

  export type usersUpsertWithWhereUniqueWithoutInstance_roleInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutInstance_roleInput, usersUncheckedUpdateWithoutInstance_roleInput>
    create: XOR<usersCreateWithoutInstance_roleInput, usersUncheckedCreateWithoutInstance_roleInput>
  }

  export type usersUpdateWithWhereUniqueWithoutInstance_roleInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutInstance_roleInput, usersUncheckedUpdateWithoutInstance_roleInput>
  }

  export type usersUpdateManyWithWhereWithoutInstance_roleInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutInstance_roleInput>
  }

  export type usersScalarWhereInput = {
    AND?: usersScalarWhereInput | usersScalarWhereInput[]
    OR?: usersScalarWhereInput[]
    NOT?: usersScalarWhereInput | usersScalarWhereInput[]
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    id?: IntFilter<"users"> | number
    name?: StringFilter<"users"> | string
    image_url?: StringNullableFilter<"users"> | string | null
    email?: StringFilter<"users"> | string
    auto_subscribe?: BoolFilter<"users"> | boolean
    instance_role_id?: IntFilter<"users"> | number
  }

  export type user_bansCreateWithoutUserInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter: chaptersCreateNestedOneWithoutUser_bansInput
  }

  export type user_bansUncheckedCreateWithoutUserInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter_id: number
  }

  export type user_bansCreateOrConnectWithoutUserInput = {
    where: user_bansWhereUniqueInput
    create: XOR<user_bansCreateWithoutUserInput, user_bansUncheckedCreateWithoutUserInput>
  }

  export type user_bansCreateManyUserInputEnvelope = {
    data: user_bansCreateManyUserInput | user_bansCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type chapter_usersCreateWithoutUserInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date: Date | string
    subscribed: boolean
    chapter: chaptersCreateNestedOneWithoutChapter_usersInput
    chapter_role: chapter_rolesCreateNestedOneWithoutChapter_usersInput
  }

  export type chapter_usersUncheckedCreateWithoutUserInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date: Date | string
    chapter_id: number
    chapter_role_id: number
    subscribed: boolean
  }

  export type chapter_usersCreateOrConnectWithoutUserInput = {
    where: chapter_usersWhereUniqueInput
    create: XOR<chapter_usersCreateWithoutUserInput, chapter_usersUncheckedCreateWithoutUserInput>
  }

  export type chapter_usersCreateManyUserInputEnvelope = {
    data: chapter_usersCreateManyUserInput | chapter_usersCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type instance_rolesCreateWithoutUsersInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    instance_role_permissions?: instance_role_permissionsCreateNestedManyWithoutInstance_roleInput
  }

  export type instance_rolesUncheckedCreateWithoutUsersInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    instance_role_permissions?: instance_role_permissionsUncheckedCreateNestedManyWithoutInstance_roleInput
  }

  export type instance_rolesCreateOrConnectWithoutUsersInput = {
    where: instance_rolesWhereUniqueInput
    create: XOR<instance_rolesCreateWithoutUsersInput, instance_rolesUncheckedCreateWithoutUsersInput>
  }

  export type event_usersCreateWithoutUserInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date?: Date | string
    subscribed: boolean
    title?: event_usersCreatetitleInput | string[]
    event: eventsCreateNestedOneWithoutEvent_usersInput
    event_role: event_rolesCreateNestedOneWithoutEvent_usersInput
    attendance: attendanceCreateNestedOneWithoutEvent_usersInput
    event_reminder?: event_remindersCreateNestedOneWithoutEvent_userInput
  }

  export type event_usersUncheckedCreateWithoutUserInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date?: Date | string
    event_id: number
    event_role_id: number
    attendance_id: number
    subscribed: boolean
    title?: event_usersCreatetitleInput | string[]
    event_reminder?: event_remindersUncheckedCreateNestedOneWithoutEvent_userInput
  }

  export type event_usersCreateOrConnectWithoutUserInput = {
    where: event_usersWhereUniqueInput
    create: XOR<event_usersCreateWithoutUserInput, event_usersUncheckedCreateWithoutUserInput>
  }

  export type event_usersCreateManyUserInputEnvelope = {
    data: event_usersCreateManyUserInput | event_usersCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type sessionsCreateWithoutUserInput = {

  }

  export type sessionsUncheckedCreateWithoutUserInput = {
    id?: number
  }

  export type sessionsCreateOrConnectWithoutUserInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutUserInput, sessionsUncheckedCreateWithoutUserInput>
  }

  export type user_bansUpsertWithWhereUniqueWithoutUserInput = {
    where: user_bansWhereUniqueInput
    update: XOR<user_bansUpdateWithoutUserInput, user_bansUncheckedUpdateWithoutUserInput>
    create: XOR<user_bansCreateWithoutUserInput, user_bansUncheckedCreateWithoutUserInput>
  }

  export type user_bansUpdateWithWhereUniqueWithoutUserInput = {
    where: user_bansWhereUniqueInput
    data: XOR<user_bansUpdateWithoutUserInput, user_bansUncheckedUpdateWithoutUserInput>
  }

  export type user_bansUpdateManyWithWhereWithoutUserInput = {
    where: user_bansScalarWhereInput
    data: XOR<user_bansUpdateManyMutationInput, user_bansUncheckedUpdateManyWithoutUserInput>
  }

  export type chapter_usersUpsertWithWhereUniqueWithoutUserInput = {
    where: chapter_usersWhereUniqueInput
    update: XOR<chapter_usersUpdateWithoutUserInput, chapter_usersUncheckedUpdateWithoutUserInput>
    create: XOR<chapter_usersCreateWithoutUserInput, chapter_usersUncheckedCreateWithoutUserInput>
  }

  export type chapter_usersUpdateWithWhereUniqueWithoutUserInput = {
    where: chapter_usersWhereUniqueInput
    data: XOR<chapter_usersUpdateWithoutUserInput, chapter_usersUncheckedUpdateWithoutUserInput>
  }

  export type chapter_usersUpdateManyWithWhereWithoutUserInput = {
    where: chapter_usersScalarWhereInput
    data: XOR<chapter_usersUpdateManyMutationInput, chapter_usersUncheckedUpdateManyWithoutUserInput>
  }

  export type instance_rolesUpsertWithoutUsersInput = {
    update: XOR<instance_rolesUpdateWithoutUsersInput, instance_rolesUncheckedUpdateWithoutUsersInput>
    create: XOR<instance_rolesCreateWithoutUsersInput, instance_rolesUncheckedCreateWithoutUsersInput>
    where?: instance_rolesWhereInput
  }

  export type instance_rolesUpdateToOneWithWhereWithoutUsersInput = {
    where?: instance_rolesWhereInput
    data: XOR<instance_rolesUpdateWithoutUsersInput, instance_rolesUncheckedUpdateWithoutUsersInput>
  }

  export type instance_rolesUpdateWithoutUsersInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    instance_role_permissions?: instance_role_permissionsUpdateManyWithoutInstance_roleNestedInput
  }

  export type instance_rolesUncheckedUpdateWithoutUsersInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    instance_role_permissions?: instance_role_permissionsUncheckedUpdateManyWithoutInstance_roleNestedInput
  }

  export type event_usersUpsertWithWhereUniqueWithoutUserInput = {
    where: event_usersWhereUniqueInput
    update: XOR<event_usersUpdateWithoutUserInput, event_usersUncheckedUpdateWithoutUserInput>
    create: XOR<event_usersCreateWithoutUserInput, event_usersUncheckedCreateWithoutUserInput>
  }

  export type event_usersUpdateWithWhereUniqueWithoutUserInput = {
    where: event_usersWhereUniqueInput
    data: XOR<event_usersUpdateWithoutUserInput, event_usersUncheckedUpdateWithoutUserInput>
  }

  export type event_usersUpdateManyWithWhereWithoutUserInput = {
    where: event_usersScalarWhereInput
    data: XOR<event_usersUpdateManyMutationInput, event_usersUncheckedUpdateManyWithoutUserInput>
  }

  export type sessionsUpsertWithoutUserInput = {
    update: XOR<sessionsUpdateWithoutUserInput, sessionsUncheckedUpdateWithoutUserInput>
    create: XOR<sessionsCreateWithoutUserInput, sessionsUncheckedCreateWithoutUserInput>
    where?: sessionsWhereInput
  }

  export type sessionsUpdateToOneWithWhereWithoutUserInput = {
    where?: sessionsWhereInput
    data: XOR<sessionsUpdateWithoutUserInput, sessionsUncheckedUpdateWithoutUserInput>
  }

  export type sessionsUpdateWithoutUserInput = {

  }

  export type sessionsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type venuesCreateWithoutVenue_tagsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    street_address?: string | null
    city: string
    postal_code: string
    region: string
    country: string
    latitude?: number | null
    longitude?: number | null
    events?: eventsCreateNestedManyWithoutVenueInput
    chapter: chaptersCreateNestedOneWithoutVenuesInput
  }

  export type venuesUncheckedCreateWithoutVenue_tagsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    street_address?: string | null
    city: string
    postal_code: string
    region: string
    country: string
    latitude?: number | null
    longitude?: number | null
    chapter_id: number
    events?: eventsUncheckedCreateNestedManyWithoutVenueInput
  }

  export type venuesCreateOrConnectWithoutVenue_tagsInput = {
    where: venuesWhereUniqueInput
    create: XOR<venuesCreateWithoutVenue_tagsInput, venuesUncheckedCreateWithoutVenue_tagsInput>
  }

  export type tagsCreateWithoutVenue_tagsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    chapter_tags?: chapter_tagsCreateNestedManyWithoutTagInput
    event_tags?: event_tagsCreateNestedManyWithoutTagInput
  }

  export type tagsUncheckedCreateWithoutVenue_tagsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    chapter_tags?: chapter_tagsUncheckedCreateNestedManyWithoutTagInput
    event_tags?: event_tagsUncheckedCreateNestedManyWithoutTagInput
  }

  export type tagsCreateOrConnectWithoutVenue_tagsInput = {
    where: tagsWhereUniqueInput
    create: XOR<tagsCreateWithoutVenue_tagsInput, tagsUncheckedCreateWithoutVenue_tagsInput>
  }

  export type venuesUpsertWithoutVenue_tagsInput = {
    update: XOR<venuesUpdateWithoutVenue_tagsInput, venuesUncheckedUpdateWithoutVenue_tagsInput>
    create: XOR<venuesCreateWithoutVenue_tagsInput, venuesUncheckedCreateWithoutVenue_tagsInput>
    where?: venuesWhereInput
  }

  export type venuesUpdateToOneWithWhereWithoutVenue_tagsInput = {
    where?: venuesWhereInput
    data: XOR<venuesUpdateWithoutVenue_tagsInput, venuesUncheckedUpdateWithoutVenue_tagsInput>
  }

  export type venuesUpdateWithoutVenue_tagsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    events?: eventsUpdateManyWithoutVenueNestedInput
    chapter?: chaptersUpdateOneRequiredWithoutVenuesNestedInput
  }

  export type venuesUncheckedUpdateWithoutVenue_tagsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    chapter_id?: IntFieldUpdateOperationsInput | number
    events?: eventsUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type tagsUpsertWithoutVenue_tagsInput = {
    update: XOR<tagsUpdateWithoutVenue_tagsInput, tagsUncheckedUpdateWithoutVenue_tagsInput>
    create: XOR<tagsCreateWithoutVenue_tagsInput, tagsUncheckedCreateWithoutVenue_tagsInput>
    where?: tagsWhereInput
  }

  export type tagsUpdateToOneWithWhereWithoutVenue_tagsInput = {
    where?: tagsWhereInput
    data: XOR<tagsUpdateWithoutVenue_tagsInput, tagsUncheckedUpdateWithoutVenue_tagsInput>
  }

  export type tagsUpdateWithoutVenue_tagsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    chapter_tags?: chapter_tagsUpdateManyWithoutTagNestedInput
    event_tags?: event_tagsUpdateManyWithoutTagNestedInput
  }

  export type tagsUncheckedUpdateWithoutVenue_tagsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    chapter_tags?: chapter_tagsUncheckedUpdateManyWithoutTagNestedInput
    event_tags?: event_tagsUncheckedUpdateManyWithoutTagNestedInput
  }

  export type eventsCreateWithoutVenueInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    description: string
    url?: string | null
    streaming_url?: string | null
    venue_type?: events_venue_type_enum
    start_at: Date | string
    ends_at: Date | string
    canceled?: boolean
    capacity: number
    invite_only?: boolean
    image_url: string
    calendar_event_id?: string | null
    chapter: chaptersCreateNestedOneWithoutEventsInput
    sponsors?: event_sponsorsCreateNestedManyWithoutEventInput
    event_tags?: event_tagsCreateNestedManyWithoutEventInput
    event_users?: event_usersCreateNestedManyWithoutEventInput
  }

  export type eventsUncheckedCreateWithoutVenueInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    description: string
    url?: string | null
    streaming_url?: string | null
    venue_type?: events_venue_type_enum
    start_at: Date | string
    ends_at: Date | string
    canceled?: boolean
    capacity: number
    invite_only?: boolean
    image_url: string
    chapter_id: number
    calendar_event_id?: string | null
    sponsors?: event_sponsorsUncheckedCreateNestedManyWithoutEventInput
    event_tags?: event_tagsUncheckedCreateNestedManyWithoutEventInput
    event_users?: event_usersUncheckedCreateNestedManyWithoutEventInput
  }

  export type eventsCreateOrConnectWithoutVenueInput = {
    where: eventsWhereUniqueInput
    create: XOR<eventsCreateWithoutVenueInput, eventsUncheckedCreateWithoutVenueInput>
  }

  export type eventsCreateManyVenueInputEnvelope = {
    data: eventsCreateManyVenueInput | eventsCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type venue_tagsCreateWithoutVenueInput = {
    created_at?: Date | string
    updated_at?: Date | string
    tag: tagsCreateNestedOneWithoutVenue_tagsInput
  }

  export type venue_tagsUncheckedCreateWithoutVenueInput = {
    created_at?: Date | string
    updated_at?: Date | string
    tag_id: number
  }

  export type venue_tagsCreateOrConnectWithoutVenueInput = {
    where: venue_tagsWhereUniqueInput
    create: XOR<venue_tagsCreateWithoutVenueInput, venue_tagsUncheckedCreateWithoutVenueInput>
  }

  export type venue_tagsCreateManyVenueInputEnvelope = {
    data: venue_tagsCreateManyVenueInput | venue_tagsCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type chaptersCreateWithoutVenuesInput = {
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    description: string
    category: string
    city: string
    region: string
    country: string
    logo_url?: string | null
    banner_url?: string | null
    calendar_id?: string | null
    chat_url?: string | null
    creator_id: number
    events?: eventsCreateNestedManyWithoutChapterInput
    user_bans?: user_bansCreateNestedManyWithoutChapterInput
    chapter_users?: chapter_usersCreateNestedManyWithoutChapterInput
    chapter_tags?: chapter_tagsCreateNestedManyWithoutChapterInput
  }

  export type chaptersUncheckedCreateWithoutVenuesInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    description: string
    category: string
    city: string
    region: string
    country: string
    logo_url?: string | null
    banner_url?: string | null
    calendar_id?: string | null
    chat_url?: string | null
    creator_id: number
    events?: eventsUncheckedCreateNestedManyWithoutChapterInput
    user_bans?: user_bansUncheckedCreateNestedManyWithoutChapterInput
    chapter_users?: chapter_usersUncheckedCreateNestedManyWithoutChapterInput
    chapter_tags?: chapter_tagsUncheckedCreateNestedManyWithoutChapterInput
  }

  export type chaptersCreateOrConnectWithoutVenuesInput = {
    where: chaptersWhereUniqueInput
    create: XOR<chaptersCreateWithoutVenuesInput, chaptersUncheckedCreateWithoutVenuesInput>
  }

  export type eventsUpsertWithWhereUniqueWithoutVenueInput = {
    where: eventsWhereUniqueInput
    update: XOR<eventsUpdateWithoutVenueInput, eventsUncheckedUpdateWithoutVenueInput>
    create: XOR<eventsCreateWithoutVenueInput, eventsUncheckedCreateWithoutVenueInput>
  }

  export type eventsUpdateWithWhereUniqueWithoutVenueInput = {
    where: eventsWhereUniqueInput
    data: XOR<eventsUpdateWithoutVenueInput, eventsUncheckedUpdateWithoutVenueInput>
  }

  export type eventsUpdateManyWithWhereWithoutVenueInput = {
    where: eventsScalarWhereInput
    data: XOR<eventsUpdateManyMutationInput, eventsUncheckedUpdateManyWithoutVenueInput>
  }

  export type venue_tagsUpsertWithWhereUniqueWithoutVenueInput = {
    where: venue_tagsWhereUniqueInput
    update: XOR<venue_tagsUpdateWithoutVenueInput, venue_tagsUncheckedUpdateWithoutVenueInput>
    create: XOR<venue_tagsCreateWithoutVenueInput, venue_tagsUncheckedCreateWithoutVenueInput>
  }

  export type venue_tagsUpdateWithWhereUniqueWithoutVenueInput = {
    where: venue_tagsWhereUniqueInput
    data: XOR<venue_tagsUpdateWithoutVenueInput, venue_tagsUncheckedUpdateWithoutVenueInput>
  }

  export type venue_tagsUpdateManyWithWhereWithoutVenueInput = {
    where: venue_tagsScalarWhereInput
    data: XOR<venue_tagsUpdateManyMutationInput, venue_tagsUncheckedUpdateManyWithoutVenueInput>
  }

  export type chaptersUpsertWithoutVenuesInput = {
    update: XOR<chaptersUpdateWithoutVenuesInput, chaptersUncheckedUpdateWithoutVenuesInput>
    create: XOR<chaptersCreateWithoutVenuesInput, chaptersUncheckedCreateWithoutVenuesInput>
    where?: chaptersWhereInput
  }

  export type chaptersUpdateToOneWithWhereWithoutVenuesInput = {
    where?: chaptersWhereInput
    data: XOR<chaptersUpdateWithoutVenuesInput, chaptersUncheckedUpdateWithoutVenuesInput>
  }

  export type chaptersUpdateWithoutVenuesInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    calendar_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_url?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    events?: eventsUpdateManyWithoutChapterNestedInput
    user_bans?: user_bansUpdateManyWithoutChapterNestedInput
    chapter_users?: chapter_usersUpdateManyWithoutChapterNestedInput
    chapter_tags?: chapter_tagsUpdateManyWithoutChapterNestedInput
  }

  export type chaptersUncheckedUpdateWithoutVenuesInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    calendar_id?: NullableStringFieldUpdateOperationsInput | string | null
    chat_url?: NullableStringFieldUpdateOperationsInput | string | null
    creator_id?: IntFieldUpdateOperationsInput | number
    events?: eventsUncheckedUpdateManyWithoutChapterNestedInput
    user_bans?: user_bansUncheckedUpdateManyWithoutChapterNestedInput
    chapter_users?: chapter_usersUncheckedUpdateManyWithoutChapterNestedInput
    chapter_tags?: chapter_tagsUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type eventsCreateManyChapterInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    description: string
    url?: string | null
    streaming_url?: string | null
    venue_type?: events_venue_type_enum
    start_at: Date | string
    ends_at: Date | string
    canceled?: boolean
    capacity: number
    invite_only?: boolean
    image_url: string
    venue_id?: number | null
    calendar_event_id?: string | null
  }

  export type user_bansCreateManyChapterInput = {
    created_at?: Date | string
    updated_at?: Date | string
    user_id: number
  }

  export type chapter_usersCreateManyChapterInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date: Date | string
    user_id: number
    chapter_role_id: number
    subscribed: boolean
  }

  export type chapter_tagsCreateManyChapterInput = {
    created_at?: Date | string
    updated_at?: Date | string
    tag_id: number
  }

  export type venuesCreateManyChapterInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    street_address?: string | null
    city: string
    postal_code: string
    region: string
    country: string
    latitude?: number | null
    longitude?: number | null
  }

  export type eventsUpdateWithoutChapterInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    venue_type?: Enumevents_venue_type_enumFieldUpdateOperationsInput | events_venue_type_enum
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    canceled?: BoolFieldUpdateOperationsInput | boolean
    capacity?: IntFieldUpdateOperationsInput | number
    invite_only?: BoolFieldUpdateOperationsInput | boolean
    image_url?: StringFieldUpdateOperationsInput | string
    calendar_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: venuesUpdateOneWithoutEventsNestedInput
    sponsors?: event_sponsorsUpdateManyWithoutEventNestedInput
    event_tags?: event_tagsUpdateManyWithoutEventNestedInput
    event_users?: event_usersUpdateManyWithoutEventNestedInput
  }

  export type eventsUncheckedUpdateWithoutChapterInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    venue_type?: Enumevents_venue_type_enumFieldUpdateOperationsInput | events_venue_type_enum
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    canceled?: BoolFieldUpdateOperationsInput | boolean
    capacity?: IntFieldUpdateOperationsInput | number
    invite_only?: BoolFieldUpdateOperationsInput | boolean
    image_url?: StringFieldUpdateOperationsInput | string
    venue_id?: NullableIntFieldUpdateOperationsInput | number | null
    calendar_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    sponsors?: event_sponsorsUncheckedUpdateManyWithoutEventNestedInput
    event_tags?: event_tagsUncheckedUpdateManyWithoutEventNestedInput
    event_users?: event_usersUncheckedUpdateManyWithoutEventNestedInput
  }

  export type eventsUncheckedUpdateManyWithoutChapterInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    venue_type?: Enumevents_venue_type_enumFieldUpdateOperationsInput | events_venue_type_enum
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    canceled?: BoolFieldUpdateOperationsInput | boolean
    capacity?: IntFieldUpdateOperationsInput | number
    invite_only?: BoolFieldUpdateOperationsInput | boolean
    image_url?: StringFieldUpdateOperationsInput | string
    venue_id?: NullableIntFieldUpdateOperationsInput | number | null
    calendar_event_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_bansUpdateWithoutChapterInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutUser_bansNestedInput
  }

  export type user_bansUncheckedUpdateWithoutChapterInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_bansUncheckedUpdateManyWithoutChapterInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type chapter_usersUpdateWithoutChapterInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    user?: usersUpdateOneRequiredWithoutUser_chaptersNestedInput
    chapter_role?: chapter_rolesUpdateOneRequiredWithoutChapter_usersNestedInput
  }

  export type chapter_usersUncheckedUpdateWithoutChapterInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    chapter_role_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chapter_usersUncheckedUpdateManyWithoutChapterInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    chapter_role_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chapter_tagsUpdateWithoutChapterInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: tagsUpdateOneRequiredWithoutChapter_tagsNestedInput
  }

  export type chapter_tagsUncheckedUpdateWithoutChapterInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type chapter_tagsUncheckedUpdateManyWithoutChapterInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type venuesUpdateWithoutChapterInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    events?: eventsUpdateManyWithoutVenueNestedInput
    venue_tags?: venue_tagsUpdateManyWithoutVenueNestedInput
  }

  export type venuesUncheckedUpdateWithoutChapterInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    events?: eventsUncheckedUpdateManyWithoutVenueNestedInput
    venue_tags?: venue_tagsUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type venuesUncheckedUpdateManyWithoutChapterInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    street_address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type chapter_usersCreateManyChapter_roleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date: Date | string
    user_id: number
    chapter_id: number
    subscribed: boolean
  }

  export type chapter_role_permissionsCreateManyChapter_roleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter_permissions_id: number
  }

  export type chapter_usersUpdateWithoutChapter_roleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    user?: usersUpdateOneRequiredWithoutUser_chaptersNestedInput
    chapter?: chaptersUpdateOneRequiredWithoutChapter_usersNestedInput
  }

  export type chapter_usersUncheckedUpdateWithoutChapter_roleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    chapter_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chapter_usersUncheckedUpdateManyWithoutChapter_roleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    chapter_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chapter_role_permissionsUpdateWithoutChapter_roleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter_permission?: chapter_permissionsUpdateOneRequiredWithoutChapter_role_permissionsNestedInput
  }

  export type chapter_role_permissionsUncheckedUpdateWithoutChapter_roleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter_permissions_id?: IntFieldUpdateOperationsInput | number
  }

  export type chapter_role_permissionsUncheckedUpdateManyWithoutChapter_roleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter_permissions_id?: IntFieldUpdateOperationsInput | number
  }

  export type chapter_role_permissionsCreateManyChapter_permissionInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter_role_id: number
  }

  export type chapter_role_permissionsUpdateWithoutChapter_permissionInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter_role?: chapter_rolesUpdateOneRequiredWithoutChapter_role_permissionsNestedInput
  }

  export type chapter_role_permissionsUncheckedUpdateWithoutChapter_permissionInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter_role_id?: IntFieldUpdateOperationsInput | number
  }

  export type chapter_role_permissionsUncheckedUpdateManyWithoutChapter_permissionInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter_role_id?: IntFieldUpdateOperationsInput | number
  }

  export type event_sponsorsCreateManyEventInput = {
    created_at?: Date | string
    updated_at?: Date | string
    sponsor_id: number
  }

  export type event_tagsCreateManyEventInput = {
    created_at?: Date | string
    updated_at?: Date | string
    tag_id: number
  }

  export type event_usersCreateManyEventInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date?: Date | string
    user_id: number
    event_role_id: number
    attendance_id: number
    subscribed: boolean
    title?: event_usersCreatetitleInput | string[]
  }

  export type event_sponsorsUpdateWithoutEventInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sponsor?: sponsorsUpdateOneRequiredWithoutEvent_sponsorsNestedInput
  }

  export type event_sponsorsUncheckedUpdateWithoutEventInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sponsor_id?: IntFieldUpdateOperationsInput | number
  }

  export type event_sponsorsUncheckedUpdateManyWithoutEventInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sponsor_id?: IntFieldUpdateOperationsInput | number
  }

  export type event_tagsUpdateWithoutEventInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: tagsUpdateOneRequiredWithoutEvent_tagsNestedInput
  }

  export type event_tagsUncheckedUpdateWithoutEventInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type event_tagsUncheckedUpdateManyWithoutEventInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type event_usersUpdateWithoutEventInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    title?: event_usersUpdatetitleInput | string[]
    user?: usersUpdateOneRequiredWithoutUser_eventsNestedInput
    event_role?: event_rolesUpdateOneRequiredWithoutEvent_usersNestedInput
    attendance?: attendanceUpdateOneRequiredWithoutEvent_usersNestedInput
    event_reminder?: event_remindersUpdateOneWithoutEvent_userNestedInput
  }

  export type event_usersUncheckedUpdateWithoutEventInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    event_role_id?: IntFieldUpdateOperationsInput | number
    attendance_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    title?: event_usersUpdatetitleInput | string[]
    event_reminder?: event_remindersUncheckedUpdateOneWithoutEvent_userNestedInput
  }

  export type event_usersUncheckedUpdateManyWithoutEventInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    event_role_id?: IntFieldUpdateOperationsInput | number
    attendance_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    title?: event_usersUpdatetitleInput | string[]
  }

  export type event_role_permissionsCreateManyEvent_roleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event_permission_id: number
  }

  export type event_usersCreateManyEvent_roleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date?: Date | string
    user_id: number
    event_id: number
    attendance_id: number
    subscribed: boolean
    title?: event_usersCreatetitleInput | string[]
  }

  export type event_role_permissionsUpdateWithoutEvent_roleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_permission?: event_permissionsUpdateOneRequiredWithoutEvent_role_permissionsNestedInput
  }

  export type event_role_permissionsUncheckedUpdateWithoutEvent_roleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type event_role_permissionsUncheckedUpdateManyWithoutEvent_roleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type event_usersUpdateWithoutEvent_roleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    title?: event_usersUpdatetitleInput | string[]
    user?: usersUpdateOneRequiredWithoutUser_eventsNestedInput
    event?: eventsUpdateOneRequiredWithoutEvent_usersNestedInput
    attendance?: attendanceUpdateOneRequiredWithoutEvent_usersNestedInput
    event_reminder?: event_remindersUpdateOneWithoutEvent_userNestedInput
  }

  export type event_usersUncheckedUpdateWithoutEvent_roleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    attendance_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    title?: event_usersUpdatetitleInput | string[]
    event_reminder?: event_remindersUncheckedUpdateOneWithoutEvent_userNestedInput
  }

  export type event_usersUncheckedUpdateManyWithoutEvent_roleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    attendance_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    title?: event_usersUpdatetitleInput | string[]
  }

  export type event_role_permissionsCreateManyEvent_permissionInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event_role_id: number
  }

  export type event_role_permissionsUpdateWithoutEvent_permissionInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_role?: event_rolesUpdateOneRequiredWithoutEvent_role_permissionsNestedInput
  }

  export type event_role_permissionsUncheckedUpdateWithoutEvent_permissionInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_role_id?: IntFieldUpdateOperationsInput | number
  }

  export type event_role_permissionsUncheckedUpdateManyWithoutEvent_permissionInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_role_id?: IntFieldUpdateOperationsInput | number
  }

  export type event_usersCreateManyAttendanceInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date?: Date | string
    user_id: number
    event_id: number
    event_role_id: number
    subscribed: boolean
    title?: event_usersCreatetitleInput | string[]
  }

  export type event_usersUpdateWithoutAttendanceInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    title?: event_usersUpdatetitleInput | string[]
    user?: usersUpdateOneRequiredWithoutUser_eventsNestedInput
    event?: eventsUpdateOneRequiredWithoutEvent_usersNestedInput
    event_role?: event_rolesUpdateOneRequiredWithoutEvent_usersNestedInput
    event_reminder?: event_remindersUpdateOneWithoutEvent_userNestedInput
  }

  export type event_usersUncheckedUpdateWithoutAttendanceInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    event_role_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    title?: event_usersUpdatetitleInput | string[]
    event_reminder?: event_remindersUncheckedUpdateOneWithoutEvent_userNestedInput
  }

  export type event_usersUncheckedUpdateManyWithoutAttendanceInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    event_role_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    title?: event_usersUpdatetitleInput | string[]
  }

  export type event_sponsorsCreateManySponsorInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event_id: number
  }

  export type event_sponsorsUpdateWithoutSponsorInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: eventsUpdateOneRequiredWithoutSponsorsNestedInput
  }

  export type event_sponsorsUncheckedUpdateWithoutSponsorInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type event_sponsorsUncheckedUpdateManyWithoutSponsorInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type chapter_tagsCreateManyTagInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter_id: number
  }

  export type event_tagsCreateManyTagInput = {
    created_at?: Date | string
    updated_at?: Date | string
    event_id: number
  }

  export type venue_tagsCreateManyTagInput = {
    created_at?: Date | string
    updated_at?: Date | string
    venue_id: number
  }

  export type chapter_tagsUpdateWithoutTagInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: chaptersUpdateOneRequiredWithoutChapter_tagsNestedInput
  }

  export type chapter_tagsUncheckedUpdateWithoutTagInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter_id?: IntFieldUpdateOperationsInput | number
  }

  export type chapter_tagsUncheckedUpdateManyWithoutTagInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter_id?: IntFieldUpdateOperationsInput | number
  }

  export type event_tagsUpdateWithoutTagInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: eventsUpdateOneRequiredWithoutEvent_tagsNestedInput
  }

  export type event_tagsUncheckedUpdateWithoutTagInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type event_tagsUncheckedUpdateManyWithoutTagInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type venue_tagsUpdateWithoutTagInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: venuesUpdateOneRequiredWithoutVenue_tagsNestedInput
  }

  export type venue_tagsUncheckedUpdateWithoutTagInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
  }

  export type venue_tagsUncheckedUpdateManyWithoutTagInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
  }

  export type instance_role_permissionsCreateManyInstance_permissionInput = {
    created_at?: Date | string
    updated_at?: Date | string
    instance_role_id: number
  }

  export type instance_role_permissionsUpdateWithoutInstance_permissionInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_role?: instance_rolesUpdateOneRequiredWithoutInstance_role_permissionsNestedInput
  }

  export type instance_role_permissionsUncheckedUpdateWithoutInstance_permissionInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_role_id?: IntFieldUpdateOperationsInput | number
  }

  export type instance_role_permissionsUncheckedUpdateManyWithoutInstance_permissionInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_role_id?: IntFieldUpdateOperationsInput | number
  }

  export type instance_role_permissionsCreateManyInstance_roleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    instance_permission_id: number
  }

  export type usersCreateManyInstance_roleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    image_url?: string | null
    email: string
    auto_subscribe?: boolean
  }

  export type instance_role_permissionsUpdateWithoutInstance_roleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_permission?: instance_permissionsUpdateOneRequiredWithoutInstance_role_permissionsNestedInput
  }

  export type instance_role_permissionsUncheckedUpdateWithoutInstance_roleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type instance_role_permissionsUncheckedUpdateManyWithoutInstance_roleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instance_permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type usersUpdateWithoutInstance_roleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    auto_subscribe?: BoolFieldUpdateOperationsInput | boolean
    user_bans?: user_bansUpdateManyWithoutUserNestedInput
    user_chapters?: chapter_usersUpdateManyWithoutUserNestedInput
    user_events?: event_usersUpdateManyWithoutUserNestedInput
    session?: sessionsUpdateOneWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutInstance_roleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    auto_subscribe?: BoolFieldUpdateOperationsInput | boolean
    user_bans?: user_bansUncheckedUpdateManyWithoutUserNestedInput
    user_chapters?: chapter_usersUncheckedUpdateManyWithoutUserNestedInput
    user_events?: event_usersUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type usersUncheckedUpdateManyWithoutInstance_roleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    auto_subscribe?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user_bansCreateManyUserInput = {
    created_at?: Date | string
    updated_at?: Date | string
    chapter_id: number
  }

  export type chapter_usersCreateManyUserInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date: Date | string
    chapter_id: number
    chapter_role_id: number
    subscribed: boolean
  }

  export type event_usersCreateManyUserInput = {
    created_at?: Date | string
    updated_at?: Date | string
    joined_date?: Date | string
    event_id: number
    event_role_id: number
    attendance_id: number
    subscribed: boolean
    title?: event_usersCreatetitleInput | string[]
  }

  export type user_bansUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: chaptersUpdateOneRequiredWithoutUser_bansNestedInput
  }

  export type user_bansUncheckedUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_bansUncheckedUpdateManyWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter_id?: IntFieldUpdateOperationsInput | number
  }

  export type chapter_usersUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    chapter?: chaptersUpdateOneRequiredWithoutChapter_usersNestedInput
    chapter_role?: chapter_rolesUpdateOneRequiredWithoutChapter_usersNestedInput
  }

  export type chapter_usersUncheckedUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter_id?: IntFieldUpdateOperationsInput | number
    chapter_role_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type chapter_usersUncheckedUpdateManyWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter_id?: IntFieldUpdateOperationsInput | number
    chapter_role_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type event_usersUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    title?: event_usersUpdatetitleInput | string[]
    event?: eventsUpdateOneRequiredWithoutEvent_usersNestedInput
    event_role?: event_rolesUpdateOneRequiredWithoutEvent_usersNestedInput
    attendance?: attendanceUpdateOneRequiredWithoutEvent_usersNestedInput
    event_reminder?: event_remindersUpdateOneWithoutEvent_userNestedInput
  }

  export type event_usersUncheckedUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_id?: IntFieldUpdateOperationsInput | number
    event_role_id?: IntFieldUpdateOperationsInput | number
    attendance_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    title?: event_usersUpdatetitleInput | string[]
    event_reminder?: event_remindersUncheckedUpdateOneWithoutEvent_userNestedInput
  }

  export type event_usersUncheckedUpdateManyWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    joined_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_id?: IntFieldUpdateOperationsInput | number
    event_role_id?: IntFieldUpdateOperationsInput | number
    attendance_id?: IntFieldUpdateOperationsInput | number
    subscribed?: BoolFieldUpdateOperationsInput | boolean
    title?: event_usersUpdatetitleInput | string[]
  }

  export type eventsCreateManyVenueInput = {
    created_at?: Date | string
    updated_at?: Date | string
    id?: number
    name: string
    description: string
    url?: string | null
    streaming_url?: string | null
    venue_type?: events_venue_type_enum
    start_at: Date | string
    ends_at: Date | string
    canceled?: boolean
    capacity: number
    invite_only?: boolean
    image_url: string
    chapter_id: number
    calendar_event_id?: string | null
  }

  export type venue_tagsCreateManyVenueInput = {
    created_at?: Date | string
    updated_at?: Date | string
    tag_id: number
  }

  export type eventsUpdateWithoutVenueInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    venue_type?: Enumevents_venue_type_enumFieldUpdateOperationsInput | events_venue_type_enum
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    canceled?: BoolFieldUpdateOperationsInput | boolean
    capacity?: IntFieldUpdateOperationsInput | number
    invite_only?: BoolFieldUpdateOperationsInput | boolean
    image_url?: StringFieldUpdateOperationsInput | string
    calendar_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    chapter?: chaptersUpdateOneRequiredWithoutEventsNestedInput
    sponsors?: event_sponsorsUpdateManyWithoutEventNestedInput
    event_tags?: event_tagsUpdateManyWithoutEventNestedInput
    event_users?: event_usersUpdateManyWithoutEventNestedInput
  }

  export type eventsUncheckedUpdateWithoutVenueInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    venue_type?: Enumevents_venue_type_enumFieldUpdateOperationsInput | events_venue_type_enum
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    canceled?: BoolFieldUpdateOperationsInput | boolean
    capacity?: IntFieldUpdateOperationsInput | number
    invite_only?: BoolFieldUpdateOperationsInput | boolean
    image_url?: StringFieldUpdateOperationsInput | string
    chapter_id?: IntFieldUpdateOperationsInput | number
    calendar_event_id?: NullableStringFieldUpdateOperationsInput | string | null
    sponsors?: event_sponsorsUncheckedUpdateManyWithoutEventNestedInput
    event_tags?: event_tagsUncheckedUpdateManyWithoutEventNestedInput
    event_users?: event_usersUncheckedUpdateManyWithoutEventNestedInput
  }

  export type eventsUncheckedUpdateManyWithoutVenueInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    venue_type?: Enumevents_venue_type_enumFieldUpdateOperationsInput | events_venue_type_enum
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ends_at?: DateTimeFieldUpdateOperationsInput | Date | string
    canceled?: BoolFieldUpdateOperationsInput | boolean
    capacity?: IntFieldUpdateOperationsInput | number
    invite_only?: BoolFieldUpdateOperationsInput | boolean
    image_url?: StringFieldUpdateOperationsInput | string
    chapter_id?: IntFieldUpdateOperationsInput | number
    calendar_event_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type venue_tagsUpdateWithoutVenueInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: tagsUpdateOneRequiredWithoutVenue_tagsNestedInput
  }

  export type venue_tagsUncheckedUpdateWithoutVenueInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type venue_tagsUncheckedUpdateManyWithoutVenueInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tag_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}